import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// node_modules/hls.js/dist/hls.js
var require_hls = __commonJS({
  "node_modules/hls.js/dist/hls.js"(exports, module) {
    typeof window !== "undefined" && function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Hls"] = factory();
      else
        root["Hls"] = factory();
    }(exports, () => {
      return (
        /******/
        (() => {
          var __webpack_modules__ = {
            /***/
            "./src/config.ts": (
              /*!***********************!*\
                !*** ./src/config.ts ***!
                \***********************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "enableStreamingMode": () => (
                    /* binding */
                    enableStreamingMode
                  ),
                  /* harmony export */
                  "hlsDefaultConfig": () => (
                    /* binding */
                    hlsDefaultConfig
                  ),
                  /* harmony export */
                  "mergeConfig": () => (
                    /* binding */
                    mergeConfig
                  )
                  /* harmony export */
                });
                var _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./controller/abr-controller */
                  "./src/controller/abr-controller.ts"
                );
                var _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./controller/audio-stream-controller */
                  "./src/controller/audio-stream-controller.ts"
                );
                var _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./controller/audio-track-controller */
                  "./src/controller/audio-track-controller.ts"
                );
                var _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./controller/subtitle-stream-controller */
                  "./src/controller/subtitle-stream-controller.ts"
                );
                var _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./controller/subtitle-track-controller */
                  "./src/controller/subtitle-track-controller.ts"
                );
                var _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./controller/buffer-controller */
                  "./src/controller/buffer-controller.ts"
                );
                var _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ./controller/timeline-controller */
                  "./src/controller/timeline-controller.ts"
                );
                var _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ./controller/cap-level-controller */
                  "./src/controller/cap-level-controller.ts"
                );
                var _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ./controller/fps-controller */
                  "./src/controller/fps-controller.ts"
                );
                var _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ./controller/eme-controller */
                  "./src/controller/eme-controller.ts"
                );
                var _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                  /*! ./controller/cmcd-controller */
                  "./src/controller/cmcd-controller.ts"
                );
                var _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                  /*! ./utils/xhr-loader */
                  "./src/utils/xhr-loader.ts"
                );
                var _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                  /*! ./utils/fetch-loader */
                  "./src/utils/fetch-loader.ts"
                );
                var _utils_cues__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                  /*! ./utils/cues */
                  "./src/utils/cues.ts"
                );
                var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                  /*! ./utils/mediakeys-helper */
                  "./src/utils/mediakeys-helper.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__2(
                  /*! ./utils/logger */
                  "./src/utils/logger.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                function ownKeys(object, enumerableOnly) {
                  var keys = Object.keys(object);
                  if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    enumerableOnly && (symbols = symbols.filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    })), keys.push.apply(keys, symbols);
                  }
                  return keys;
                }
                function _objectSpread(target) {
                  for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
                      _defineProperty(target, key, source[key]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                  }
                  return target;
                }
                function _defineProperty(obj, key, value) {
                  key = _toPropertyKey(key);
                  if (key in obj) {
                    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var hlsDefaultConfig = _objectSpread(_objectSpread({
                  autoStartLoad: true,
                  // used by stream-controller
                  startPosition: -1,
                  // used by stream-controller
                  defaultAudioCodec: void 0,
                  // used by stream-controller
                  debug: false,
                  // used by logger
                  capLevelOnFPSDrop: false,
                  // used by fps-controller
                  capLevelToPlayerSize: false,
                  // used by cap-level-controller
                  ignoreDevicePixelRatio: false,
                  // used by cap-level-controller
                  initialLiveManifestSize: 1,
                  // used by stream-controller
                  maxBufferLength: 30,
                  // used by stream-controller
                  backBufferLength: Infinity,
                  // used by buffer-controller
                  maxBufferSize: 60 * 1e3 * 1e3,
                  // used by stream-controller
                  maxBufferHole: 0.1,
                  // used by stream-controller
                  highBufferWatchdogPeriod: 2,
                  // used by stream-controller
                  nudgeOffset: 0.1,
                  // used by stream-controller
                  nudgeMaxRetry: 3,
                  // used by stream-controller
                  maxFragLookUpTolerance: 0.25,
                  // used by stream-controller
                  liveSyncDurationCount: 3,
                  // used by latency-controller
                  liveMaxLatencyDurationCount: Infinity,
                  // used by latency-controller
                  liveSyncDuration: void 0,
                  // used by latency-controller
                  liveMaxLatencyDuration: void 0,
                  // used by latency-controller
                  maxLiveSyncPlaybackRate: 1,
                  // used by latency-controller
                  liveDurationInfinity: false,
                  // used by buffer-controller
                  liveBackBufferLength: null,
                  // used by buffer-controller
                  maxMaxBufferLength: 600,
                  // used by stream-controller
                  enableWorker: true,
                  // used by demuxer
                  enableSoftwareAES: true,
                  // used by decrypter
                  manifestLoadingTimeOut: 1e4,
                  // used by playlist-loader
                  manifestLoadingMaxRetry: 1,
                  // used by playlist-loader
                  manifestLoadingRetryDelay: 1e3,
                  // used by playlist-loader
                  manifestLoadingMaxRetryTimeout: 64e3,
                  // used by playlist-loader
                  startLevel: void 0,
                  // used by level-controller
                  levelLoadingTimeOut: 1e4,
                  // used by playlist-loader
                  levelLoadingMaxRetry: 4,
                  // used by playlist-loader
                  levelLoadingRetryDelay: 1e3,
                  // used by playlist-loader
                  levelLoadingMaxRetryTimeout: 64e3,
                  // used by playlist-loader
                  fragLoadingTimeOut: 2e4,
                  // used by fragment-loader
                  fragLoadingMaxRetry: 6,
                  // used by fragment-loader
                  fragLoadingRetryDelay: 1e3,
                  // used by fragment-loader
                  fragLoadingMaxRetryTimeout: 64e3,
                  // used by fragment-loader
                  startFragPrefetch: false,
                  // used by stream-controller
                  fpsDroppedMonitoringPeriod: 5e3,
                  // used by fps-controller
                  fpsDroppedMonitoringThreshold: 0.2,
                  // used by fps-controller
                  appendErrorMaxRetry: 3,
                  // used by buffer-controller
                  loader: _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__["default"],
                  // loader: FetchLoader,
                  fLoader: void 0,
                  // used by fragment-loader
                  pLoader: void 0,
                  // used by playlist-loader
                  xhrSetup: void 0,
                  // used by xhr-loader
                  licenseXhrSetup: void 0,
                  // used by eme-controller
                  licenseResponseCallback: void 0,
                  // used by eme-controller
                  abrController: _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__["default"],
                  bufferController: _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__["default"],
                  capLevelController: _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__["default"],
                  fpsController: _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__["default"],
                  stretchShortVideoTrack: false,
                  // used by mp4-remuxer
                  maxAudioFramesDrift: 1,
                  // used by mp4-remuxer
                  forceKeyFrameOnDiscontinuity: true,
                  // used by ts-demuxer
                  abrEwmaFastLive: 3,
                  // used by abr-controller
                  abrEwmaSlowLive: 9,
                  // used by abr-controller
                  abrEwmaFastVoD: 3,
                  // used by abr-controller
                  abrEwmaSlowVoD: 9,
                  // used by abr-controller
                  abrEwmaDefaultEstimate: 5e5,
                  // 500 kbps  // used by abr-controller
                  abrBandWidthFactor: 0.95,
                  // used by abr-controller
                  abrBandWidthUpFactor: 0.7,
                  // used by abr-controller
                  abrMaxWithRealBitrate: false,
                  // used by abr-controller
                  maxStarvationDelay: 4,
                  // used by abr-controller
                  maxLoadingDelay: 4,
                  // used by abr-controller
                  minAutoBitrate: 0,
                  // used by hls
                  emeEnabled: false,
                  // used by eme-controller
                  widevineLicenseUrl: void 0,
                  // used by eme-controller
                  drmSystems: {},
                  // used by eme-controller
                  drmSystemOptions: {},
                  // used by eme-controller
                  requestMediaKeySystemAccessFunc: _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__.requestMediaKeySystemAccess,
                  // used by eme-controller
                  testBandwidth: true,
                  progressive: false,
                  lowLatencyMode: true,
                  cmcd: void 0,
                  enableDateRangeMetadataCues: true,
                  enableEmsgMetadataCues: true,
                  enableID3MetadataCues: true
                }, timelineConfig()), {}, {
                  subtitleStreamController: true ? _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__.SubtitleStreamController : 0,
                  subtitleTrackController: true ? _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__["default"] : 0,
                  timelineController: true ? _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__.TimelineController : 0,
                  audioStreamController: true ? _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"] : 0,
                  audioTrackController: true ? _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__["default"] : 0,
                  emeController: true ? _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__["default"] : 0,
                  cmcdController: true ? _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__["default"] : 0
                });
                function timelineConfig() {
                  return {
                    cueHandler: _utils_cues__WEBPACK_IMPORTED_MODULE_13__["default"],
                    // used by timeline-controller
                    enableWebVTT: true,
                    // used by timeline-controller
                    enableIMSC1: true,
                    // used by timeline-controller
                    enableCEA708Captions: true,
                    // used by timeline-controller
                    captionsTextTrack1Label: "English",
                    // used by timeline-controller
                    captionsTextTrack1LanguageCode: "en",
                    // used by timeline-controller
                    captionsTextTrack2Label: "Spanish",
                    // used by timeline-controller
                    captionsTextTrack2LanguageCode: "es",
                    // used by timeline-controller
                    captionsTextTrack3Label: "Unknown CC",
                    // used by timeline-controller
                    captionsTextTrack3LanguageCode: "",
                    // used by timeline-controller
                    captionsTextTrack4Label: "Unknown CC",
                    // used by timeline-controller
                    captionsTextTrack4LanguageCode: "",
                    // used by timeline-controller
                    renderTextTracksNatively: true
                  };
                }
                function mergeConfig(defaultConfig, userConfig) {
                  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
                    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                  }
                  if (userConfig.liveMaxLatencyDurationCount !== void 0 && (userConfig.liveSyncDurationCount === void 0 || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
                    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                  }
                  if (userConfig.liveMaxLatencyDuration !== void 0 && (userConfig.liveSyncDuration === void 0 || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
                    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                  }
                  return _extends({}, defaultConfig, userConfig);
                }
                function enableStreamingMode(config) {
                  var currentLoader = config.loader;
                  if (currentLoader !== _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__["default"] && currentLoader !== _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__["default"]) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_15__.logger.log("[config]: Custom loader detected, cannot enable progressive streaming");
                    config.progressive = false;
                  } else {
                    var canStreamProgressively = (0, _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__.fetchSupported)();
                    if (canStreamProgressively) {
                      config.loader = _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__["default"];
                      config.progressive = true;
                      config.enableSoftwareAES = true;
                      _utils_logger__WEBPACK_IMPORTED_MODULE_15__.logger.log("[config]: Progressive streaming enabled, using FetchLoader");
                    }
                  }
                }
              }
            ),
            /***/
            "./src/controller/abr-controller.ts": (
              /*!******************************************!*\
                !*** ./src/controller/abr-controller.ts ***!
                \******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/ewma-bandwidth-estimator */
                  "./src/utils/ewma-bandwidth-estimator.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var AbrController = function() {
                  function AbrController2(hls) {
                    this.hls = void 0;
                    this.lastLoadedFragLevel = 0;
                    this._nextAutoLevel = -1;
                    this.timer = void 0;
                    this.onCheck = this._abandonRulesCheck.bind(this);
                    this.fragCurrent = null;
                    this.partCurrent = null;
                    this.bitrateTestDelay = 0;
                    this.bwEstimator = void 0;
                    this.hls = hls;
                    var config = hls.config;
                    this.bwEstimator = new _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__["default"](config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
                    this.registerListeners();
                  }
                  var _proto = AbrController2.prototype;
                  _proto.registerListeners = function registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADING, this.onFragLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADED, this.onFragLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADING, this.onFragLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOADED, this.onFragLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);
                  };
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.clearTimer();
                    this.hls = this.onCheck = null;
                    this.fragCurrent = this.partCurrent = null;
                  };
                  _proto.onFragLoading = function onFragLoading(event, data) {
                    var frag = data.frag;
                    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN) {
                      if (!this.timer) {
                        var _data$part;
                        this.fragCurrent = frag;
                        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
                        this.timer = self.setInterval(this.onCheck, 100);
                      }
                    }
                  };
                  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                    var config = this.hls.config;
                    if (data.details.live) {
                      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
                    } else {
                      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
                    }
                  };
                  _proto._abandonRulesCheck = function _abandonRulesCheck() {
                    var frag = this.fragCurrent, part = this.partCurrent, hls = this.hls;
                    var autoLevelEnabled = hls.autoLevelEnabled, media = hls.media;
                    if (!frag || !media) {
                      return;
                    }
                    var stats = part ? part.stats : frag.stats;
                    var duration = part ? part.duration : frag.duration;
                    if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {
                      this.clearTimer();
                      this._nextAutoLevel = -1;
                      return;
                    }
                    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
                      return;
                    }
                    var bufferInfo = hls.mainForwardBufferInfo;
                    if (bufferInfo === null) {
                      return;
                    }
                    var requestDelay = performance.now() - stats.loading.start;
                    var playbackRate = Math.abs(media.playbackRate);
                    if (requestDelay <= 500 * duration / playbackRate) {
                      return;
                    }
                    var loadedFirstByte = stats.loaded && stats.loading.first;
                    var bwEstimate = this.bwEstimator.getEstimate();
                    var levels = hls.levels, minAutoLevel = hls.minAutoLevel;
                    var level = levels[frag.level];
                    var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));
                    var loadRate = loadedFirstByte ? stats.loaded * 1e3 / requestDelay : 0;
                    var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate;
                    var bufferStarvationDelay = bufferInfo.len / playbackRate;
                    if (fragLoadedDelay <= bufferStarvationDelay) {
                      return;
                    }
                    var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
                    var nextLoadLevel;
                    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
                      var levelNextBitrate = levels[nextLoadLevel].maxBitrate;
                      fragLevelNextLoadedDelay = loadRate ? duration * levelNextBitrate / (8 * 0.8 * loadRate) : duration * levelNextBitrate / bwEstimate;
                      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                        break;
                      }
                    }
                    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
                      return;
                    }
                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Fragment " + frag.sn + (part ? " part " + part.index : "") + " of level " + frag.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + nextLoadLevel + "\n      Current BW estimate: " + ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : "Unknown") + " Kb/s\n      Estimated load time for current fragment: " + fragLoadedDelay.toFixed(3) + " s\n      Estimated load time for the next fragment: " + fragLevelNextLoadedDelay.toFixed(3) + " s\n      Time to underbuffer: " + bufferStarvationDelay.toFixed(3) + " s");
                    hls.nextLoadLevel = nextLoadLevel;
                    if (loadedFirstByte) {
                      this.bwEstimator.sample(requestDelay, stats.loaded);
                    }
                    this.clearTimer();
                    if (frag.loader || frag.keyLoader) {
                      this.fragCurrent = this.partCurrent = null;
                      frag.abortRequests();
                    }
                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_LOAD_EMERGENCY_ABORTED, {
                      frag,
                      part,
                      stats
                    });
                  };
                  _proto.onFragLoaded = function onFragLoaded(event, _ref) {
                    var frag = _ref.frag, part = _ref.part;
                    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.sn)) {
                      var stats = part ? part.stats : frag.stats;
                      var duration = part ? part.duration : frag.duration;
                      this.clearTimer();
                      this.lastLoadedFragLevel = frag.level;
                      this._nextAutoLevel = -1;
                      if (this.hls.config.abrMaxWithRealBitrate) {
                        var level = this.hls.levels[frag.level];
                        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
                        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
                        level.loaded = {
                          bytes: loadedBytes,
                          duration: loadedDuration
                        };
                        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
                      }
                      if (frag.bitrateTest) {
                        var fragBufferedData = {
                          stats,
                          frag,
                          part,
                          id: frag.type
                        };
                        this.onFragBuffered(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, fragBufferedData);
                      }
                    }
                  };
                  _proto.onFragBuffered = function onFragBuffered(event, data) {
                    var frag = data.frag, part = data.part;
                    var stats = part ? part.stats : frag.stats;
                    if (stats.aborted) {
                      return;
                    }
                    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN || frag.sn === "initSegment") {
                      return;
                    }
                    var processingMs = stats.parsing.end - stats.loading.start;
                    this.bwEstimator.sample(processingMs, stats.loaded);
                    stats.bwEstimate = this.bwEstimator.getEstimate();
                    if (frag.bitrateTest) {
                      this.bitrateTestDelay = processingMs / 1e3;
                    } else {
                      this.bitrateTestDelay = 0;
                    }
                  };
                  _proto.onError = function onError(event, data) {
                    var _data$frag;
                    if (((_data$frag = data.frag) === null || _data$frag === void 0 ? void 0 : _data$frag.type) === _types_loader__WEBPACK_IMPORTED_MODULE_4__.PlaylistLevelType.MAIN) {
                      if (data.type === _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.KEY_SYSTEM_ERROR) {
                        this.clearTimer();
                        return;
                      }
                      switch (data.details) {
                        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.FRAG_LOAD_ERROR:
                        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.FRAG_LOAD_TIMEOUT:
                        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.KEY_LOAD_ERROR:
                        case _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.KEY_LOAD_TIMEOUT:
                          this.clearTimer();
                          break;
                        default:
                          break;
                      }
                    }
                  };
                  _proto.clearTimer = function clearTimer() {
                    self.clearInterval(this.timer);
                    this.timer = void 0;
                  };
                  _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {
                    var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent, hls = this.hls;
                    var maxAutoLevel = hls.maxAutoLevel, config = hls.config, minAutoLevel = hls.minAutoLevel, media = hls.media;
                    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
                    var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
                    var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;
                    var bufferInfo = hls.mainForwardBufferInfo;
                    var bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;
                    var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);
                    if (bestLevel >= 0) {
                      return bestLevel;
                    }
                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace((bufferStarvationDelay ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
                    var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
                    var bwFactor = config.abrBandWidthFactor;
                    var bwUpFactor = config.abrBandWidthUpFactor;
                    if (!bufferStarvationDelay) {
                      var bitrateTestDelay = this.bitrateTestDelay;
                      if (bitrateTestDelay) {
                        var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
                        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace("bitrate test took " + Math.round(1e3 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * maxStarvationDelay) + " ms");
                        bwFactor = bwUpFactor = 1;
                      }
                    }
                    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);
                    return Math.max(bestLevel, 0);
                  };
                  _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {
                    var _level$details;
                    var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent, currentLevel = this.lastLoadedFragLevel;
                    var levels = this.hls.levels;
                    var level = levels[currentLevel];
                    var live = !!(level !== null && level !== void 0 && (_level$details = level.details) !== null && _level$details !== void 0 && _level$details.live);
                    var currentCodecSet = level === null || level === void 0 ? void 0 : level.codecSet;
                    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
                    for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
                      var levelInfo = levels[i];
                      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {
                        continue;
                      }
                      var levelDetails = levelInfo.details;
                      var avgDuration = (partCurrent ? levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.partTarget : levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
                      var adjustedbw = void 0;
                      if (i <= currentLevel) {
                        adjustedbw = bwFactor * currentBw;
                      } else {
                        adjustedbw = bwUpFactor * currentBw;
                      }
                      var bitrate = levels[i].maxBitrate;
                      var fetchDuration = bitrate * avgDuration / adjustedbw;
                      _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + i + "/" + Math.round(adjustedbw) + "/" + bitrate + "/" + avgDuration + "/" + maxFetchDuration + "/" + fetchDuration);
                      if (adjustedbw > bitrate && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
                      (fetchDuration === 0 || !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
                        return i;
                      }
                    }
                    return -1;
                  };
                  _createClass(AbrController2, [{
                    key: "nextAutoLevel",
                    get: function get() {
                      var forcedAutoLevel = this._nextAutoLevel;
                      var bwEstimator = this.bwEstimator;
                      if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {
                        return forcedAutoLevel;
                      }
                      var nextABRAutoLevel = this.getNextABRAutoLevel();
                      if (forcedAutoLevel !== -1 && this.hls.levels[nextABRAutoLevel].loadError) {
                        return forcedAutoLevel;
                      }
                      if (forcedAutoLevel !== -1) {
                        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
                      }
                      return nextABRAutoLevel;
                    },
                    set: function set(nextLevel) {
                      this._nextAutoLevel = nextLevel;
                    }
                  }]);
                  return AbrController2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = AbrController;
              }
            ),
            /***/
            "./src/controller/audio-stream-controller.ts": (
              /*!***************************************************!*\
                !*** ./src/controller/audio-stream-controller.ts ***!
                \***************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./base-stream-controller */
                  "./src/controller/base-stream-controller.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/buffer-helper */
                  "./src/utils/buffer-helper.ts"
                );
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./fragment-tracker */
                  "./src/controller/fragment-tracker.ts"
                );
                var _types_level__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../types/level */
                  "./src/types/level.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../loader/fragment */
                  "./src/loader/fragment.ts"
                );
                var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../demux/chunk-cache */
                  "./src/demux/chunk-cache.ts"
                );
                var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ../demux/transmuxer-interface */
                  "./src/demux/transmuxer-interface.ts"
                );
                var _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                  /*! ../types/transmuxer */
                  "./src/types/transmuxer.ts"
                );
                var _fragment_finders__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                  /*! ./fragment-finders */
                  "./src/controller/fragment-finders.ts"
                );
                var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                  /*! ../utils/discontinuities */
                  "./src/utils/discontinuities.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var TICK_INTERVAL = 100;
                var AudioStreamController = function(_BaseStreamController) {
                  _inheritsLoose(AudioStreamController2, _BaseStreamController);
                  function AudioStreamController2(hls, fragmentTracker, keyLoader) {
                    var _this;
                    _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[audio-stream-controller]") || this;
                    _this.videoBuffer = null;
                    _this.videoTrackCC = -1;
                    _this.waitingVideoCC = -1;
                    _this.audioSwitch = false;
                    _this.trackId = -1;
                    _this.waitingData = null;
                    _this.mainDetails = null;
                    _this.bufferFlushed = false;
                    _this.cachedTrackLoadedData = null;
                    _this._registerListeners();
                    return _this;
                  }
                  var _proto = AudioStreamController2.prototype;
                  _proto.onHandlerDestroying = function onHandlerDestroying() {
                    this._unregisterListeners();
                    this.mainDetails = null;
                  };
                  _proto._registerListeners = function _registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_RESET, this.onBufferReset, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_CREATED, this.onBufferCreated, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                  };
                  _proto._unregisterListeners = function _unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, this.onError, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_RESET, this.onBufferReset, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_CREATED, this.onBufferCreated, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                  };
                  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
                    var frag = _ref.frag, id = _ref.id, initPTS = _ref.initPTS;
                    if (id === "main") {
                      var cc = frag.cc;
                      this.initPTS[frag.cc] = initPTS;
                      this.log("InitPTS for cc: " + cc + " found from main: " + initPTS);
                      this.videoTrackCC = cc;
                      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS) {
                        this.tick();
                      }
                    }
                  };
                  _proto.startLoad = function startLoad(startPosition) {
                    if (!this.levels) {
                      this.startPosition = startPosition;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED;
                      return;
                    }
                    var lastCurrentTime = this.lastCurrentTime;
                    this.stopLoad();
                    this.setInterval(TICK_INTERVAL);
                    this.fragLoadError = 0;
                    if (lastCurrentTime > 0 && startPosition === -1) {
                      this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                      startPosition = lastCurrentTime;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                    } else {
                      this.loadedmetadata = false;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK;
                    }
                    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
                    this.tick();
                  };
                  _proto.doTick = function doTick() {
                    switch (this.state) {
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE:
                        this.doTickIdle();
                        break;
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK: {
                        var _levels$trackId;
                        var levels = this.levels, trackId = this.trackId;
                        var details = levels === null || levels === void 0 ? void 0 : (_levels$trackId = levels[trackId]) === null || _levels$trackId === void 0 ? void 0 : _levels$trackId.details;
                        if (details) {
                          if (this.waitForCdnTuneIn(details)) {
                            break;
                          }
                          this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS;
                        }
                        break;
                      }
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY: {
                        var _this$media;
                        var now = performance.now();
                        var retryDate = this.retryDate;
                        if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {
                          this.log("RetryDate reached, switch back to IDLE state");
                          this.resetStartWhenNotLoaded(this.trackId);
                          this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                        }
                        break;
                      }
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS: {
                        var waitingData = this.waitingData;
                        if (waitingData) {
                          var frag = waitingData.frag, part = waitingData.part, cache = waitingData.cache, complete = waitingData.complete;
                          if (this.initPTS[frag.cc] !== void 0) {
                            this.waitingData = null;
                            this.waitingVideoCC = -1;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING;
                            var payload = cache.flush();
                            var data = {
                              frag,
                              part,
                              payload,
                              networkDetails: null
                            };
                            this._handleFragmentLoadProgress(data);
                            if (complete) {
                              _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);
                            }
                          } else if (this.videoTrackCC !== this.waitingVideoCC) {
                            this.log("Waiting fragment cc (" + frag.cc + ") cancelled because video is at cc " + this.videoTrackCC);
                            this.clearWaitingFragment();
                          } else {
                            var pos = this.getLoadPosition();
                            var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
                            var waitingFragmentAtPosition = (0, _fragment_finders__WEBPACK_IMPORTED_MODULE_11__.fragmentWithinToleranceTest)(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
                            if (waitingFragmentAtPosition < 0) {
                              this.log("Waiting fragment cc (" + frag.cc + ") @ " + frag.start + " cancelled because another fragment at " + bufferInfo.end + " is needed");
                              this.clearWaitingFragment();
                            }
                          }
                        } else {
                          this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                        }
                      }
                    }
                    this.onTickEnd();
                  };
                  _proto.clearWaitingFragment = function clearWaitingFragment() {
                    var waitingData = this.waitingData;
                    if (waitingData) {
                      this.fragmentTracker.removeFragment(waitingData.frag);
                      this.waitingData = null;
                      this.waitingVideoCC = -1;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                    }
                  };
                  _proto.resetLoadingState = function resetLoadingState() {
                    this.clearWaitingFragment();
                    _BaseStreamController.prototype.resetLoadingState.call(this);
                  };
                  _proto.onTickEnd = function onTickEnd() {
                    var media = this.media;
                    if (!media || !media.readyState) {
                      return;
                    }
                    this.lastCurrentTime = media.currentTime;
                  };
                  _proto.doTickIdle = function doTickIdle() {
                    var hls = this.hls, levels = this.levels, media = this.media, trackId = this.trackId;
                    var config = hls.config;
                    if (!levels || !levels[trackId]) {
                      return;
                    }
                    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
                      return;
                    }
                    var levelInfo = levels[trackId];
                    var trackDetails = levelInfo.details;
                    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK;
                      return;
                    }
                    var bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
                    if (this.bufferFlushed && bufferable) {
                      this.bufferFlushed = false;
                      this.afterBufferFlushed(bufferable, _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO);
                    }
                    var bufferInfo = this.getFwdBufferInfo(bufferable, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO);
                    if (bufferInfo === null) {
                      return;
                    }
                    var audioSwitch = this.audioSwitch;
                    if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_EOS, {
                        type: "audio"
                      });
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ENDED;
                      return;
                    }
                    var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);
                    var bufferLen = bufferInfo.len;
                    var maxBufLen = this.getMaxBufferLength(mainBufferInfo === null || mainBufferInfo === void 0 ? void 0 : mainBufferInfo.len);
                    if (bufferLen >= maxBufLen && !audioSwitch) {
                      return;
                    }
                    var fragments = trackDetails.fragments;
                    var start = fragments[0].start;
                    var targetBufferTime = bufferInfo.end;
                    if (audioSwitch && media) {
                      var pos = this.getLoadPosition();
                      targetBufferTime = pos;
                      if (trackDetails.PTSKnown && pos < start) {
                        if (bufferInfo.end > start || bufferInfo.nextStart) {
                          this.log("Alt audio track ahead of main track, seek to start of alt audio track");
                          media.currentTime = start + 0.05;
                        }
                      }
                    }
                    if (mainBufferInfo && targetBufferTime > mainBufferInfo.end + trackDetails.targetduration) {
                      return;
                    }
                    if ((!mainBufferInfo || !mainBufferInfo.len) && bufferInfo.len) {
                      return;
                    }
                    var frag = this.getNextFragment(targetBufferTime, trackDetails);
                    if (!frag) {
                      this.bufferFlushed = true;
                      return;
                    }
                    this.loadFragment(frag, trackDetails, targetBufferTime);
                  };
                  _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {
                    var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);
                    if (!mainBufferLength) {
                      return maxConfigBuffer;
                    }
                    return Math.max(maxConfigBuffer, mainBufferLength);
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    this.videoBuffer = null;
                    _BaseStreamController.prototype.onMediaDetaching.call(this);
                  };
                  _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {
                    var audioTracks = _ref2.audioTracks;
                    this.resetTransmuxer();
                    this.levels = audioTracks.map(function(mediaPlaylist) {
                      return new _types_level__WEBPACK_IMPORTED_MODULE_5__.Level(mediaPlaylist);
                    });
                  };
                  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
                    var altAudio = !!data.url;
                    this.trackId = data.id;
                    var fragCurrent = this.fragCurrent;
                    if (fragCurrent) {
                      fragCurrent.abortRequests();
                    }
                    this.fragCurrent = null;
                    this.clearWaitingFragment();
                    if (!altAudio) {
                      this.resetTransmuxer();
                    } else {
                      this.setInterval(TICK_INTERVAL);
                    }
                    if (altAudio) {
                      this.audioSwitch = true;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                    } else {
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED;
                    }
                    this.tick();
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.mainDetails = null;
                    this.fragmentTracker.removeAllFragments();
                    this.startPosition = this.lastCurrentTime = 0;
                    this.bufferFlushed = false;
                  };
                  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                    this.mainDetails = data.details;
                    if (this.cachedTrackLoadedData !== null) {
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
                      this.cachedTrackLoadedData = null;
                    }
                  };
                  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
                    var _track$details;
                    if (this.mainDetails == null) {
                      this.cachedTrackLoadedData = data;
                      return;
                    }
                    var levels = this.levels;
                    var newDetails = data.details, trackId = data.id;
                    if (!levels) {
                      this.warn("Audio tracks were reset while loading level " + trackId);
                      return;
                    }
                    this.log("Track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + newDetails.totalduration);
                    var track = levels[trackId];
                    var sliding = 0;
                    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {
                      var mainDetails = this.mainDetails;
                      if (!newDetails.fragments[0]) {
                        newDetails.deltaUpdateFailed = true;
                      }
                      if (newDetails.deltaUpdateFailed || !mainDetails) {
                        return;
                      }
                      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
                        (0, _utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__.alignMediaPlaylistByPDT)(newDetails, mainDetails);
                        sliding = newDetails.fragments[0].start;
                      } else {
                        sliding = this.alignPlaylists(newDetails, track.details);
                      }
                    }
                    track.details = newDetails;
                    this.levelLastLoaded = trackId;
                    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
                      this.setStartPosition(track.details, sliding);
                    }
                    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                    }
                    this.tick();
                  };
                  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
                    var _frag$initSegment;
                    var frag = data.frag, part = data.part, payload = data.payload;
                    var config = this.config, trackId = this.trackId, levels = this.levels;
                    if (!levels) {
                      this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
                      return;
                    }
                    var track = levels[trackId];
                    console.assert(track, "Audio track is defined on fragment load progress");
                    var details = track.details;
                    console.assert(details, "Audio track details are defined on fragment load progress");
                    var audioCodec = config.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
                    var transmuxer = this.transmuxer;
                    if (!transmuxer) {
                      transmuxer = this.transmuxer = new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__["default"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
                    }
                    var initPTS = this.initPTS[frag.cc];
                    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;
                    if (initPTS !== void 0) {
                      var accurateTimeOffset = false;
                      var partIndex = part ? part.index : -1;
                      var partial = partIndex !== -1;
                      var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__.ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
                      transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
                    } else {
                      this.log("Unknown video PTS for cc " + frag.cc + ", waiting for video PTS before demuxing audio frag " + frag.sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                      var _this$waitingData = this.waitingData = this.waitingData || {
                        frag,
                        part,
                        cache: new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__["default"](),
                        complete: false
                      }, cache = _this$waitingData.cache;
                      cache.push(new Uint8Array(payload));
                      this.waitingVideoCC = this.videoTrackCC;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS;
                    }
                  };
                  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
                    if (this.waitingData) {
                      this.waitingData.complete = true;
                      return;
                    }
                    _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);
                  };
                  _proto.onBufferReset = function onBufferReset() {
                    this.mediaBuffer = this.videoBuffer = null;
                    this.loadedmetadata = false;
                  };
                  _proto.onBufferCreated = function onBufferCreated(event, data) {
                    var audioTrack = data.tracks.audio;
                    if (audioTrack) {
                      this.mediaBuffer = audioTrack.buffer || null;
                    }
                    if (data.tracks.video) {
                      this.videoBuffer = data.tracks.video.buffer || null;
                    }
                  };
                  _proto.onFragBuffered = function onFragBuffered(event, data) {
                    var frag = data.frag, part = data.part;
                    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO) {
                      if (!this.loadedmetadata && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN) {
                        var _ref3;
                        if ((_ref3 = this.videoBuffer || this.media) !== null && _ref3 !== void 0 && _ref3.buffered.length) {
                          this.loadedmetadata = true;
                        }
                      }
                      return;
                    }
                    if (this.fragContextChanged(frag)) {
                      this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch);
                      return;
                    }
                    if (frag.sn !== "initSegment") {
                      this.fragPrevious = frag;
                      if (this.audioSwitch) {
                        this.audioSwitch = false;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHED, {
                          id: this.trackId
                        });
                      }
                    }
                    this.fragBufferedComplete(frag, part);
                  };
                  _proto.onError = function onError(event, data) {
                    if (data.type === _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorTypes.KEY_SYSTEM_ERROR) {
                      this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO, data);
                      return;
                    }
                    switch (data.details) {
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.FRAG_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.FRAG_LOAD_TIMEOUT:
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.FRAG_PARSING_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.KEY_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.KEY_LOAD_TIMEOUT:
                        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO, data);
                        break;
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
                        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR && this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED) {
                          this.state = data.fatal ? _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR : _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                          this.warn(data.details + " while loading frag, switching to " + this.state + " state");
                        }
                        break;
                      case _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.BUFFER_FULL_ERROR:
                        if (data.parent === "audio" && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED)) {
                          var flushBuffer = true;
                          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO);
                          if (bufferedInfo && bufferedInfo.len > 0.5) {
                            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);
                          }
                          if (flushBuffer) {
                            this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer");
                            this.fragCurrent = null;
                            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
                          }
                          this.resetLoadingState();
                        }
                        break;
                      default:
                        break;
                    }
                  };
                  _proto.onBufferFlushed = function onBufferFlushed(event, _ref4) {
                    var type = _ref4.type;
                    if (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO) {
                      this.bufferFlushed = true;
                      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ENDED) {
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                      }
                    }
                  };
                  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
                    var _id3$samples;
                    var id = "audio";
                    var hls = this.hls;
                    var remuxResult = transmuxResult.remuxResult, chunkMeta = transmuxResult.chunkMeta;
                    var context = this.getCurrentContext(chunkMeta);
                    if (!context) {
                      this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
                      this.resetStartWhenNotLoaded(chunkMeta.level);
                      return;
                    }
                    var frag = context.frag, part = context.part, details = context.level.details;
                    var audio = remuxResult.audio, text = remuxResult.text, id3 = remuxResult.id3, initSegment = remuxResult.initSegment;
                    if (this.fragContextChanged(frag) || !details) {
                      return;
                    }
                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING;
                    if (this.audioSwitch && audio) {
                      this.completeAudioSwitch();
                    }
                    if (initSegment !== null && initSegment !== void 0 && initSegment.tracks) {
                      this._bufferInitSegment(initSegment.tracks, frag, chunkMeta);
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_PARSING_INIT_SEGMENT, {
                        frag,
                        id,
                        tracks: initSegment.tracks
                      });
                    }
                    if (audio) {
                      var startPTS = audio.startPTS, endPTS = audio.endPTS, startDTS = audio.startDTS, endDTS = audio.endDTS;
                      if (part) {
                        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO] = {
                          startPTS,
                          endPTS,
                          startDTS,
                          endDTS
                        };
                      }
                      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
                      this.bufferFragmentData(audio, frag, part, chunkMeta);
                    }
                    if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {
                      var emittedID3 = _extends({
                        id,
                        frag,
                        details
                      }, id3);
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_PARSING_METADATA, emittedID3);
                    }
                    if (text) {
                      var emittedText = _extends({
                        id,
                        frag,
                        details
                      }, text);
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.FRAG_PARSING_USERDATA, emittedText);
                    }
                  };
                  _proto._bufferInitSegment = function _bufferInitSegment(tracks, frag, chunkMeta) {
                    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING) {
                      return;
                    }
                    if (tracks.video) {
                      delete tracks.video;
                    }
                    var track = tracks.audio;
                    if (!track) {
                      return;
                    }
                    track.levelCodec = track.codec;
                    track.id = "audio";
                    this.log("Init audio buffer, container:" + track.container + ", codecs[parsed]=[" + track.codec + "]");
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_CODECS, tracks);
                    var initSegment = track.initSegment;
                    if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {
                      var segment = {
                        type: "audio",
                        frag,
                        part: null,
                        chunkMeta,
                        parent: frag.type,
                        data: initSegment
                      };
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.BUFFER_APPENDING, segment);
                    }
                    this.tick();
                  };
                  _proto.loadFragment = function loadFragment(frag, trackDetails, targetBufferTime) {
                    var fragState = this.fragmentTracker.getState(frag);
                    this.fragCurrent = frag;
                    if (this.audioSwitch || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__.FragmentState.NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__.FragmentState.PARTIAL) {
                      if (frag.sn === "initSegment") {
                        this._loadInitSegment(frag, trackDetails);
                      } else if (trackDetails.live && !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.initPTS[frag.cc])) {
                        this.log("Waiting for video PTS in continuity counter " + frag.cc + " of live stream before loading audio fragment " + frag.sn + " of level " + this.trackId);
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_INIT_PTS;
                      } else {
                        this.startFragRequested = true;
                        _BaseStreamController.prototype.loadFragment.call(this, frag, trackDetails, targetBufferTime);
                      }
                    }
                  };
                  _proto.completeAudioSwitch = function completeAudioSwitch() {
                    var hls = this.hls, media = this.media, trackId = this.trackId;
                    if (media) {
                      this.log("Switching audio track : flushing all audio");
                      _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
                    }
                    this.audioSwitch = false;
                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.AUDIO_TRACK_SWITCHED, {
                      id: trackId
                    });
                  };
                  return AudioStreamController2;
                }(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"]);
                const __WEBPACK_DEFAULT_EXPORT__ = AudioStreamController;
              }
            ),
            /***/
            "./src/controller/audio-track-controller.ts": (
              /*!**************************************************!*\
                !*** ./src/controller/audio-track-controller.ts ***!
                \**************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./base-playlist-controller */
                  "./src/controller/base-playlist-controller.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var AudioTrackController = function(_BasePlaylistControll) {
                  _inheritsLoose(AudioTrackController2, _BasePlaylistControll);
                  function AudioTrackController2(hls) {
                    var _this;
                    _this = _BasePlaylistControll.call(this, hls, "[audio-track-controller]") || this;
                    _this.tracks = [];
                    _this.groupId = null;
                    _this.tracksInGroup = [];
                    _this.trackId = -1;
                    _this.trackName = "";
                    _this.selectDefaultTrack = true;
                    _this.registerListeners();
                    return _this;
                  }
                  var _proto = AudioTrackController2.prototype;
                  _proto.registerListeners = function registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);
                  };
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.tracks.length = 0;
                    this.tracksInGroup.length = 0;
                    _BasePlaylistControll.prototype.destroy.call(this);
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.tracks = [];
                    this.groupId = null;
                    this.tracksInGroup = [];
                    this.trackId = -1;
                    this.trackName = "";
                    this.selectDefaultTrack = true;
                  };
                  _proto.onManifestParsed = function onManifestParsed(event, data) {
                    this.tracks = data.audioTracks || [];
                  };
                  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
                    var id = data.id, details = data.details;
                    var currentTrack = this.tracksInGroup[id];
                    if (!currentTrack) {
                      this.warn("Invalid audio track id " + id);
                      return;
                    }
                    var curDetails = currentTrack.details;
                    currentTrack.details = data.details;
                    this.log("audioTrack " + id + " loaded [" + details.startSN + "-" + details.endSN + "]");
                    if (id === this.trackId) {
                      this.retryCount = 0;
                      this.playlistLoaded(id, data, curDetails);
                    }
                  };
                  _proto.onLevelLoading = function onLevelLoading(event, data) {
                    this.switchLevel(data.level);
                  };
                  _proto.onLevelSwitching = function onLevelSwitching(event, data) {
                    this.switchLevel(data.level);
                  };
                  _proto.switchLevel = function switchLevel(levelIndex) {
                    var levelInfo = this.hls.levels[levelIndex];
                    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.audioGroupIds)) {
                      return;
                    }
                    var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
                    if (this.groupId !== audioGroupId) {
                      this.groupId = audioGroupId;
                      var audioTracks = this.tracks.filter(function(track) {
                        return !audioGroupId || track.groupId === audioGroupId;
                      });
                      if (this.selectDefaultTrack && !audioTracks.some(function(track) {
                        return track.default;
                      })) {
                        this.selectDefaultTrack = false;
                      }
                      this.tracksInGroup = audioTracks;
                      var audioTracksUpdated = {
                        audioTracks
                      };
                      this.log("Updating audio tracks, " + audioTracks.length + ' track(s) found in "' + audioGroupId + '" group-id');
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
                      this.selectInitialTrack();
                    }
                  };
                  _proto.onError = function onError(event, data) {
                    _BasePlaylistControll.prototype.onError.call(this, event, data);
                    if (data.fatal || !data.context) {
                      return;
                    }
                    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__.PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
                      this.retryLoadingOrFail(data);
                    }
                  };
                  _proto.setAudioTrack = function setAudioTrack(newId) {
                    var tracks = this.tracksInGroup;
                    if (newId < 0 || newId >= tracks.length) {
                      this.warn("Invalid id passed to audio-track controller");
                      return;
                    }
                    this.clearTimer();
                    var lastTrack = tracks[this.trackId];
                    this.log("Now switching to audio-track index " + newId);
                    var track = tracks[newId];
                    var id = track.id, _track$groupId = track.groupId, groupId = _track$groupId === void 0 ? "" : _track$groupId, name = track.name, type = track.type, url = track.url;
                    this.trackId = newId;
                    this.trackName = name;
                    this.selectDefaultTrack = false;
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_SWITCHING, {
                      id,
                      groupId,
                      name,
                      type,
                      url
                    });
                    if (track.details && !track.details.live) {
                      return;
                    }
                    var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);
                    this.loadPlaylist(hlsUrlParameters);
                  };
                  _proto.selectInitialTrack = function selectInitialTrack() {
                    var audioTracks = this.tracksInGroup;
                    console.assert(audioTracks.length, "Initial audio track should be selected when tracks are known");
                    var currentAudioTrackName = this.trackName;
                    var trackId = this.findTrackId(currentAudioTrackName) || this.findTrackId();
                    if (trackId !== -1) {
                      this.setAudioTrack(trackId);
                    } else {
                      this.warn("No track found for running audio group-ID: " + this.groupId);
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
                        fatal: true
                      });
                    }
                  };
                  _proto.findTrackId = function findTrackId(name) {
                    var audioTracks = this.tracksInGroup;
                    for (var i = 0; i < audioTracks.length; i++) {
                      var track = audioTracks[i];
                      if (!this.selectDefaultTrack || track.default) {
                        if (!name || name === track.name) {
                          return track.id;
                        }
                      }
                    }
                    return -1;
                  };
                  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
                    _BasePlaylistControll.prototype.loadPlaylist.call(this);
                    var audioTrack = this.tracksInGroup[this.trackId];
                    if (this.shouldLoadTrack(audioTrack)) {
                      var id = audioTrack.id;
                      var groupId = audioTrack.groupId;
                      var url = audioTrack.url;
                      if (hlsUrlParameters) {
                        try {
                          url = hlsUrlParameters.addDirectives(url);
                        } catch (error) {
                          this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
                        }
                      }
                      this.log("loading audio-track playlist for id: " + id);
                      this.clearTimer();
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.AUDIO_TRACK_LOADING, {
                        url,
                        id,
                        groupId,
                        deliveryDirectives: hlsUrlParameters || null
                      });
                    }
                  };
                  _createClass(AudioTrackController2, [{
                    key: "audioTracks",
                    get: function get() {
                      return this.tracksInGroup;
                    }
                  }, {
                    key: "audioTrack",
                    get: function get() {
                      return this.trackId;
                    },
                    set: function set(newId) {
                      this.selectDefaultTrack = false;
                      this.setAudioTrack(newId);
                    }
                  }]);
                  return AudioTrackController2;
                }(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__["default"]);
                const __WEBPACK_DEFAULT_EXPORT__ = AudioTrackController;
              }
            ),
            /***/
            "./src/controller/base-playlist-controller.ts": (
              /*!****************************************************!*\
                !*** ./src/controller/base-playlist-controller.ts ***!
                \****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    BasePlaylistController
                  )
                  /* harmony export */
                });
                var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../types/level */
                  "./src/types/level.ts"
                );
                var _level_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./level-helper */
                  "./src/controller/level-helper.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var BasePlaylistController = function() {
                  function BasePlaylistController2(hls, logPrefix) {
                    this.hls = void 0;
                    this.timer = -1;
                    this.requestScheduled = -1;
                    this.canLoad = false;
                    this.retryCount = 0;
                    this.log = void 0;
                    this.warn = void 0;
                    this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, logPrefix + ":");
                    this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, logPrefix + ":");
                    this.hls = hls;
                  }
                  var _proto = BasePlaylistController2.prototype;
                  _proto.destroy = function destroy() {
                    this.clearTimer();
                    this.hls = this.log = this.warn = null;
                  };
                  _proto.onError = function onError(event, data) {
                    if (data.fatal && (data.type === _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.NETWORK_ERROR || data.type === _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.KEY_SYSTEM_ERROR)) {
                      this.stopLoad();
                    }
                  };
                  _proto.clearTimer = function clearTimer() {
                    clearTimeout(this.timer);
                    this.timer = -1;
                  };
                  _proto.startLoad = function startLoad() {
                    this.canLoad = true;
                    this.retryCount = 0;
                    this.requestScheduled = -1;
                    this.loadPlaylist();
                  };
                  _proto.stopLoad = function stopLoad() {
                    this.canLoad = false;
                    this.clearTimer();
                  };
                  _proto.switchParams = function switchParams(playlistUri, previous) {
                    var renditionReports = previous === null || previous === void 0 ? void 0 : previous.renditionReports;
                    if (renditionReports) {
                      for (var i = 0; i < renditionReports.length; i++) {
                        var attr = renditionReports[i];
                        var uri = void 0;
                        try {
                          uri = new self.URL(attr.URI, previous.url).href;
                        } catch (error) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("Could not construct new URL for Rendition Report: " + error);
                          uri = attr.URI || "";
                        }
                        if (uri === playlistUri.slice(-uri.length)) {
                          var msn = parseInt(attr["LAST-MSN"]) || (previous === null || previous === void 0 ? void 0 : previous.lastPartSn);
                          var part = parseInt(attr["LAST-PART"]) || (previous === null || previous === void 0 ? void 0 : previous.lastPartIndex);
                          if (this.hls.config.lowLatencyMode) {
                            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
                            if (part >= 0 && currentGoal > previous.partTarget) {
                              part += 1;
                            }
                          }
                          return new _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsUrlParameters(msn, part >= 0 ? part : void 0, _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsSkip.No);
                        }
                      }
                    }
                  };
                  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
                    if (this.requestScheduled === -1) {
                      this.requestScheduled = self.performance.now();
                    }
                  };
                  _proto.shouldLoadTrack = function shouldLoadTrack(track) {
                    return this.canLoad && track && !!track.url && (!track.details || track.details.live);
                  };
                  _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {
                    var _this = this;
                    var details = data.details, stats = data.stats;
                    var now = self.performance.now();
                    var elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;
                    details.advancedDateTime = Date.now() - elapsed;
                    if (details.live || previousDetails !== null && previousDetails !== void 0 && previousDetails.live) {
                      details.reloaded(previousDetails);
                      if (previousDetails) {
                        this.log("live playlist " + index + " " + (details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : "MISSED"));
                      }
                      if (previousDetails && details.fragments.length > 0) {
                        (0, _level_helper__WEBPACK_IMPORTED_MODULE_1__.mergeDetails)(previousDetails, details);
                      }
                      if (!this.canLoad || !details.live) {
                        return;
                      }
                      var deliveryDirectives;
                      var msn = void 0;
                      var part = void 0;
                      if (details.canBlockReload && details.endSN && details.advanced) {
                        var lowLatencyMode = this.hls.config.lowLatencyMode;
                        var lastPartSn = details.lastPartSn;
                        var endSn = details.endSN;
                        var lastPartIndex = details.lastPartIndex;
                        var hasParts = lastPartIndex !== -1;
                        var lastPart = lastPartSn === endSn;
                        var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
                        if (hasParts) {
                          msn = lastPart ? endSn + 1 : lastPartSn;
                          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
                        } else {
                          msn = endSn + 1;
                        }
                        var lastAdvanced = details.age;
                        var cdnAge = lastAdvanced + details.ageHeader;
                        var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
                        if (currentGoal > 0) {
                          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
                            this.warn("CDN Tune-in goal increased from: " + previousDetails.tuneInGoal + " to: " + currentGoal + " with playlist age: " + details.age);
                            currentGoal = 0;
                          } else {
                            var segments = Math.floor(currentGoal / details.targetduration);
                            msn += segments;
                            if (part !== void 0) {
                              var parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                              part += parts;
                            }
                            this.log("CDN Tune-in age: " + details.ageHeader + "s last advanced " + lastAdvanced.toFixed(2) + "s goal: " + currentGoal + " skip sn " + segments + " to part " + part);
                          }
                          details.tuneInGoal = currentGoal;
                        }
                        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
                        if (lowLatencyMode || !lastPart) {
                          this.loadPlaylist(deliveryDirectives);
                          return;
                        }
                      } else {
                        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
                      }
                      var bufferInfo = this.hls.mainForwardBufferInfo;
                      var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
                      var distanceToLiveEdgeMs = (details.edge - position) * 1e3;
                      var reloadInterval = (0, _level_helper__WEBPACK_IMPORTED_MODULE_1__.computeReloadInterval)(details, distanceToLiveEdgeMs);
                      if (!details.updated) {
                        this.requestScheduled = -1;
                      } else if (now > this.requestScheduled + reloadInterval) {
                        this.requestScheduled = stats.loading.start;
                      }
                      if (msn !== void 0 && details.canBlockReload) {
                        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1e3 || 1e3);
                      } else {
                        this.requestScheduled = (this.requestScheduled === -1 ? now : this.requestScheduled) + reloadInterval;
                      }
                      var estimatedTimeUntilUpdate = this.requestScheduled - now;
                      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
                      this.log("reload live playlist " + index + " in " + Math.round(estimatedTimeUntilUpdate) + " ms");
                      this.timer = self.setTimeout(function() {
                        return _this.loadPlaylist(deliveryDirectives);
                      }, estimatedTimeUntilUpdate);
                    } else {
                      this.clearTimer();
                    }
                  };
                  _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
                    var skip = (0, _types_level__WEBPACK_IMPORTED_MODULE_0__.getSkipValue)(details, msn);
                    if (previousDeliveryDirectives !== null && previousDeliveryDirectives !== void 0 && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
                      msn = previousDeliveryDirectives.msn;
                      part = previousDeliveryDirectives.part;
                      skip = _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsSkip.No;
                    }
                    return new _types_level__WEBPACK_IMPORTED_MODULE_0__.HlsUrlParameters(msn, part, skip);
                  };
                  _proto.retryLoadingOrFail = function retryLoadingOrFail(errorEvent) {
                    var _this2 = this;
                    var config = this.hls.config;
                    var retry = this.retryCount < config.levelLoadingMaxRetry;
                    if (retry) {
                      var _errorEvent$context;
                      this.requestScheduled = -1;
                      this.retryCount++;
                      if (errorEvent.details.indexOf("LoadTimeOut") > -1 && (_errorEvent$context = errorEvent.context) !== null && _errorEvent$context !== void 0 && _errorEvent$context.deliveryDirectives) {
                        this.warn("retry playlist loading #" + this.retryCount + ' after "' + errorEvent.details + '"');
                        this.loadPlaylist();
                      } else {
                        var delay = Math.min(Math.pow(2, this.retryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
                        this.timer = self.setTimeout(function() {
                          return _this2.loadPlaylist();
                        }, delay);
                        this.warn("retry playlist loading #" + this.retryCount + " in " + delay + ' ms after "' + errorEvent.details + '"');
                      }
                    } else {
                      this.warn('cannot recover from error "' + errorEvent.details + '"');
                      this.clearTimer();
                      errorEvent.fatal = true;
                    }
                    return retry;
                  };
                  return BasePlaylistController2;
                }();
              }
            ),
            /***/
            "./src/controller/base-stream-controller.ts": (
              /*!**************************************************!*\
                !*** ./src/controller/base-stream-controller.ts ***!
                \**************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "State": () => (
                    /* binding */
                    State
                  ),
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    BaseStreamController
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _task_loop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../task-loop */
                  "./src/task-loop.ts"
                );
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./fragment-tracker */
                  "./src/controller/fragment-tracker.ts"
                );
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/buffer-helper */
                  "./src/utils/buffer-helper.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../types/transmuxer */
                  "./src/types/transmuxer.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ../utils/discontinuities */
                  "./src/utils/discontinuities.ts"
                );
                var _fragment_finders__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                  /*! ./fragment-finders */
                  "./src/controller/fragment-finders.ts"
                );
                var _level_helper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                  /*! ./level-helper */
                  "./src/controller/level-helper.ts"
                );
                var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                  /*! ../loader/fragment-loader */
                  "./src/loader/fragment-loader.ts"
                );
                var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                  /*! ../crypt/decrypter */
                  "./src/crypt/decrypter.ts"
                );
                var _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                  /*! ../utils/time-ranges */
                  "./src/utils/time-ranges.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var State = {
                  STOPPED: "STOPPED",
                  IDLE: "IDLE",
                  KEY_LOADING: "KEY_LOADING",
                  FRAG_LOADING: "FRAG_LOADING",
                  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
                  WAITING_TRACK: "WAITING_TRACK",
                  PARSING: "PARSING",
                  PARSED: "PARSED",
                  ENDED: "ENDED",
                  ERROR: "ERROR",
                  WAITING_INIT_PTS: "WAITING_INIT_PTS",
                  WAITING_LEVEL: "WAITING_LEVEL"
                };
                var BaseStreamController = function(_TaskLoop) {
                  _inheritsLoose(BaseStreamController2, _TaskLoop);
                  function BaseStreamController2(hls, fragmentTracker, keyLoader, logPrefix) {
                    var _this;
                    _this = _TaskLoop.call(this) || this;
                    _this.hls = void 0;
                    _this.fragPrevious = null;
                    _this.fragCurrent = null;
                    _this.fragmentTracker = void 0;
                    _this.transmuxer = null;
                    _this._state = State.STOPPED;
                    _this.media = null;
                    _this.mediaBuffer = null;
                    _this.config = void 0;
                    _this.bitrateTest = false;
                    _this.lastCurrentTime = 0;
                    _this.nextLoadPosition = 0;
                    _this.startPosition = 0;
                    _this.loadedmetadata = false;
                    _this.fragLoadError = 0;
                    _this.retryDate = 0;
                    _this.levels = null;
                    _this.fragmentLoader = void 0;
                    _this.keyLoader = void 0;
                    _this.levelLastLoaded = null;
                    _this.startFragRequested = false;
                    _this.decrypter = void 0;
                    _this.initPTS = [];
                    _this.onvseeking = null;
                    _this.onvended = null;
                    _this.logPrefix = "";
                    _this.log = void 0;
                    _this.warn = void 0;
                    _this.logPrefix = logPrefix;
                    _this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger, logPrefix + ":");
                    _this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger, logPrefix + ":");
                    _this.hls = hls;
                    _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__["default"](hls.config);
                    _this.keyLoader = keyLoader;
                    _this.fragmentTracker = fragmentTracker;
                    _this.config = hls.config;
                    _this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__["default"](hls.config);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_5__.Events.LEVEL_SWITCHING, _this.onLevelSwitching, _assertThisInitialized(_this));
                    return _this;
                  }
                  var _proto = BaseStreamController2.prototype;
                  _proto.doTick = function doTick() {
                    this.onTickEnd();
                  };
                  _proto.onTickEnd = function onTickEnd() {
                  };
                  _proto.startLoad = function startLoad(startPosition) {
                  };
                  _proto.stopLoad = function stopLoad() {
                    this.fragmentLoader.abort();
                    this.keyLoader.abort();
                    var frag = this.fragCurrent;
                    if (frag) {
                      frag.abortRequests();
                      this.fragmentTracker.removeFragment(frag);
                    }
                    this.resetTransmuxer();
                    this.fragCurrent = null;
                    this.fragPrevious = null;
                    this.clearInterval();
                    this.clearNextTick();
                    this.state = State.STOPPED;
                  };
                  _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
                    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
                      return false;
                    }
                    var partList = levelDetails.partList;
                    if (partList !== null && partList !== void 0 && partList.length) {
                      var lastPart = partList[partList.length - 1];
                      var lastPartBuffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
                      return lastPartBuffered;
                    }
                    var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
                    return this.fragmentTracker.isEndListAppended(playlistType);
                  };
                  _proto.getLevelDetails = function getLevelDetails() {
                    if (this.levels && this.levelLastLoaded !== null) {
                      var _this$levels$this$lev;
                      return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) === null || _this$levels$this$lev === void 0 ? void 0 : _this$levels$this$lev.details;
                    }
                  };
                  _proto.onMediaAttached = function onMediaAttached(event, data) {
                    var media = this.media = this.mediaBuffer = data.media;
                    this.onvseeking = this.onMediaSeeking.bind(this);
                    this.onvended = this.onMediaEnded.bind(this);
                    media.addEventListener("seeking", this.onvseeking);
                    media.addEventListener("ended", this.onvended);
                    var config = this.config;
                    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
                      this.startLoad(config.startPosition);
                    }
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    var media = this.media;
                    if (media !== null && media !== void 0 && media.ended) {
                      this.log("MSE detaching and video ended, reset startPosition");
                      this.startPosition = this.lastCurrentTime = 0;
                    }
                    if (media && this.onvseeking && this.onvended) {
                      media.removeEventListener("seeking", this.onvseeking);
                      media.removeEventListener("ended", this.onvended);
                      this.onvseeking = this.onvended = null;
                    }
                    if (this.keyLoader) {
                      this.keyLoader.detach();
                    }
                    this.media = this.mediaBuffer = null;
                    this.loadedmetadata = false;
                    this.fragmentTracker.removeAllFragments();
                    this.stopLoad();
                  };
                  _proto.onMediaSeeking = function onMediaSeeking() {
                    var config = this.config, fragCurrent = this.fragCurrent, media = this.media, mediaBuffer = this.mediaBuffer, state = this.state;
                    var currentTime = media ? media.currentTime : 0;
                    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
                    this.log("media seeking to " + ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(currentTime) ? currentTime.toFixed(3) : currentTime) + ", state: " + state);
                    if (this.state === State.ENDED) {
                      this.resetLoadingState();
                    } else if (fragCurrent) {
                      var tolerance = config.maxFragLookUpTolerance;
                      var fragStartOffset = fragCurrent.start - tolerance;
                      var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
                      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
                        var pastFragment = currentTime > fragEndOffset;
                        if (currentTime < fragStartOffset || pastFragment) {
                          if (pastFragment && fragCurrent.loader) {
                            this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
                            fragCurrent.abortRequests();
                          }
                          this.resetLoadingState();
                        }
                      }
                    }
                    if (media) {
                      this.lastCurrentTime = currentTime;
                    }
                    if (!this.loadedmetadata && !bufferInfo.len) {
                      this.nextLoadPosition = this.startPosition = currentTime;
                    }
                    this.tickImmediate();
                  };
                  _proto.onMediaEnded = function onMediaEnded() {
                    this.startPosition = this.lastCurrentTime = 0;
                  };
                  _proto.onLevelSwitching = function onLevelSwitching(event, data) {
                    this.fragLoadError = 0;
                  };
                  _proto.onHandlerDestroying = function onHandlerDestroying() {
                    this.stopLoad();
                    _TaskLoop.prototype.onHandlerDestroying.call(this);
                  };
                  _proto.onHandlerDestroyed = function onHandlerDestroyed() {
                    this.state = State.STOPPED;
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_5__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
                    if (this.fragmentLoader) {
                      this.fragmentLoader.destroy();
                    }
                    if (this.keyLoader) {
                      this.keyLoader.destroy();
                    }
                    if (this.decrypter) {
                      this.decrypter.destroy();
                    }
                    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
                    _TaskLoop.prototype.onHandlerDestroyed.call(this);
                  };
                  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
                    this._loadFragForPlayback(frag, levelDetails, targetBufferTime);
                  };
                  _proto._loadFragForPlayback = function _loadFragForPlayback(frag, levelDetails, targetBufferTime) {
                    var _this2 = this;
                    var progressCallback = function progressCallback2(data) {
                      if (_this2.fragContextChanged(frag)) {
                        _this2.warn("Fragment " + frag.sn + (data.part ? " p: " + data.part.index : "") + " of level " + frag.level + " was dropped during download.");
                        _this2.fragmentTracker.removeFragment(frag);
                        return;
                      }
                      frag.stats.chunkCount++;
                      _this2._handleFragmentLoadProgress(data);
                    };
                    this._doFragLoad(frag, levelDetails, targetBufferTime, progressCallback).then(function(data) {
                      if (!data) {
                        return;
                      }
                      _this2.fragLoadError = 0;
                      var state = _this2.state;
                      if (_this2.fragContextChanged(frag)) {
                        if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {
                          _this2.fragmentTracker.removeFragment(frag);
                          _this2.state = State.IDLE;
                        }
                        return;
                      }
                      if ("payload" in data) {
                        _this2.log("Loaded fragment " + frag.sn + " of level " + frag.level);
                        _this2.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADED, data);
                      }
                      _this2._handleFragmentLoadComplete(data);
                    }).catch(function(reason) {
                      if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {
                        return;
                      }
                      _this2.warn(reason);
                      _this2.resetFragmentLoading(frag);
                    });
                  };
                  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {
                    if (type === void 0) {
                      type = null;
                    }
                    if (!(startOffset - endOffset)) {
                      return;
                    }
                    var flushScope = {
                      startOffset,
                      endOffset,
                      type
                    };
                    this.fragLoadError = 0;
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.BUFFER_FLUSHING, flushScope);
                  };
                  _proto._loadInitSegment = function _loadInitSegment(frag, details) {
                    var _this3 = this;
                    this._doFragLoad(frag, details).then(function(data) {
                      if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {
                        throw new Error("init load aborted");
                      }
                      return data;
                    }).then(function(data) {
                      var hls = _this3.hls;
                      var payload = data.payload;
                      var decryptData = frag.decryptdata;
                      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
                        var startTime = self.performance.now();
                        return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function(decryptedData) {
                          var endTime = self.performance.now();
                          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_DECRYPTED, {
                            frag,
                            payload: decryptedData,
                            stats: {
                              tstart: startTime,
                              tdecrypt: endTime
                            }
                          });
                          data.payload = decryptedData;
                          return data;
                        });
                      }
                      return data;
                    }).then(function(data) {
                      var fragCurrent = _this3.fragCurrent, hls = _this3.hls, levels = _this3.levels;
                      if (!levels) {
                        throw new Error("init load aborted, missing levels");
                      }
                      var details2 = levels[frag.level].details;
                      console.assert(details2, "Level details are defined when init segment is loaded");
                      var stats = frag.stats;
                      _this3.state = State.IDLE;
                      _this3.fragLoadError = 0;
                      frag.data = new Uint8Array(data.payload);
                      stats.parsing.start = stats.buffering.start = self.performance.now();
                      stats.parsing.end = stats.buffering.end = self.performance.now();
                      if (data.frag === fragCurrent) {
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_BUFFERED, {
                          stats,
                          frag: fragCurrent,
                          part: null,
                          id: frag.type
                        });
                      }
                      _this3.tick();
                    }).catch(function(reason) {
                      if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {
                        return;
                      }
                      _this3.warn(reason);
                      _this3.resetFragmentLoading(frag);
                    });
                  };
                  _proto.fragContextChanged = function fragContextChanged(frag) {
                    var fragCurrent = this.fragCurrent;
                    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;
                  };
                  _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {
                    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
                    var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                    this.log("Buffered " + frag.type + " sn: " + frag.sn + (part ? " part: " + part.index : "") + " of " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + " " + frag.level + " (frag:[" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + "-" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + "] > buffer:" + (media ? _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__["default"].toString(_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.getBuffered(media)) : "(detached)") + ")");
                    this.state = State.IDLE;
                    if (!media) {
                      return;
                    }
                    if (!this.loadedmetadata && frag.type == _types_loader__WEBPACK_IMPORTED_MODULE_15__.PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) === null || _this$fragCurrent === void 0 ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) === null || _this$fragPrevious === void 0 ? void 0 : _this$fragPrevious.sn)) {
                      this.loadedmetadata = true;
                      this.seekToStartPos();
                    }
                    this.tick();
                  };
                  _proto.seekToStartPos = function seekToStartPos() {
                  };
                  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {
                    var transmuxer = this.transmuxer;
                    if (!transmuxer) {
                      return;
                    }
                    var frag = fragLoadedEndData.frag, part = fragLoadedEndData.part, partsLoaded = fragLoadedEndData.partsLoaded;
                    var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function(fragLoaded) {
                      return !fragLoaded;
                    });
                    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__.ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
                    transmuxer.flush(chunkMeta);
                  };
                  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {
                  };
                  _proto._doFragLoad = function _doFragLoad(frag, details, targetBufferTime, progressCallback) {
                    var _frag$decryptdata, _this4 = this;
                    if (targetBufferTime === void 0) {
                      targetBufferTime = null;
                    }
                    if (!this.levels) {
                      throw new Error("frag load aborted, missing levels");
                    }
                    var keyLoadingPromise = null;
                    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) !== null && _frag$decryptdata !== void 0 && _frag$decryptdata.key)) {
                      this.log("Loading key for " + frag.sn + " of [" + details.startSN + "-" + details.endSN + "], " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + " " + frag.level);
                      this.state = State.KEY_LOADING;
                      this.fragCurrent = frag;
                      keyLoadingPromise = this.keyLoader.load(frag).then(function(keyLoadedData) {
                        if (!_this4.fragContextChanged(keyLoadedData.frag)) {
                          _this4.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_LOADED, keyLoadedData);
                          if (_this4.state === State.KEY_LOADING) {
                            _this4.state = State.IDLE;
                          }
                          return keyLoadedData;
                        }
                      });
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_LOADING, {
                        frag
                      });
                      this.throwIfFragContextChanged("KEY_LOADING");
                    } else if (!frag.encrypted && details.encryptedFragments.length) {
                      this.keyLoader.loadClear(frag, details.encryptedFragments);
                    }
                    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
                    if (this.config.lowLatencyMode && details) {
                      var partList = details.partList;
                      if (partList && progressCallback) {
                        if (targetBufferTime > frag.end && details.fragmentHint) {
                          frag = details.fragmentHint;
                        }
                        var partIndex = this.getNextPart(partList, frag, targetBufferTime);
                        if (partIndex > -1) {
                          var part = partList[partIndex];
                          this.log("Loading part sn: " + frag.sn + " p: " + part.index + " cc: " + frag.cc + " of playlist [" + details.startSN + "-" + details.endSN + "] parts [0-" + partIndex + "-" + (partList.length - 1) + "] " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
                          this.nextLoadPosition = part.start + part.duration;
                          this.state = State.FRAG_LOADING;
                          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADING, {
                            frag,
                            part: partList[partIndex],
                            targetBufferTime
                          });
                          this.throwIfFragContextChanged("FRAG_LOADING parts");
                          if (keyLoadingPromise) {
                            return keyLoadingPromise.then(function(keyLoadedData) {
                              if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {
                                return null;
                              }
                              return _this4.doFragPartsLoad(frag, partList, partIndex, progressCallback);
                            }).catch(function(error) {
                              return _this4.handleFragLoadError(error);
                            });
                          }
                          return this.doFragPartsLoad(frag, partList, partIndex, progressCallback).catch(function(error) {
                            return _this4.handleFragLoadError(error);
                          });
                        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
                          return Promise.resolve(null);
                        }
                      }
                    }
                    this.log("Loading fragment " + frag.sn + " cc: " + frag.cc + " " + (details ? "of [" + details.startSN + "-" + details.endSN + "] " : "") + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
                    if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.sn) && !this.bitrateTest) {
                      this.nextLoadPosition = frag.start + frag.duration;
                    }
                    this.state = State.FRAG_LOADING;
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADING, {
                      frag,
                      targetBufferTime
                    });
                    this.throwIfFragContextChanged("FRAG_LOADING");
                    var dataOnProgress = this.config.progressive;
                    if (dataOnProgress && keyLoadingPromise) {
                      return keyLoadingPromise.then(function(keyLoadedData) {
                        if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData === null || keyLoadedData === void 0 ? void 0 : keyLoadedData.frag)) {
                          return null;
                        }
                        return _this4.fragmentLoader.load(frag, progressCallback);
                      }).catch(function(error) {
                        return _this4.handleFragLoadError(error);
                      });
                    }
                    return Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : void 0), keyLoadingPromise]).then(function(_ref) {
                      var fragLoadedData = _ref[0];
                      if (!dataOnProgress && fragLoadedData && progressCallback) {
                        progressCallback(fragLoadedData);
                      }
                      return fragLoadedData;
                    }).catch(function(error) {
                      return _this4.handleFragLoadError(error);
                    });
                  };
                  _proto.throwIfFragContextChanged = function throwIfFragContextChanged(context) {
                    if (this.fragCurrent === null) {
                      throw new Error("frag load aborted, context changed in " + context);
                    }
                  };
                  _proto.doFragPartsLoad = function doFragPartsLoad(frag, partList, partIndex, progressCallback) {
                    var _this5 = this;
                    return new Promise(function(resolve, reject) {
                      var partsLoaded = [];
                      var loadPartIndex = function loadPartIndex2(index) {
                        var part = partList[index];
                        _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function(partLoadedData) {
                          partsLoaded[part.index] = partLoadedData;
                          var loadedPart = partLoadedData.part;
                          _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_LOADED, partLoadedData);
                          var nextPart = partList[index + 1];
                          if (nextPart && nextPart.fragment === frag) {
                            loadPartIndex2(index + 1);
                          } else {
                            return resolve({
                              frag,
                              part: loadedPart,
                              partsLoaded
                            });
                          }
                        }).catch(reject);
                      };
                      loadPartIndex(partIndex);
                    });
                  };
                  _proto.handleFragLoadError = function handleFragLoadError(error) {
                    if ("data" in error) {
                      var data = error.data;
                      if (error.data && data.details === _errors__WEBPACK_IMPORTED_MODULE_6__.ErrorDetails.INTERNAL_ABORTED) {
                        this.handleFragLoadAborted(data.frag, data.part);
                      } else {
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.ERROR, data);
                      }
                    } else {
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_6__.ErrorTypes.OTHER_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_6__.ErrorDetails.INTERNAL_EXCEPTION,
                        err: error,
                        fatal: true
                      });
                    }
                    return null;
                  };
                  _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {
                    var context = this.getCurrentContext(chunkMeta);
                    if (!context || this.state !== State.PARSING) {
                      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
                        this.state = State.IDLE;
                      }
                      return;
                    }
                    var frag = context.frag, part = context.part, level = context.level;
                    var now = self.performance.now();
                    frag.stats.parsing.end = now;
                    if (part) {
                      part.stats.parsing.end = now;
                    }
                    this.updateLevelTiming(frag, part, level, chunkMeta.partial);
                  };
                  _proto.getCurrentContext = function getCurrentContext(chunkMeta) {
                    var levels = this.levels;
                    var levelIndex = chunkMeta.level, sn = chunkMeta.sn, partIndex = chunkMeta.part;
                    if (!levels || !levels[levelIndex]) {
                      this.warn("Levels object was unset while buffering fragment " + sn + " of level " + levelIndex + ". The current chunk will not be buffered.");
                      return null;
                    }
                    var level = levels[levelIndex];
                    var part = partIndex > -1 ? (0, _level_helper__WEBPACK_IMPORTED_MODULE_11__.getPartWith)(level, sn, partIndex) : null;
                    var frag = part ? part.fragment : (0, _level_helper__WEBPACK_IMPORTED_MODULE_11__.getFragmentWithSN)(level, sn, this.fragCurrent);
                    if (!frag) {
                      return null;
                    }
                    return {
                      frag,
                      part,
                      level
                    };
                  };
                  _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {
                    if (!data || this.state !== State.PARSING) {
                      return;
                    }
                    var data1 = data.data1, data2 = data.data2;
                    var buffer = data1;
                    if (data1 && data2) {
                      buffer = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.appendUint8Array)(data1, data2);
                    }
                    if (!buffer || !buffer.length) {
                      return;
                    }
                    var segment = {
                      type: data.type,
                      frag,
                      part,
                      chunkMeta,
                      parent: frag.type,
                      data: buffer
                    };
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.BUFFER_APPENDING, segment);
                    if (data.dropped && data.independent && !part) {
                      this.flushBufferGap(frag);
                    }
                  };
                  _proto.flushBufferGap = function flushBufferGap(frag) {
                    var media = this.media;
                    if (!media) {
                      return;
                    }
                    if (!_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.isBuffered(media, media.currentTime)) {
                      this.flushMainBuffer(0, frag.start);
                      return;
                    }
                    var currentTime = media.currentTime;
                    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(media, currentTime, 0);
                    var fragDuration = frag.duration;
                    var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
                    var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
                    if (frag.start - start > segmentFraction) {
                      this.flushMainBuffer(start, frag.start);
                    }
                  };
                  _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {
                    var config = this.config;
                    var pos = this.getLoadPosition();
                    if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(pos)) {
                      return null;
                    }
                    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(bufferable, pos, config.maxBufferHole);
                    if (bufferInfo.len === 0 && bufferInfo.nextStart !== void 0) {
                      var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
                      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
                        return _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, config.maxBufferHole));
                      }
                    }
                    return bufferInfo;
                  };
                  _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {
                    var config = this.config;
                    var maxBufLen;
                    if (levelBitrate) {
                      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
                    } else {
                      maxBufLen = config.maxBufferLength;
                    }
                    return Math.min(maxBufLen, config.maxMaxBufferLength);
                  };
                  _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {
                    var config = this.config;
                    var minLength = threshold || config.maxBufferLength;
                    if (config.maxMaxBufferLength >= minLength) {
                      config.maxMaxBufferLength /= 2;
                      this.warn("Reduce max buffer length to " + config.maxMaxBufferLength + "s");
                      return true;
                    }
                    return false;
                  };
                  _proto.getNextFragment = function getNextFragment(pos, levelDetails) {
                    var fragments = levelDetails.fragments;
                    var fragLen = fragments.length;
                    if (!fragLen) {
                      return null;
                    }
                    var config = this.config;
                    var start = fragments[0].start;
                    var frag;
                    if (levelDetails.live) {
                      var initialLiveManifestSize = config.initialLiveManifestSize;
                      if (fragLen < initialLiveManifestSize) {
                        this.warn("Not enough fragments to start playback (have: " + fragLen + ", need: " + initialLiveManifestSize + ")");
                        return null;
                      }
                      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {
                        frag = this.getInitialLiveFragment(levelDetails, fragments);
                        this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
                      }
                    } else if (pos <= start) {
                      frag = fragments[0];
                    }
                    if (!frag) {
                      var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
                      frag = this.getFragmentAtPosition(pos, end, levelDetails);
                    }
                    return this.mapToInitFragWhenRequired(frag);
                  };
                  _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {
                    if (frag !== null && frag !== void 0 && frag.initSegment && !(frag !== null && frag !== void 0 && frag.initSegment.data) && !this.bitrateTest) {
                      return frag.initSegment;
                    }
                    return frag;
                  };
                  _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {
                    var nextPart = -1;
                    var contiguous = false;
                    var independentAttrOmitted = true;
                    for (var i = 0, len = partList.length; i < len; i++) {
                      var part = partList[i];
                      independentAttrOmitted = independentAttrOmitted && !part.independent;
                      if (nextPart > -1 && targetBufferTime < part.start) {
                        break;
                      }
                      var loaded = part.loaded;
                      if (loaded) {
                        nextPart = -1;
                      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
                        nextPart = i;
                      }
                      contiguous = loaded;
                    }
                    return nextPart;
                  };
                  _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {
                    var lastPart = partList[partList.length - 1];
                    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
                  };
                  _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {
                    var fragPrevious = this.fragPrevious;
                    var frag = null;
                    if (fragPrevious) {
                      if (levelDetails.hasProgramDateTime) {
                        this.log("Live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
                        frag = (0, _fragment_finders__WEBPACK_IMPORTED_MODULE_10__.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
                      }
                      if (!frag) {
                        var targetSN = fragPrevious.sn + 1;
                        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                          var fragNext = fragments[targetSN - levelDetails.startSN];
                          if (fragPrevious.cc === fragNext.cc) {
                            frag = fragNext;
                            this.log("Live playlist, switching playlist, load frag with next SN: " + frag.sn);
                          }
                        }
                        if (!frag) {
                          frag = (0, _fragment_finders__WEBPACK_IMPORTED_MODULE_10__.findFragWithCC)(fragments, fragPrevious.cc);
                          if (frag) {
                            this.log("Live playlist, switching playlist, load frag with same CC: " + frag.sn);
                          }
                        }
                      }
                    } else {
                      var liveStart = this.hls.liveSyncPosition;
                      if (liveStart !== null) {
                        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
                      }
                    }
                    return frag;
                  };
                  _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {
                    var config = this.config;
                    var fragPrevious = this.fragPrevious;
                    var fragments = levelDetails.fragments, endSN = levelDetails.endSN;
                    var fragmentHint = levelDetails.fragmentHint;
                    var tolerance = config.maxFragLookUpTolerance;
                    var loadingParts = !!(config.lowLatencyMode && levelDetails.partList && fragmentHint);
                    if (loadingParts && fragmentHint && !this.bitrateTest) {
                      fragments = fragments.concat(fragmentHint);
                      endSN = fragmentHint.sn;
                    }
                    var frag;
                    if (bufferEnd < end) {
                      var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;
                      frag = (0, _fragment_finders__WEBPACK_IMPORTED_MODULE_10__.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, lookupTolerance);
                    } else {
                      frag = fragments[fragments.length - 1];
                    }
                    if (frag) {
                      var curSNIdx = frag.sn - levelDetails.startSN;
                      if (this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__.FragmentState.OK) {
                        fragPrevious = frag;
                      }
                      if (fragPrevious && frag.sn === fragPrevious.sn && !loadingParts) {
                        var sameLevel = fragPrevious && frag.level === fragPrevious.level;
                        if (sameLevel) {
                          var nextFrag = fragments[curSNIdx + 1];
                          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__.FragmentState.OK) {
                            this.log("SN " + frag.sn + " just loaded, load next one: " + nextFrag.sn);
                            frag = nextFrag;
                          } else {
                            frag = null;
                          }
                        }
                      }
                    }
                    return frag;
                  };
                  _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {
                    var config = this.config, media = this.media;
                    if (!media) {
                      return;
                    }
                    var liveSyncPosition = this.hls.liveSyncPosition;
                    var currentTime = media.currentTime;
                    var start = levelDetails.fragments[0].start;
                    var end = levelDetails.edge;
                    var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
                    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
                      var maxLatency = config.liveMaxLatencyDuration !== void 0 ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
                      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
                        if (!this.loadedmetadata) {
                          this.nextLoadPosition = liveSyncPosition;
                        }
                        if (media.readyState) {
                          this.warn("Playback: " + currentTime.toFixed(3) + " is located too far from the end of live sliding playlist: " + end + ", reset currentTime to : " + liveSyncPosition.toFixed(3));
                          media.currentTime = liveSyncPosition;
                        }
                      }
                    }
                  };
                  _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {
                    var levels = this.levels, levelLastLoaded = this.levelLastLoaded, fragPrevious = this.fragPrevious;
                    var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;
                    var length = details.fragments.length;
                    if (!length) {
                      this.warn("No fragments in live playlist");
                      return 0;
                    }
                    var slidingStart = details.fragments[0].start;
                    var firstLevelLoad = !previousDetails;
                    var aligned = details.alignedSliding && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(slidingStart);
                    if (firstLevelLoad || !aligned && !slidingStart) {
                      (0, _utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__.alignStream)(fragPrevious, lastLevel, details);
                      var alignedSlidingStart = details.fragments[0].start;
                      this.log("Live playlist sliding: " + alignedSlidingStart.toFixed(2) + " start-sn: " + (previousDetails ? previousDetails.startSN : "na") + "->" + details.startSN + " prev-sn: " + (fragPrevious ? fragPrevious.sn : "na") + " fragments: " + length);
                      return alignedSlidingStart;
                    }
                    return slidingStart;
                  };
                  _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {
                    var advancePartLimit = 3;
                    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
                  };
                  _proto.setStartPosition = function setStartPosition(details, sliding) {
                    var startPosition = this.startPosition;
                    if (startPosition < sliding) {
                      startPosition = -1;
                    }
                    if (startPosition === -1 || this.lastCurrentTime === -1) {
                      var startTimeOffset = details.startTimeOffset;
                      if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(startTimeOffset)) {
                        startPosition = sliding + startTimeOffset;
                        if (startTimeOffset < 0) {
                          startPosition += details.totalduration;
                        }
                        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
                        this.log("Start time offset " + startTimeOffset + " found in playlist, adjust startPosition to " + startPosition);
                        this.startPosition = startPosition;
                      } else if (details.live) {
                        startPosition = this.hls.liveSyncPosition || sliding;
                      } else {
                        this.startPosition = startPosition = 0;
                      }
                      this.lastCurrentTime = startPosition;
                    }
                    this.nextLoadPosition = startPosition;
                  };
                  _proto.getLoadPosition = function getLoadPosition() {
                    var media = this.media;
                    var pos = 0;
                    if (this.loadedmetadata && media) {
                      pos = media.currentTime;
                    } else if (this.nextLoadPosition) {
                      pos = this.nextLoadPosition;
                    }
                    return pos;
                  };
                  _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {
                    if (this.transmuxer && frag.sn !== "initSegment" && frag.stats.aborted) {
                      this.warn("Fragment " + frag.sn + (part ? " part" + part.index : "") + " of level " + frag.level + " was aborted");
                      this.resetFragmentLoading(frag);
                    }
                  };
                  _proto.resetFragmentLoading = function resetFragmentLoading(frag) {
                    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
                      this.state = State.IDLE;
                    }
                  };
                  _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {
                    if (data.fatal) {
                      this.stopLoad();
                      this.state = State.ERROR;
                      return;
                    }
                    var config = this.config;
                    if (data.chunkMeta) {
                      var context = this.getCurrentContext(data.chunkMeta);
                      if (context) {
                        data.frag = context.frag;
                        data.levelRetry = true;
                        this.fragLoadError = config.fragLoadingMaxRetry;
                      }
                    }
                    var frag = data.frag;
                    if (!frag || frag.type !== filterType) {
                      return;
                    }
                    var fragCurrent = this.fragCurrent;
                    console.assert(fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level && frag.urlId === fragCurrent.urlId, "Frag load error must match current frag to retry");
                    if (this.fragLoadError + 1 <= config.fragLoadingMaxRetry) {
                      if (!this.loadedmetadata) {
                        this.startFragRequested = false;
                        this.nextLoadPosition = this.startPosition;
                      }
                      var delay = Math.min(Math.pow(2, this.fragLoadError) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                      this.warn("Fragment " + frag.sn + " of " + filterType + " " + frag.level + " failed to load, retrying in " + delay + "ms");
                      this.retryDate = self.performance.now() + delay;
                      this.fragLoadError++;
                      this.state = State.FRAG_LOADING_WAITING_RETRY;
                    } else if (data.levelRetry) {
                      if (filterType === _types_loader__WEBPACK_IMPORTED_MODULE_15__.PlaylistLevelType.AUDIO) {
                        this.fragCurrent = null;
                      }
                      this.fragLoadError = 0;
                      this.state = State.IDLE;
                    } else {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.error(data.details + " reaches max retry, redispatch as fatal ...");
                      data.fatal = true;
                      this.hls.stopLoad();
                      this.state = State.ERROR;
                    }
                  };
                  _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {
                    if (!media) {
                      return;
                    }
                    var bufferedTimeRanges = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__.BufferHelper.getBuffered(media);
                    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
                    if (this.state === State.ENDED) {
                      this.resetLoadingState();
                    }
                  };
                  _proto.resetLoadingState = function resetLoadingState() {
                    this.log("Reset loading state");
                    this.fragCurrent = null;
                    this.fragPrevious = null;
                    this.state = State.IDLE;
                  };
                  _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {
                    if (!this.loadedmetadata) {
                      this.startFragRequested = false;
                      var details = this.levels ? this.levels[level].details : null;
                      if (details !== null && details !== void 0 && details.live) {
                        this.startPosition = -1;
                        this.setStartPosition(details, 0);
                        this.resetLoadingState();
                      } else {
                        this.nextLoadPosition = this.startPosition;
                      }
                    }
                  };
                  _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {
                    var _this6 = this;
                    var details = level.details;
                    console.assert(!!details, "level.details must be defined");
                    var parsed = Object.keys(frag.elementaryStreams).reduce(function(result, type) {
                      var info = frag.elementaryStreams[type];
                      if (info) {
                        var parsedDuration = info.endPTS - info.startPTS;
                        if (parsedDuration <= 0) {
                          _this6.warn("Could not parse fragment " + frag.sn + " " + type + " duration reliably (" + parsedDuration + ")");
                          return result || false;
                        }
                        var drift = partial ? 0 : (0, _level_helper__WEBPACK_IMPORTED_MODULE_11__.updateFragPTSDTS)(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
                        _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.LEVEL_PTS_UPDATED, {
                          details,
                          level,
                          drift,
                          type,
                          frag,
                          start: info.startPTS,
                          end: info.endPTS
                        });
                        return true;
                      }
                      return result;
                    }, false);
                    if (!parsed) {
                      this.warn("Found no media in fragment " + frag.sn + " of level " + level.id + " resetting transmuxer to fallback to playlist timing");
                      this.resetTransmuxer();
                    }
                    this.state = State.PARSED;
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__.Events.FRAG_PARSED, {
                      frag,
                      part
                    });
                  };
                  _proto.resetTransmuxer = function resetTransmuxer() {
                    if (this.transmuxer) {
                      this.transmuxer.destroy();
                      this.transmuxer = null;
                    }
                  };
                  _createClass(BaseStreamController2, [{
                    key: "state",
                    get: function get() {
                      return this._state;
                    },
                    set: function set(nextState) {
                      var previousState = this._state;
                      if (previousState !== nextState) {
                        this._state = nextState;
                        this.log(previousState + "->" + nextState);
                      }
                    }
                  }]);
                  return BaseStreamController2;
                }(_task_loop__WEBPACK_IMPORTED_MODULE_1__["default"]);
              }
            ),
            /***/
            "./src/controller/buffer-controller.ts": (
              /*!*********************************************!*\
                !*** ./src/controller/buffer-controller.ts ***!
                \*********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    BufferController
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/buffer-helper */
                  "./src/utils/buffer-helper.ts"
                );
                var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/mediasource-helper */
                  "./src/utils/mediasource-helper.ts"
                );
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../loader/fragment */
                  "./src/loader/fragment.ts"
                );
                var _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ./buffer-operation-queue */
                  "./src/controller/buffer-operation-queue.ts"
                );
                var MediaSource2 = (0, _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__.getMediaSource)();
                var VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\.[^.,]+)+/;
                var BufferController = function() {
                  function BufferController2(hls) {
                    var _this = this;
                    this.details = null;
                    this._objectUrl = null;
                    this.operationQueue = void 0;
                    this.listeners = void 0;
                    this.hls = void 0;
                    this.bufferCodecEventsExpected = 0;
                    this._bufferCodecEventsTotal = 0;
                    this.media = null;
                    this.mediaSource = null;
                    this.lastMpegAudioChunk = null;
                    this.appendError = 0;
                    this.tracks = {};
                    this.pendingTracks = {};
                    this.sourceBuffer = void 0;
                    this._onMediaSourceOpen = function() {
                      var media = _this.media, mediaSource = _this.mediaSource;
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Media source opened");
                      if (media) {
                        media.removeEventListener("emptied", _this._onMediaEmptied);
                        _this.updateMediaElementDuration();
                        _this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, {
                          media
                        });
                      }
                      if (mediaSource) {
                        mediaSource.removeEventListener("sourceopen", _this._onMediaSourceOpen);
                      }
                      _this.checkPendingTracks();
                    };
                    this._onMediaSourceClose = function() {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Media source closed");
                    };
                    this._onMediaSourceEnded = function() {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Media source ended");
                    };
                    this._onMediaEmptied = function() {
                      var media = _this.media, _objectUrl = _this._objectUrl;
                      if (media && media.src !== _objectUrl) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error("Media element src was set while attaching MediaSource (" + _objectUrl + " > " + media.src + ")");
                      }
                    };
                    this.hls = hls;
                    this._initSourceBuffer();
                    this.registerListeners();
                  }
                  var _proto = BufferController2.prototype;
                  _proto.hasSourceTypes = function hasSourceTypes() {
                    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
                  };
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.details = null;
                    this.lastMpegAudioChunk = null;
                  };
                  _proto.registerListeners = function registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_RESET, this.onBufferReset, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_APPENDING, this.onBufferAppending, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_CODECS, this.onBufferCodecs, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_EOS, this.onBufferEos, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSED, this.onFragParsed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_CHANGED, this.onFragChanged, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_RESET, this.onBufferReset, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_APPENDING, this.onBufferAppending, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_CODECS, this.onBufferCodecs, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_EOS, this.onBufferEos, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSED, this.onFragParsed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_CHANGED, this.onFragChanged, this);
                  };
                  _proto._initSourceBuffer = function _initSourceBuffer() {
                    this.sourceBuffer = {};
                    this.operationQueue = new _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__["default"](this.sourceBuffer);
                    this.listeners = {
                      audio: [],
                      video: [],
                      audiovideo: []
                    };
                    this.lastMpegAudioChunk = null;
                  };
                  _proto.onManifestParsed = function onManifestParsed(event, data) {
                    var codecEvents = 2;
                    if (data.audio && !data.video || !data.altAudio) {
                      codecEvents = 1;
                    }
                    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
                    this.details = null;
                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
                  };
                  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                    var media = this.media = data.media;
                    if (media && MediaSource2) {
                      var ms = this.mediaSource = new MediaSource2();
                      ms.addEventListener("sourceopen", this._onMediaSourceOpen);
                      ms.addEventListener("sourceended", this._onMediaSourceEnded);
                      ms.addEventListener("sourceclose", this._onMediaSourceClose);
                      media.src = self.URL.createObjectURL(ms);
                      this._objectUrl = media.src;
                      media.addEventListener("emptied", this._onMediaEmptied);
                    }
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    var media = this.media, mediaSource = this.mediaSource, _objectUrl = this._objectUrl;
                    if (mediaSource) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: media source detaching");
                      if (mediaSource.readyState === "open") {
                        try {
                          mediaSource.endOfStream();
                        } catch (err) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[buffer-controller]: onMediaDetaching: " + err.message + " while calling endOfStream");
                        }
                      }
                      this.onBufferReset();
                      mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
                      mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
                      mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
                      if (media) {
                        media.removeEventListener("emptied", this._onMediaEmptied);
                        if (_objectUrl) {
                          self.URL.revokeObjectURL(_objectUrl);
                        }
                        if (media.src === _objectUrl) {
                          media.removeAttribute("src");
                          media.load();
                        } else {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup");
                        }
                      }
                      this.mediaSource = null;
                      this.media = null;
                      this._objectUrl = null;
                      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
                      this.pendingTracks = {};
                      this.tracks = {};
                    }
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHED, void 0);
                  };
                  _proto.onBufferReset = function onBufferReset() {
                    var _this2 = this;
                    this.getSourceBufferTypes().forEach(function(type) {
                      var sb = _this2.sourceBuffer[type];
                      try {
                        if (sb) {
                          _this2.removeBufferListeners(type);
                          if (_this2.mediaSource) {
                            _this2.mediaSource.removeSourceBuffer(sb);
                          }
                          _this2.sourceBuffer[type] = void 0;
                        }
                      } catch (err) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[buffer-controller]: Failed to reset the " + type + " buffer", err);
                      }
                    });
                    this._initSourceBuffer();
                  };
                  _proto.onBufferCodecs = function onBufferCodecs(event, data) {
                    var _this3 = this;
                    var sourceBufferCount = this.getSourceBufferTypes().length;
                    Object.keys(data).forEach(function(trackName) {
                      if (sourceBufferCount) {
                        var track = _this3.tracks[trackName];
                        if (track && typeof track.buffer.changeType === "function") {
                          var _data$trackName = data[trackName], id = _data$trackName.id, codec = _data$trackName.codec, levelCodec = _data$trackName.levelCodec, container = _data$trackName.container, metadata = _data$trackName.metadata;
                          var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
                          var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
                          if (currentCodec !== nextCodec) {
                            var mimeType = container + ";codecs=" + (levelCodec || codec);
                            _this3.appendChangeType(trackName, mimeType);
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: switching codec " + currentCodec + " to " + nextCodec);
                            _this3.tracks[trackName] = {
                              buffer: track.buffer,
                              codec,
                              container,
                              levelCodec,
                              metadata,
                              id
                            };
                          }
                        }
                      } else {
                        _this3.pendingTracks[trackName] = data[trackName];
                      }
                    });
                    if (sourceBufferCount) {
                      return;
                    }
                    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
                    if (this.mediaSource && this.mediaSource.readyState === "open") {
                      this.checkPendingTracks();
                    }
                  };
                  _proto.appendChangeType = function appendChangeType(type, mimeType) {
                    var _this4 = this;
                    var operationQueue = this.operationQueue;
                    var operation = {
                      execute: function execute() {
                        var sb = _this4.sourceBuffer[type];
                        if (sb) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: changing " + type + " sourceBuffer type to " + mimeType);
                          sb.changeType(mimeType);
                        }
                        operationQueue.shiftAndExecuteNext(type);
                      },
                      onStart: function onStart() {
                      },
                      onComplete: function onComplete() {
                      },
                      onError: function onError(e) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[buffer-controller]: Failed to change " + type + " SourceBuffer type", e);
                      }
                    };
                    operationQueue.append(operation, type);
                  };
                  _proto.onBufferAppending = function onBufferAppending(event, eventData) {
                    var _this5 = this;
                    var hls = this.hls, operationQueue = this.operationQueue, tracks = this.tracks;
                    var data = eventData.data, type = eventData.type, frag = eventData.frag, part = eventData.part, chunkMeta = eventData.chunkMeta;
                    var chunkStats = chunkMeta.buffering[type];
                    var bufferAppendingStart = self.performance.now();
                    chunkStats.start = bufferAppendingStart;
                    var fragBuffering = frag.stats.buffering;
                    var partBuffering = part ? part.stats.buffering : null;
                    if (fragBuffering.start === 0) {
                      fragBuffering.start = bufferAppendingStart;
                    }
                    if (partBuffering && partBuffering.start === 0) {
                      partBuffering.start = bufferAppendingStart;
                    }
                    var audioTrack = tracks.audio;
                    var checkTimestampOffset = false;
                    if (type === "audio" && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.container) === "audio/mpeg") {
                      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
                      this.lastMpegAudioChunk = chunkMeta;
                    }
                    var fragStart = frag.start;
                    var operation = {
                      execute: function execute() {
                        chunkStats.executeStart = self.performance.now();
                        if (checkTimestampOffset) {
                          var sb = _this5.sourceBuffer[type];
                          if (sb) {
                            var delta = fragStart - sb.timestampOffset;
                            if (Math.abs(delta) >= 0.1) {
                              _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + fragStart + " (delta: " + delta + ") sn: " + frag.sn + ")");
                              sb.timestampOffset = fragStart;
                            }
                          }
                        }
                        _this5.appendExecutor(data, type);
                      },
                      onStart: function onStart() {
                      },
                      onComplete: function onComplete() {
                        var end = self.performance.now();
                        chunkStats.executeEnd = chunkStats.end = end;
                        if (fragBuffering.first === 0) {
                          fragBuffering.first = end;
                        }
                        if (partBuffering && partBuffering.first === 0) {
                          partBuffering.first = end;
                        }
                        var sourceBuffer = _this5.sourceBuffer;
                        var timeRanges = {};
                        for (var _type in sourceBuffer) {
                          timeRanges[_type] = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(sourceBuffer[_type]);
                        }
                        _this5.appendError = 0;
                        _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_APPENDED, {
                          type,
                          frag,
                          part,
                          chunkMeta,
                          parent: frag.type,
                          timeRanges
                        });
                      },
                      onError: function onError(err) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error("[buffer-controller]: Error encountered while trying to append to the " + type + " SourceBuffer", err);
                        var event2 = {
                          type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,
                          parent: frag.type,
                          details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_APPEND_ERROR,
                          err,
                          fatal: false
                        };
                        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {
                          event2.details = _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_FULL_ERROR;
                        } else {
                          _this5.appendError++;
                          event2.details = _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_APPEND_ERROR;
                          if (_this5.appendError > hls.config.appendErrorMaxRetry) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error("[buffer-controller]: Failed " + hls.config.appendErrorMaxRetry + " times to append segment in sourceBuffer");
                            event2.fatal = true;
                            hls.stopLoad();
                          }
                        }
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, event2);
                      }
                    };
                    operationQueue.append(operation, type);
                  };
                  _proto.onBufferFlushing = function onBufferFlushing(event, data) {
                    var _this6 = this;
                    var operationQueue = this.operationQueue;
                    var flushOperation = function flushOperation2(type) {
                      return {
                        execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),
                        onStart: function onStart() {
                        },
                        onComplete: function onComplete() {
                          _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHED, {
                            type
                          });
                        },
                        onError: function onError(e) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[buffer-controller]: Failed to remove from " + type + " SourceBuffer", e);
                        }
                      };
                    };
                    if (data.type) {
                      operationQueue.append(flushOperation(data.type), data.type);
                    } else {
                      this.getSourceBufferTypes().forEach(function(type) {
                        operationQueue.append(flushOperation(type), type);
                      });
                    }
                  };
                  _proto.onFragParsed = function onFragParsed(event, data) {
                    var _this7 = this;
                    var frag = data.frag, part = data.part;
                    var buffersAppendedTo = [];
                    var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
                    if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__.ElementaryStreamTypes.AUDIOVIDEO]) {
                      buffersAppendedTo.push("audiovideo");
                    } else {
                      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__.ElementaryStreamTypes.AUDIO]) {
                        buffersAppendedTo.push("audio");
                      }
                      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__.ElementaryStreamTypes.VIDEO]) {
                        buffersAppendedTo.push("video");
                      }
                    }
                    var onUnblocked = function onUnblocked2() {
                      var now = self.performance.now();
                      frag.stats.buffering.end = now;
                      if (part) {
                        part.stats.buffering.end = now;
                      }
                      var stats = part ? part.stats : frag.stats;
                      _this7.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_BUFFERED, {
                        frag,
                        part,
                        stats,
                        id: frag.type
                      });
                    };
                    if (buffersAppendedTo.length === 0) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("Fragments must have at least one ElementaryStreamType set. type: " + frag.type + " level: " + frag.level + " sn: " + frag.sn);
                    }
                    this.blockBuffers(onUnblocked, buffersAppendedTo);
                  };
                  _proto.onFragChanged = function onFragChanged(event, data) {
                    this.flushBackBuffer();
                  };
                  _proto.onBufferEos = function onBufferEos(event, data) {
                    var _this8 = this;
                    var ended = this.getSourceBufferTypes().reduce(function(acc, type) {
                      var sb = _this8.sourceBuffer[type];
                      if (sb && (!data.type || data.type === type)) {
                        sb.ending = true;
                        if (!sb.ended) {
                          sb.ended = true;
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: " + type + " sourceBuffer now EOS");
                        }
                      }
                      return acc && !!(!sb || sb.ended);
                    }, true);
                    if (ended) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Queueing mediaSource.endOfStream()");
                      this.blockBuffers(function() {
                        _this8.getSourceBufferTypes().forEach(function(type) {
                          var sb = _this8.sourceBuffer[type];
                          if (sb) {
                            sb.ending = false;
                          }
                        });
                        var mediaSource = _this8.mediaSource;
                        if (!mediaSource || mediaSource.readyState !== "open") {
                          if (mediaSource) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.info("[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: " + mediaSource.readyState);
                          }
                          return;
                        }
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Calling mediaSource.endOfStream()");
                        mediaSource.endOfStream();
                      });
                    }
                  };
                  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
                    var details = _ref.details;
                    if (!details.fragments.length) {
                      return;
                    }
                    this.details = details;
                    if (this.getSourceBufferTypes().length) {
                      this.blockBuffers(this.updateMediaElementDuration.bind(this));
                    } else {
                      this.updateMediaElementDuration();
                    }
                  };
                  _proto.flushBackBuffer = function flushBackBuffer() {
                    var hls = this.hls, details = this.details, media = this.media, sourceBuffer = this.sourceBuffer;
                    if (!media || details === null) {
                      return;
                    }
                    var sourceBufferTypes = this.getSourceBufferTypes();
                    if (!sourceBufferTypes.length) {
                      return;
                    }
                    var backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;
                    if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(backBufferLength) || backBufferLength < 0) {
                      return;
                    }
                    var currentTime = media.currentTime;
                    var targetDuration = details.levelTargetDuration;
                    var maxBackBufferLength = Math.max(backBufferLength, targetDuration);
                    var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
                    sourceBufferTypes.forEach(function(type) {
                      var sb = sourceBuffer[type];
                      if (sb) {
                        var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(sb);
                        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
                          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BACK_BUFFER_REACHED, {
                            bufferEnd: targetBackBufferPosition
                          });
                          if (details.live) {
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LIVE_BACK_BUFFER_REACHED, {
                              bufferEnd: targetBackBufferPosition
                            });
                          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.info("[buffer-controller]: Cannot flush " + type + " back buffer while SourceBuffer is in ended state");
                            return;
                          }
                          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: targetBackBufferPosition,
                            type
                          });
                        }
                      }
                    });
                  };
                  _proto.updateMediaElementDuration = function updateMediaElementDuration() {
                    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") {
                      return;
                    }
                    var details = this.details, hls = this.hls, media = this.media, mediaSource = this.mediaSource;
                    var levelDuration = details.fragments[0].start + details.totalduration;
                    var mediaDuration = media.duration;
                    var msDuration = (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mediaSource.duration) ? mediaSource.duration : 0;
                    if (details.live && hls.config.liveDurationInfinity) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Media Source duration is set to Infinity");
                      mediaSource.duration = Infinity;
                      this.updateSeekableRange(details);
                    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mediaDuration)) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Updating Media Source duration to " + levelDuration.toFixed(3));
                      mediaSource.duration = levelDuration;
                    }
                  };
                  _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {
                    var mediaSource = this.mediaSource;
                    var fragments = levelDetails.fragments;
                    var len = fragments.length;
                    if (len && levelDetails.live && mediaSource !== null && mediaSource !== void 0 && mediaSource.setLiveSeekableRange) {
                      var start = Math.max(0, fragments[0].start);
                      var end = Math.max(start, start + levelDetails.totalduration);
                      mediaSource.setLiveSeekableRange(start, end);
                    }
                  };
                  _proto.checkPendingTracks = function checkPendingTracks() {
                    var bufferCodecEventsExpected = this.bufferCodecEventsExpected, operationQueue = this.operationQueue, pendingTracks = this.pendingTracks;
                    var pendingTracksCount = Object.keys(pendingTracks).length;
                    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
                      this.createSourceBuffers(pendingTracks);
                      this.pendingTracks = {};
                      var buffers = this.getSourceBufferTypes();
                      if (buffers.length === 0) {
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                          type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,
                          details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                          fatal: true,
                          reason: "could not create source buffer for media codec(s)"
                        });
                        return;
                      }
                      buffers.forEach(function(type) {
                        operationQueue.executeNext(type);
                      });
                    }
                  };
                  _proto.createSourceBuffers = function createSourceBuffers(tracks) {
                    var sourceBuffer = this.sourceBuffer, mediaSource = this.mediaSource;
                    if (!mediaSource) {
                      throw Error("createSourceBuffers called when mediaSource was null");
                    }
                    var tracksCreated = 0;
                    for (var trackName in tracks) {
                      if (!sourceBuffer[trackName]) {
                        var track = tracks[trackName];
                        if (!track) {
                          throw Error("source buffer exists for track " + trackName + ", however track does not");
                        }
                        var codec = track.levelCodec || track.codec;
                        var mimeType = track.container + ";codecs=" + codec;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: creating sourceBuffer(" + mimeType + ")");
                        try {
                          var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
                          var sbName = trackName;
                          this.addBufferListener(sbName, "updatestart", this._onSBUpdateStart);
                          this.addBufferListener(sbName, "updateend", this._onSBUpdateEnd);
                          this.addBufferListener(sbName, "error", this._onSBUpdateError);
                          this.tracks[trackName] = {
                            buffer: sb,
                            codec,
                            container: track.container,
                            levelCodec: track.levelCodec,
                            metadata: track.metadata,
                            id: track.id
                          };
                          tracksCreated++;
                        } catch (err) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error("[buffer-controller]: error while trying to add sourceBuffer: " + err.message);
                          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                            fatal: false,
                            error: err,
                            mimeType
                          });
                        }
                      }
                    }
                    if (tracksCreated) {
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_CREATED, {
                        tracks: this.tracks
                      });
                    }
                  };
                  _proto._onSBUpdateStart = function _onSBUpdateStart(type) {
                    var operationQueue = this.operationQueue;
                    var operation = operationQueue.current(type);
                    operation.onStart();
                  };
                  _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {
                    var operationQueue = this.operationQueue;
                    var operation = operationQueue.current(type);
                    operation.onComplete();
                    operationQueue.shiftAndExecuteNext(type);
                  };
                  _proto._onSBUpdateError = function _onSBUpdateError(type, event) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error("[buffer-controller]: " + type + " SourceBuffer error", event);
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                      type: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorTypes.MEDIA_ERROR,
                      details: _errors__WEBPACK_IMPORTED_MODULE_3__.ErrorDetails.BUFFER_APPENDING_ERROR,
                      fatal: false
                    });
                    var operation = this.operationQueue.current(type);
                    if (operation) {
                      operation.onError(event);
                    }
                  };
                  _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {
                    var media = this.media, mediaSource = this.mediaSource, operationQueue = this.operationQueue, sourceBuffer = this.sourceBuffer;
                    var sb = sourceBuffer[type];
                    if (!media || !mediaSource || !sb) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[buffer-controller]: Attempting to remove from the " + type + " SourceBuffer, but it does not exist");
                      operationQueue.shiftAndExecuteNext(type);
                      return;
                    }
                    var mediaDuration = (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(media.duration) ? media.duration : Infinity;
                    var msDuration = (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mediaSource.duration) ? mediaSource.duration : Infinity;
                    var removeStart = Math.max(0, startOffset);
                    var removeEnd = Math.min(endOffset, mediaDuration, msDuration);
                    if (removeEnd > removeStart && !sb.ending) {
                      sb.ended = false;
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Removing [" + removeStart + "," + removeEnd + "] from the " + type + " SourceBuffer");
                      console.assert(!sb.updating, type + " sourceBuffer must not be updating");
                      sb.remove(removeStart, removeEnd);
                    } else {
                      operationQueue.shiftAndExecuteNext(type);
                    }
                  };
                  _proto.appendExecutor = function appendExecutor(data, type) {
                    var operationQueue = this.operationQueue, sourceBuffer = this.sourceBuffer;
                    var sb = sourceBuffer[type];
                    if (!sb) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[buffer-controller]: Attempting to append to the " + type + " SourceBuffer, but it does not exist");
                      operationQueue.shiftAndExecuteNext(type);
                      return;
                    }
                    sb.ended = false;
                    console.assert(!sb.updating, type + " sourceBuffer must not be updating");
                    sb.appendBuffer(data);
                  };
                  _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {
                    var _this9 = this;
                    if (buffers === void 0) {
                      buffers = this.getSourceBufferTypes();
                    }
                    if (!buffers.length) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist");
                      Promise.resolve().then(onUnblocked);
                      return;
                    }
                    var operationQueue = this.operationQueue;
                    var blockingOperations = buffers.map(function(type) {
                      return operationQueue.appendBlocker(type);
                    });
                    Promise.all(blockingOperations).then(function() {
                      onUnblocked();
                      buffers.forEach(function(type) {
                        var sb = _this9.sourceBuffer[type];
                        if (!sb || !sb.updating) {
                          operationQueue.shiftAndExecuteNext(type);
                        }
                      });
                    });
                  };
                  _proto.getSourceBufferTypes = function getSourceBufferTypes() {
                    return Object.keys(this.sourceBuffer);
                  };
                  _proto.addBufferListener = function addBufferListener(type, event, fn) {
                    var buffer = this.sourceBuffer[type];
                    if (!buffer) {
                      return;
                    }
                    var listener = fn.bind(this, type);
                    this.listeners[type].push({
                      event,
                      listener
                    });
                    buffer.addEventListener(event, listener);
                  };
                  _proto.removeBufferListeners = function removeBufferListeners(type) {
                    var buffer = this.sourceBuffer[type];
                    if (!buffer) {
                      return;
                    }
                    this.listeners[type].forEach(function(l) {
                      buffer.removeEventListener(l.event, l.listener);
                    });
                  };
                  return BufferController2;
                }();
              }
            ),
            /***/
            "./src/controller/buffer-operation-queue.ts": (
              /*!**************************************************!*\
                !*** ./src/controller/buffer-operation-queue.ts ***!
                \**************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    BufferOperationQueue
                  )
                  /* harmony export */
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var BufferOperationQueue = function() {
                  function BufferOperationQueue2(sourceBufferReference) {
                    this.buffers = void 0;
                    this.queues = {
                      video: [],
                      audio: [],
                      audiovideo: []
                    };
                    this.buffers = sourceBufferReference;
                  }
                  var _proto = BufferOperationQueue2.prototype;
                  _proto.append = function append(operation, type) {
                    var queue = this.queues[type];
                    queue.push(operation);
                    if (queue.length === 1 && this.buffers[type]) {
                      this.executeNext(type);
                    }
                  };
                  _proto.insertAbort = function insertAbort(operation, type) {
                    var queue = this.queues[type];
                    queue.unshift(operation);
                    this.executeNext(type);
                  };
                  _proto.appendBlocker = function appendBlocker(type) {
                    var execute;
                    var promise = new Promise(function(resolve) {
                      execute = resolve;
                    });
                    var operation = {
                      execute,
                      onStart: function onStart() {
                      },
                      onComplete: function onComplete() {
                      },
                      onError: function onError() {
                      }
                    };
                    this.append(operation, type);
                    return promise;
                  };
                  _proto.executeNext = function executeNext(type) {
                    var buffers = this.buffers, queues = this.queues;
                    var sb = buffers[type];
                    var queue = queues[type];
                    if (queue.length) {
                      var operation = queue[0];
                      try {
                        operation.execute();
                      } catch (e) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation");
                        operation.onError(e);
                        if (!sb || !sb.updating) {
                          queue.shift();
                          this.executeNext(type);
                        }
                      }
                    }
                  };
                  _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {
                    this.queues[type].shift();
                    this.executeNext(type);
                  };
                  _proto.current = function current(type) {
                    return this.queues[type][0];
                  };
                  return BufferOperationQueue2;
                }();
              }
            ),
            /***/
            "./src/controller/cap-level-controller.ts": (
              /*!************************************************!*\
                !*** ./src/controller/cap-level-controller.ts ***!
                \************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var CapLevelController = function() {
                  function CapLevelController2(hls) {
                    this.autoLevelCapping = void 0;
                    this.firstLevel = void 0;
                    this.media = void 0;
                    this.restrictedLevels = void 0;
                    this.timer = void 0;
                    this.hls = void 0;
                    this.streamController = void 0;
                    this.clientRect = void 0;
                    this.hls = hls;
                    this.autoLevelCapping = Number.POSITIVE_INFINITY;
                    this.firstLevel = -1;
                    this.media = null;
                    this.restrictedLevels = [];
                    this.timer = void 0;
                    this.clientRect = null;
                    this.registerListeners();
                  }
                  var _proto = CapLevelController2.prototype;
                  _proto.setStreamController = function setStreamController(streamController) {
                    this.streamController = streamController;
                  };
                  _proto.destroy = function destroy() {
                    this.unregisterListener();
                    if (this.hls.config.capLevelToPlayerSize) {
                      this.stopCapping();
                    }
                    this.media = null;
                    this.clientRect = null;
                    this.hls = this.streamController = null;
                  };
                  _proto.registerListeners = function registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CODECS, this.onBufferCodecs, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                  };
                  _proto.unregisterListener = function unregisterListener() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CODECS, this.onBufferCodecs, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                  };
                  _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {
                    if (CapLevelController2.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
                      this.restrictedLevels.push(data.droppedLevel);
                    }
                  };
                  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                    this.media = data.media instanceof HTMLVideoElement ? data.media : null;
                    this.clientRect = null;
                  };
                  _proto.onManifestParsed = function onManifestParsed(event, data) {
                    var hls = this.hls;
                    this.restrictedLevels = [];
                    this.firstLevel = data.firstLevel;
                    if (hls.config.capLevelToPlayerSize && data.video) {
                      this.startCapping();
                    }
                  };
                  _proto.onBufferCodecs = function onBufferCodecs(event, data) {
                    var hls = this.hls;
                    if (hls.config.capLevelToPlayerSize && data.video) {
                      this.startCapping();
                    }
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    this.stopCapping();
                  };
                  _proto.detectPlayerSize = function detectPlayerSize() {
                    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
                      var levels = this.hls.levels;
                      if (levels.length) {
                        var hls = this.hls;
                        hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);
                        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
                          this.streamController.nextLevelSwitch();
                        }
                        this.autoLevelCapping = hls.autoLevelCapping;
                      }
                    }
                  };
                  _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
                    var _this = this;
                    var levels = this.hls.levels;
                    if (!levels.length) {
                      return -1;
                    }
                    var validLevels = levels.filter(function(level, index) {
                      return CapLevelController2.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;
                    });
                    this.clientRect = null;
                    return CapLevelController2.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
                  };
                  _proto.startCapping = function startCapping() {
                    if (this.timer) {
                      return;
                    }
                    this.autoLevelCapping = Number.POSITIVE_INFINITY;
                    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
                    self.clearInterval(this.timer);
                    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3);
                    this.detectPlayerSize();
                  };
                  _proto.stopCapping = function stopCapping() {
                    this.restrictedLevels = [];
                    this.firstLevel = -1;
                    this.autoLevelCapping = Number.POSITIVE_INFINITY;
                    if (this.timer) {
                      self.clearInterval(this.timer);
                      this.timer = void 0;
                    }
                  };
                  _proto.getDimensions = function getDimensions() {
                    if (this.clientRect) {
                      return this.clientRect;
                    }
                    var media = this.media;
                    var boundsRect = {
                      width: 0,
                      height: 0
                    };
                    if (media) {
                      var clientRect = media.getBoundingClientRect();
                      boundsRect.width = clientRect.width;
                      boundsRect.height = clientRect.height;
                      if (!boundsRect.width && !boundsRect.height) {
                        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
                        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
                      }
                    }
                    this.clientRect = boundsRect;
                    return boundsRect;
                  };
                  CapLevelController2.isLevelAllowed = function isLevelAllowed(level, restrictedLevels) {
                    if (restrictedLevels === void 0) {
                      restrictedLevels = [];
                    }
                    return restrictedLevels.indexOf(level) === -1;
                  };
                  CapLevelController2.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
                    if (!levels || !levels.length) {
                      return -1;
                    }
                    var atGreatestBandwidth = function atGreatestBandwidth2(curLevel, nextLevel) {
                      if (!nextLevel) {
                        return true;
                      }
                      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
                    };
                    var maxLevelIndex = levels.length - 1;
                    for (var i = 0; i < levels.length; i += 1) {
                      var level = levels[i];
                      if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {
                        maxLevelIndex = i;
                        break;
                      }
                    }
                    return maxLevelIndex;
                  };
                  _createClass(CapLevelController2, [{
                    key: "mediaWidth",
                    get: function get() {
                      return this.getDimensions().width * this.contentScaleFactor;
                    }
                  }, {
                    key: "mediaHeight",
                    get: function get() {
                      return this.getDimensions().height * this.contentScaleFactor;
                    }
                  }, {
                    key: "contentScaleFactor",
                    get: function get() {
                      var pixelRatio = 1;
                      if (!this.hls.config.ignoreDevicePixelRatio) {
                        try {
                          pixelRatio = self.devicePixelRatio;
                        } catch (e) {
                        }
                      }
                      return pixelRatio;
                    }
                  }]);
                  return CapLevelController2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = CapLevelController;
              }
            ),
            /***/
            "./src/controller/cmcd-controller.ts": (
              /*!*******************************************!*\
                !*** ./src/controller/cmcd-controller.ts ***!
                \*******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    CMCDController
                  )
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _types_cmcd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../types/cmcd */
                  "./src/types/cmcd.ts"
                );
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/buffer-helper */
                  "./src/utils/buffer-helper.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _createForOfIteratorHelperLoose(o, allowArrayLike) {
                  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                  if (it)
                    return (it = it.call(o)).next.bind(it);
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    return function() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _unsupportedIterableToArray(o, minLen) {
                  if (!o)
                    return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(o, minLen);
                  var n = Object.prototype.toString.call(o).slice(8, -1);
                  if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return _arrayLikeToArray(o, minLen);
                }
                function _arrayLikeToArray(arr, len) {
                  if (len == null || len > arr.length)
                    len = arr.length;
                  for (var i = 0, arr2 = new Array(len); i < len; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                var CMCDController = function() {
                  function CMCDController2(hls) {
                    var _this = this;
                    this.hls = void 0;
                    this.config = void 0;
                    this.media = void 0;
                    this.sid = void 0;
                    this.cid = void 0;
                    this.useHeaders = false;
                    this.initialized = false;
                    this.starved = false;
                    this.buffering = true;
                    this.audioBuffer = void 0;
                    this.videoBuffer = void 0;
                    this.onWaiting = function() {
                      if (_this.initialized) {
                        _this.starved = true;
                      }
                      _this.buffering = true;
                    };
                    this.onPlaying = function() {
                      if (!_this.initialized) {
                        _this.initialized = true;
                      }
                      _this.buffering = false;
                    };
                    this.applyPlaylistData = function(context) {
                      try {
                        _this.apply(context, {
                          ot: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MANIFEST,
                          su: !_this.initialized
                        });
                      } catch (error) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Could not generate manifest CMCD data.", error);
                      }
                    };
                    this.applyFragmentData = function(context) {
                      try {
                        var fragment = context.frag;
                        var level = _this.hls.levels[fragment.level];
                        var ot = _this.getObjectType(fragment);
                        var data = {
                          d: fragment.duration * 1e3,
                          ot
                        };
                        if (ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.VIDEO || ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO || ot == _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MUXED) {
                          data.br = level.bitrate / 1e3;
                          data.tb = _this.getTopBandwidth(ot) / 1e3;
                          data.bl = _this.getBufferLength(ot);
                        }
                        _this.apply(context, data);
                      } catch (error) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Could not generate segment CMCD data.", error);
                      }
                    };
                    this.hls = hls;
                    var config = this.config = hls.config;
                    var cmcd = config.cmcd;
                    if (cmcd != null) {
                      config.pLoader = this.createPlaylistLoader();
                      config.fLoader = this.createFragmentLoader();
                      this.sid = cmcd.sessionId || CMCDController2.uuid();
                      this.cid = cmcd.contentId;
                      this.useHeaders = cmcd.useHeaders === true;
                      this.registerListeners();
                    }
                  }
                  var _proto = CMCDController2.prototype;
                  _proto.registerListeners = function registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CREATED, this.onBufferCreated, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_CREATED, this.onBufferCreated, this);
                    this.onMediaDetached();
                  };
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
                  };
                  _proto.onMediaAttached = function onMediaAttached(event, data) {
                    this.media = data.media;
                    this.media.addEventListener("waiting", this.onWaiting);
                    this.media.addEventListener("playing", this.onPlaying);
                  };
                  _proto.onMediaDetached = function onMediaDetached() {
                    if (!this.media) {
                      return;
                    }
                    this.media.removeEventListener("waiting", this.onWaiting);
                    this.media.removeEventListener("playing", this.onPlaying);
                    this.media = null;
                  };
                  _proto.onBufferCreated = function onBufferCreated(event, data) {
                    var _data$tracks$audio, _data$tracks$video;
                    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) === null || _data$tracks$audio === void 0 ? void 0 : _data$tracks$audio.buffer;
                    this.videoBuffer = (_data$tracks$video = data.tracks.video) === null || _data$tracks$video === void 0 ? void 0 : _data$tracks$video.buffer;
                  };
                  _proto.createData = function createData() {
                    var _this$media;
                    return {
                      v: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDVersion,
                      sf: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDStreamingFormat.HLS,
                      sid: this.sid,
                      cid: this.cid,
                      pr: (_this$media = this.media) === null || _this$media === void 0 ? void 0 : _this$media.playbackRate,
                      mtp: this.hls.bandwidthEstimate / 1e3
                    };
                  };
                  _proto.apply = function apply(context, data) {
                    if (data === void 0) {
                      data = {};
                    }
                    _extends(data, this.createData());
                    var isVideo = data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.INIT || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.VIDEO || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MUXED;
                    if (this.starved && isVideo) {
                      data.bs = true;
                      data.su = true;
                      this.starved = false;
                    }
                    if (data.su == null) {
                      data.su = this.buffering;
                    }
                    if (this.useHeaders) {
                      var headers = CMCDController2.toHeaders(data);
                      if (!Object.keys(headers).length) {
                        return;
                      }
                      if (!context.headers) {
                        context.headers = {};
                      }
                      _extends(context.headers, headers);
                    } else {
                      var query = CMCDController2.toQuery(data);
                      if (!query) {
                        return;
                      }
                      context.url = CMCDController2.appendQueryToUri(context.url, query);
                    }
                  };
                  _proto.getObjectType = function getObjectType(fragment) {
                    var type = fragment.type;
                    if (type === "subtitle") {
                      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.TIMED_TEXT;
                    }
                    if (fragment.sn === "initSegment") {
                      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.INIT;
                    }
                    if (type === "audio") {
                      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO;
                    }
                    if (type === "main") {
                      if (!this.hls.audioTracks.length) {
                        return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.MUXED;
                      }
                      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.VIDEO;
                    }
                    return void 0;
                  };
                  _proto.getTopBandwidth = function getTopBandwidth(type) {
                    var bitrate = 0;
                    var levels;
                    var hls = this.hls;
                    if (type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO) {
                      levels = hls.audioTracks;
                    } else {
                      var max = hls.maxAutoLevel;
                      var len = max > -1 ? max + 1 : hls.levels.length;
                      levels = hls.levels.slice(0, len);
                    }
                    for (var _iterator = _createForOfIteratorHelperLoose(levels), _step; !(_step = _iterator()).done; ) {
                      var level = _step.value;
                      if (level.bitrate > bitrate) {
                        bitrate = level.bitrate;
                      }
                    }
                    return bitrate > 0 ? bitrate : NaN;
                  };
                  _proto.getBufferLength = function getBufferLength(type) {
                    var media = this.hls.media;
                    var buffer = type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__.CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
                    if (!buffer || !media) {
                      return NaN;
                    }
                    var info = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__.BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
                    return info.len * 1e3;
                  };
                  _proto.createPlaylistLoader = function createPlaylistLoader() {
                    var pLoader = this.config.pLoader;
                    var apply = this.applyPlaylistData;
                    var Ctor = pLoader || this.config.loader;
                    return function() {
                      function CmcdPlaylistLoader(config) {
                        this.loader = void 0;
                        this.loader = new Ctor(config);
                      }
                      var _proto2 = CmcdPlaylistLoader.prototype;
                      _proto2.destroy = function destroy() {
                        this.loader.destroy();
                      };
                      _proto2.abort = function abort() {
                        this.loader.abort();
                      };
                      _proto2.load = function load(context, config, callbacks) {
                        apply(context);
                        this.loader.load(context, config, callbacks);
                      };
                      _createClass(CmcdPlaylistLoader, [{
                        key: "stats",
                        get: function get() {
                          return this.loader.stats;
                        }
                      }, {
                        key: "context",
                        get: function get() {
                          return this.loader.context;
                        }
                      }]);
                      return CmcdPlaylistLoader;
                    }();
                  };
                  _proto.createFragmentLoader = function createFragmentLoader() {
                    var fLoader = this.config.fLoader;
                    var apply = this.applyFragmentData;
                    var Ctor = fLoader || this.config.loader;
                    return function() {
                      function CmcdFragmentLoader(config) {
                        this.loader = void 0;
                        this.loader = new Ctor(config);
                      }
                      var _proto3 = CmcdFragmentLoader.prototype;
                      _proto3.destroy = function destroy() {
                        this.loader.destroy();
                      };
                      _proto3.abort = function abort() {
                        this.loader.abort();
                      };
                      _proto3.load = function load(context, config, callbacks) {
                        apply(context);
                        this.loader.load(context, config, callbacks);
                      };
                      _createClass(CmcdFragmentLoader, [{
                        key: "stats",
                        get: function get() {
                          return this.loader.stats;
                        }
                      }, {
                        key: "context",
                        get: function get() {
                          return this.loader.context;
                        }
                      }]);
                      return CmcdFragmentLoader;
                    }();
                  };
                  CMCDController2.uuid = function uuid() {
                    var url = URL.createObjectURL(new Blob());
                    var uuid2 = url.toString();
                    URL.revokeObjectURL(url);
                    return uuid2.slice(uuid2.lastIndexOf("/") + 1);
                  };
                  CMCDController2.serialize = function serialize(data) {
                    var results = [];
                    var isValid = function isValid2(value2) {
                      return !Number.isNaN(value2) && value2 != null && value2 !== "" && value2 !== false;
                    };
                    var toRounded = function toRounded2(value2) {
                      return Math.round(value2);
                    };
                    var toHundred = function toHundred2(value2) {
                      return toRounded(value2 / 100) * 100;
                    };
                    var toUrlSafe = function toUrlSafe2(value2) {
                      return encodeURIComponent(value2);
                    };
                    var formatters = {
                      br: toRounded,
                      d: toRounded,
                      bl: toHundred,
                      dl: toHundred,
                      mtp: toHundred,
                      nor: toUrlSafe,
                      rtp: toHundred,
                      tb: toRounded
                    };
                    var keys = Object.keys(data || {}).sort();
                    for (var _iterator2 = _createForOfIteratorHelperLoose(keys), _step2; !(_step2 = _iterator2()).done; ) {
                      var key = _step2.value;
                      var value = data[key];
                      if (!isValid(value)) {
                        continue;
                      }
                      if (key === "v" && value === 1) {
                        continue;
                      }
                      if (key == "pr" && value === 1) {
                        continue;
                      }
                      var formatter = formatters[key];
                      if (formatter) {
                        value = formatter(value);
                      }
                      var type = typeof value;
                      var result = void 0;
                      if (key === "ot" || key === "sf" || key === "st") {
                        result = key + "=" + value;
                      } else if (type === "boolean") {
                        result = key;
                      } else if (type === "number") {
                        result = key + "=" + value;
                      } else {
                        result = key + "=" + JSON.stringify(value);
                      }
                      results.push(result);
                    }
                    return results.join(",");
                  };
                  CMCDController2.toHeaders = function toHeaders(data) {
                    var keys = Object.keys(data);
                    var headers = {};
                    var headerNames = ["Object", "Request", "Session", "Status"];
                    var headerGroups = [{}, {}, {}, {}];
                    var headerMap = {
                      br: 0,
                      d: 0,
                      ot: 0,
                      tb: 0,
                      bl: 1,
                      dl: 1,
                      mtp: 1,
                      nor: 1,
                      nrr: 1,
                      su: 1,
                      cid: 2,
                      pr: 2,
                      sf: 2,
                      sid: 2,
                      st: 2,
                      v: 2,
                      bs: 3,
                      rtp: 3
                    };
                    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
                      var key = _keys[_i];
                      var index = headerMap[key] != null ? headerMap[key] : 1;
                      headerGroups[index][key] = data[key];
                    }
                    for (var i = 0; i < headerGroups.length; i++) {
                      var value = CMCDController2.serialize(headerGroups[i]);
                      if (value) {
                        headers["CMCD-" + headerNames[i]] = value;
                      }
                    }
                    return headers;
                  };
                  CMCDController2.toQuery = function toQuery(data) {
                    return "CMCD=" + encodeURIComponent(CMCDController2.serialize(data));
                  };
                  CMCDController2.appendQueryToUri = function appendQueryToUri(uri, query) {
                    if (!query) {
                      return uri;
                    }
                    var separator = uri.includes("?") ? "&" : "?";
                    return "" + uri + separator + query;
                  };
                  return CMCDController2;
                }();
              }
            ),
            /***/
            "./src/controller/eme-controller.ts": (
              /*!******************************************!*\
                !*** ./src/controller/eme-controller.ts ***!
                \******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/mediakeys-helper */
                  "./src/utils/mediakeys-helper.ts"
                );
                var _utils_keysystem_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/keysystem-util */
                  "./src/utils/keysystem-util.ts"
                );
                var _utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/numeric-encoding-utils */
                  "./src/utils/numeric-encoding-utils.ts"
                );
                var _loader_level_key__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../loader/level-key */
                  "./src/loader/level-key.ts"
                );
                var _utils_hex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../utils/hex */
                  "./src/utils/hex.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! eventemitter3 */
                  "./node_modules/eventemitter3/index.js"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_9___default = __webpack_require__2.n(eventemitter3__WEBPACK_IMPORTED_MODULE_9__);
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
                  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                    if (Class2 === null || !_isNativeFunction(Class2))
                      return Class2;
                    if (typeof Class2 !== "function") {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    if (typeof _cache !== "undefined") {
                      if (_cache.has(Class2))
                        return _cache.get(Class2);
                      _cache.set(Class2, Wrapper);
                    }
                    function Wrapper() {
                      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                    return _setPrototypeOf(Wrapper, Class2);
                  };
                  return _wrapNativeSuper(Class);
                }
                function _construct(Parent, args, Class) {
                  if (_isNativeReflectConstruct()) {
                    _construct = Reflect.construct.bind();
                  } else {
                    _construct = function _construct2(Parent2, args2, Class2) {
                      var a = [null];
                      a.push.apply(a, args2);
                      var Constructor = Function.bind.apply(Parent2, a);
                      var instance = new Constructor();
                      if (Class2)
                        _setPrototypeOf(instance, Class2.prototype);
                      return instance;
                    };
                  }
                  return _construct.apply(null, arguments);
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                function _isNativeFunction(fn) {
                  return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                var MAX_LICENSE_REQUEST_FAILURES = 3;
                var LOGGER_PREFIX = "[eme]";
                var EMEController = function() {
                  function EMEController2(hls) {
                    this.hls = void 0;
                    this.config = void 0;
                    this.media = null;
                    this.keyFormatPromise = null;
                    this.keySystemAccessPromises = {};
                    this._requestLicenseFailureCount = 0;
                    this.mediaKeySessions = [];
                    this.keyIdToKeySessionPromise = {};
                    this.setMediaKeysQueue = EMEController2.CDMCleanupPromise ? [EMEController2.CDMCleanupPromise] : [];
                    this.onMediaEncrypted = this._onMediaEncrypted.bind(this);
                    this.onWaitingForKey = this._onWaitingForKey.bind(this);
                    this.debug = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.debug.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);
                    this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);
                    this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);
                    this.error = _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.error.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger, LOGGER_PREFIX);
                    this.hls = hls;
                    this.config = hls.config;
                    this.registerListeners();
                  }
                  var _proto = EMEController2.prototype;
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.onMediaDetached();
                    this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;
                  };
                  _proto.registerListeners = function registerListeners() {
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHED, this.onMediaDetached, this);
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);
                  };
                  _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
                    var _this$config = this.config, drmSystems = _this$config.drmSystems, widevineLicenseUrl = _this$config.widevineLicenseUrl;
                    var keySystemConfiguration = drmSystems[keySystem];
                    if (keySystemConfiguration) {
                      return keySystemConfiguration.licenseUrl;
                    }
                    if (keySystem === _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.WIDEVINE && widevineLicenseUrl) {
                      return widevineLicenseUrl;
                    }
                    throw new Error('no license server URL configured for key-system "' + keySystem + '"');
                  };
                  _proto.getServerCertificateUrl = function getServerCertificateUrl(keySystem) {
                    var drmSystems = this.config.drmSystems;
                    var keySystemConfiguration = drmSystems[keySystem];
                    if (keySystemConfiguration) {
                      return keySystemConfiguration.serverCertificateUrl;
                    } else {
                      this.log('No Server Certificate in config.drmSystems["' + keySystem + '"]');
                    }
                  };
                  _proto.attemptKeySystemAccess = function attemptKeySystemAccess(keySystemsToAttempt) {
                    var _this = this;
                    var levels = this.hls.levels;
                    var uniqueCodec = function uniqueCodec2(value, i, a) {
                      return !!value && a.indexOf(value) === i;
                    };
                    var audioCodecs = levels.map(function(level) {
                      return level.audioCodec;
                    }).filter(uniqueCodec);
                    var videoCodecs = levels.map(function(level) {
                      return level.videoCodec;
                    }).filter(uniqueCodec);
                    if (audioCodecs.length + videoCodecs.length === 0) {
                      videoCodecs.push("avc1.42e01e");
                    }
                    return new Promise(function(resolve, reject) {
                      var attempt = function attempt2(keySystems) {
                        var keySystem = keySystems.shift();
                        _this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(function(mediaKeys) {
                          return resolve({
                            keySystem,
                            mediaKeys
                          });
                        }).catch(function(error) {
                          if (keySystems.length) {
                            attempt2(keySystems);
                          } else if (error instanceof EMEKeyError) {
                            reject(error);
                          } else {
                            reject(new EMEKeyError({
                              type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                              details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                              error,
                              fatal: true
                            }, error.message));
                          }
                        });
                      };
                      attempt(keySystemsToAttempt);
                    });
                  };
                  _proto.requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
                    var requestMediaKeySystemAccessFunc = this.config.requestMediaKeySystemAccessFunc;
                    if (!(typeof requestMediaKeySystemAccessFunc === "function")) {
                      var errMessage = "Configured requestMediaKeySystemAccess is not a function " + requestMediaKeySystemAccessFunc;
                      if (_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.requestMediaKeySystemAccess === null && self.location.protocol === "http:") {
                        errMessage = "navigator.requestMediaKeySystemAccess is not available over insecure protocol " + location.protocol;
                      }
                      return Promise.reject(new Error(errMessage));
                    }
                    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
                  };
                  _proto.getMediaKeysPromise = function getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
                    var _this2 = this;
                    var mediaKeySystemConfigs = (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getSupportedMediaKeySystemConfigurations)(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);
                    var keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
                    var keySystemAccess = keySystemAccessPromises === null || keySystemAccessPromises === void 0 ? void 0 : keySystemAccessPromises.keySystemAccess;
                    if (!keySystemAccess) {
                      this.log('Requesting encrypted media "' + keySystem + '" key-system access with config: ' + JSON.stringify(mediaKeySystemConfigs));
                      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
                      var _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
                        keySystemAccess
                      };
                      keySystemAccess.catch(function(error) {
                        _this2.log('Failed to obtain access to key-system "' + keySystem + '": ' + error);
                      });
                      return keySystemAccess.then(function(mediaKeySystemAccess) {
                        _this2.log('Access for key-system "' + mediaKeySystemAccess.keySystem + '" obtained');
                        var certificateRequest = _this2.fetchServerCertificate(keySystem);
                        _this2.log('Create media-keys for "' + keySystem + '"');
                        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(function(mediaKeys) {
                          _this2.log('Media-keys created for "' + keySystem + '"');
                          return certificateRequest.then(function(certificate) {
                            if (certificate) {
                              return _this2.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);
                            }
                            return mediaKeys;
                          });
                        });
                        _keySystemAccessPromises.mediaKeys.catch(function(error) {
                          _this2.error('Failed to create media-keys for "' + keySystem + '"}: ' + error);
                        });
                        return _keySystemAccessPromises.mediaKeys;
                      });
                    }
                    return keySystemAccess.then(function() {
                      return keySystemAccessPromises.mediaKeys;
                    });
                  };
                  _proto.createMediaKeySessionContext = function createMediaKeySessionContext(_ref) {
                    var decryptdata = _ref.decryptdata, keySystem = _ref.keySystem, mediaKeys = _ref.mediaKeys;
                    console.assert(!!mediaKeys, "mediaKeys is defined");
                    this.log('Creating key-system session "' + keySystem + '" keyId: ' + _utils_hex__WEBPACK_IMPORTED_MODULE_7__["default"].hexDump(decryptdata.keyId || []));
                    var mediaKeysSession = mediaKeys.createSession();
                    var mediaKeySessionContext = {
                      decryptdata,
                      keySystem,
                      mediaKeys,
                      mediaKeysSession,
                      keyStatus: "status-pending"
                    };
                    this.mediaKeySessions.push(mediaKeySessionContext);
                    return mediaKeySessionContext;
                  };
                  _proto.renewKeySession = function renewKeySession(mediaKeySessionContext) {
                    var decryptdata = mediaKeySessionContext.decryptdata;
                    if (decryptdata.pssh) {
                      var keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
                      var _keyId = this.getKeyIdString(decryptdata);
                      var scheme = "cenc";
                      this.keyIdToKeySessionPromise[_keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "expired");
                    } else {
                      this.warn("Could not renew expired session. Missing pssh initData.");
                    }
                    this.removeSession(mediaKeySessionContext);
                  };
                  _proto.getKeyIdString = function getKeyIdString(decryptdata) {
                    if (!decryptdata) {
                      throw new Error("Could not read keyId of undefined decryptdata");
                    }
                    if (decryptdata.keyId === null) {
                      throw new Error("keyId is null");
                    }
                    return _utils_hex__WEBPACK_IMPORTED_MODULE_7__["default"].hexDump(decryptdata.keyId);
                  };
                  _proto.updateKeySession = function updateKeySession(mediaKeySessionContext, data) {
                    var _mediaKeySessionConte;
                    var keySession = mediaKeySessionContext.mediaKeysSession;
                    this.log('Updating key-session "' + keySession.sessionId + '" for keyID ' + _utils_hex__WEBPACK_IMPORTED_MODULE_7__["default"].hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) === null || _mediaKeySessionConte === void 0 ? void 0 : _mediaKeySessionConte.keyId) || []) + "\n      } (data length: " + (data ? data.byteLength : data) + ")");
                    return keySession.update(data);
                  };
                  _proto.selectKeySystemFormat = function selectKeySystemFormat(frag) {
                    var keyFormats = Object.keys(frag.levelkeys || {});
                    if (!this.keyFormatPromise) {
                      this.log("Selecting key-system from fragment (sn: " + frag.sn + " " + frag.type + ": " + frag.level + ") key formats " + keyFormats.join(", "));
                      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
                    }
                    return this.keyFormatPromise;
                  };
                  _proto.getKeyFormatPromise = function getKeyFormatPromise(keyFormats) {
                    var _this3 = this;
                    return new Promise(function(resolve, reject) {
                      var keySystemsInConfig = (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getKeySystemsForConfig)(_this3.config);
                      var keySystemsToAttempt = keyFormats.map(_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemFormatToKeySystemDomain).filter(function(value) {
                        return !!value && keySystemsInConfig.indexOf(value) !== -1;
                      });
                      return _this3.getKeySystemSelectionPromise(keySystemsToAttempt).then(function(_ref2) {
                        var keySystem = _ref2.keySystem;
                        var keySystemFormat = (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemDomainToKeySystemFormat)(keySystem);
                        if (keySystemFormat) {
                          resolve(keySystemFormat);
                        } else {
                          reject(new Error('Unable to find format for key-system "' + keySystem + '"'));
                        }
                      }).catch(reject);
                    });
                  };
                  _proto.loadKey = function loadKey(data) {
                    var _this4 = this;
                    var decryptdata = data.keyInfo.decryptdata;
                    var keyId = this.getKeyIdString(decryptdata);
                    var keyDetails = "(keyId: " + keyId + ' format: "' + decryptdata.keyFormat + '" method: ' + decryptdata.method + " uri: " + decryptdata.uri + ")";
                    this.log("Starting session for key " + keyDetails);
                    var keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];
                    if (!keySessionContextPromise) {
                      keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(function(_ref3) {
                        var keySystem = _ref3.keySystem, mediaKeys = _ref3.mediaKeys;
                        _this4.throwIfDestroyed();
                        _this4.log("Handle encrypted media sn: " + data.frag.sn + " " + data.frag.type + ": " + data.frag.level + " using key " + keyDetails);
                        return _this4.attemptSetMediaKeys(keySystem, mediaKeys).then(function() {
                          _this4.throwIfDestroyed();
                          var keySessionContext = _this4.createMediaKeySessionContext({
                            keySystem,
                            mediaKeys,
                            decryptdata
                          });
                          var scheme = "cenc";
                          return _this4.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "playlist-key");
                        });
                      });
                      keySessionContextPromise.catch(function(error) {
                        return _this4.handleError(error);
                      });
                    }
                    return keySessionContextPromise;
                  };
                  _proto.throwIfDestroyed = function throwIfDestroyed(message) {
                    if (message === void 0) {
                      message = "Invalid state";
                    }
                    if (!this.hls) {
                      throw new Error("invalid state");
                    }
                  };
                  _proto.handleError = function handleError(error) {
                    if (!this.hls) {
                      return;
                    }
                    this.error(error.message);
                    if (error instanceof EMEKeyError) {
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, error.data);
                    } else {
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_KEYS,
                        error,
                        fatal: true
                      });
                    }
                  };
                  _proto.getKeySystemForKeyPromise = function getKeySystemForKeyPromise(decryptdata) {
                    var keyId = this.getKeyIdString(decryptdata);
                    var mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
                    if (!mediaKeySessionContext) {
                      var keySystem = (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemFormatToKeySystemDomain)(decryptdata.keyFormat);
                      var keySystemsToAttempt = keySystem ? [keySystem] : (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getKeySystemsForConfig)(this.config);
                      return this.attemptKeySystemAccess(keySystemsToAttempt);
                    }
                    return mediaKeySessionContext;
                  };
                  _proto.getKeySystemSelectionPromise = function getKeySystemSelectionPromise(keySystemsToAttempt) {
                    if (!keySystemsToAttempt.length) {
                      keySystemsToAttempt = (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.getKeySystemsForConfig)(this.config);
                    }
                    if (keySystemsToAttempt.length === 0) {
                      throw new EMEKeyError({
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                        fatal: true
                      }, "Missing key-system license configuration options " + JSON.stringify({
                        drmSystems: this.config.drmSystems
                      }));
                    }
                    return this.attemptKeySystemAccess(keySystemsToAttempt);
                  };
                  _proto._onMediaEncrypted = function _onMediaEncrypted(event) {
                    var _this5 = this;
                    var initDataType = event.initDataType, initData = event.initData;
                    this.debug('"' + event.type + '" event: init data type: "' + initDataType + '"');
                    if (initData === null) {
                      return;
                    }
                    var keyId;
                    var keySystemDomain;
                    if (initDataType === "sinf" && this.config.drmSystems[_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.FAIRPLAY]) {
                      var json = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.bin2str)(new Uint8Array(initData));
                      try {
                        var sinf = (0, _utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_5__.base64Decode)(JSON.parse(json).sinf);
                        var tenc = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.parseSinf)(new Uint8Array(sinf));
                        if (!tenc) {
                          return;
                        }
                        keyId = tenc.subarray(8, 24);
                        keySystemDomain = _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.FAIRPLAY;
                      } catch (error) {
                        this.warn('Failed to parse sinf "encrypted" event message initData');
                        return;
                      }
                    } else {
                      var psshInfo = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__.parsePssh)(initData);
                      if (psshInfo === null) {
                        return;
                      }
                      if (psshInfo.version === 0 && psshInfo.systemId === _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystemIds.WIDEVINE && psshInfo.data) {
                        keyId = psshInfo.data.subarray(8, 24);
                      }
                      keySystemDomain = (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemIdToKeySystemDomain)(psshInfo.systemId);
                    }
                    if (!keySystemDomain || !keyId) {
                      return;
                    }
                    var keyIdHex = _utils_hex__WEBPACK_IMPORTED_MODULE_7__["default"].hexDump(keyId);
                    var keyIdToKeySessionPromise = this.keyIdToKeySessionPromise, mediaKeySessions = this.mediaKeySessions;
                    var keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
                    var _loop = function _loop2(i2) {
                      var keyContext = mediaKeySessions[i2];
                      var decryptdata = keyContext.decryptdata;
                      if (decryptdata.pssh || !decryptdata.keyId) {
                        return "continue";
                      }
                      var oldKeyIdHex = _utils_hex__WEBPACK_IMPORTED_MODULE_7__["default"].hexDump(decryptdata.keyId);
                      if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, "").indexOf(keyIdHex) !== -1) {
                        keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
                        delete keyIdToKeySessionPromise[oldKeyIdHex];
                        decryptdata.pssh = new Uint8Array(initData);
                        decryptdata.keyId = keyId;
                        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(function() {
                          return _this5.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, "encrypted-event-key-match");
                        });
                        return "break";
                      }
                    };
                    for (var i = 0; i < mediaKeySessions.length; i++) {
                      var _ret = _loop(i);
                      if (_ret === "continue")
                        continue;
                      if (_ret === "break")
                        break;
                    }
                    if (!keySessionContextPromise) {
                      keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(function(_ref4) {
                        var _keySystemToKeySystem;
                        var keySystem = _ref4.keySystem, mediaKeys = _ref4.mediaKeys;
                        _this5.throwIfDestroyed();
                        var decryptdata = new _loader_level_key__WEBPACK_IMPORTED_MODULE_6__.LevelKey("ISO-23001-7", keyIdHex, (_keySystemToKeySystem = (0, _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.keySystemDomainToKeySystemFormat)(keySystem)) != null ? _keySystemToKeySystem : "");
                        decryptdata.pssh = new Uint8Array(initData);
                        decryptdata.keyId = keyId;
                        return _this5.attemptSetMediaKeys(keySystem, mediaKeys).then(function() {
                          _this5.throwIfDestroyed();
                          var keySessionContext = _this5.createMediaKeySessionContext({
                            decryptdata,
                            keySystem,
                            mediaKeys
                          });
                          return _this5.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, "encrypted-event-no-match");
                        });
                      });
                    }
                    keySessionContextPromise.catch(function(error) {
                      return _this5.handleError(error);
                    });
                  };
                  _proto._onWaitingForKey = function _onWaitingForKey(event) {
                    this.log('"' + event.type + '" event');
                  };
                  _proto.attemptSetMediaKeys = function attemptSetMediaKeys(keySystem, mediaKeys) {
                    var _this6 = this;
                    var queue = this.setMediaKeysQueue.slice();
                    this.log('Setting media-keys for "' + keySystem + '"');
                    var setMediaKeysPromise = Promise.all(queue).then(function() {
                      if (!_this6.media) {
                        throw new Error("Attempted to set mediaKeys without media element attached");
                      }
                      return _this6.media.setMediaKeys(mediaKeys);
                    });
                    this.setMediaKeysQueue.push(setMediaKeysPromise);
                    return setMediaKeysPromise.then(function() {
                      _this6.log('Media-keys set for "' + keySystem + '"');
                      queue.push(setMediaKeysPromise);
                      _this6.setMediaKeysQueue = _this6.setMediaKeysQueue.filter(function(p) {
                        return queue.indexOf(p) === -1;
                      });
                    });
                  };
                  _proto.generateRequestWithPreferredKeySession = function generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {
                    var _this$config$drmSyste, _this$config$drmSyste2, _this7 = this;
                    var generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) === null || _this$config$drmSyste === void 0 ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) === null || _this$config$drmSyste2 === void 0 ? void 0 : _this$config$drmSyste2.generateRequest;
                    if (generateRequestFilter) {
                      try {
                        var mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);
                        if (!mappedInitData) {
                          throw new Error("Invalid response from configured generateRequest filter");
                        }
                        initDataType = mappedInitData.initDataType;
                        initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;
                      } catch (error) {
                        var _this$hls;
                        this.warn(error.message);
                        if ((_this$hls = this.hls) !== null && _this$hls !== void 0 && _this$hls.config.debug) {
                          throw error;
                        }
                      }
                    }
                    if (initData === null) {
                      this.log('Skipping key-session request for "' + reason + '" (no initData)');
                      return Promise.resolve(context);
                    }
                    var keyId = this.getKeyIdString(context.decryptdata);
                    this.log('Generating key-session request for "' + reason + '": ' + keyId + " (init data type: " + initDataType + " length: " + (initData ? initData.byteLength : null) + ")");
                    var licenseStatus = new (eventemitter3__WEBPACK_IMPORTED_MODULE_9___default())();
                    context.mediaKeysSession.onmessage = function(event) {
                      var keySession = context.mediaKeysSession;
                      if (!keySession) {
                        licenseStatus.emit("error", new Error("invalid state"));
                        return;
                      }
                      var messageType = event.messageType, message = event.message;
                      _this7.log('"' + messageType + '" message event for session "' + keySession.sessionId + '" message size: ' + message.byteLength);
                      if (messageType === "license-request" || messageType === "license-renewal") {
                        _this7.renewLicense(context, message).catch(function(error) {
                          _this7.handleError(error);
                          licenseStatus.emit("error", error);
                        });
                      } else if (messageType === "license-release") {
                        if (context.keySystem === _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__.KeySystems.FAIRPLAY) {
                          _this7.updateKeySession(context, (0, _utils_keysystem_util__WEBPACK_IMPORTED_MODULE_4__.strToUtf8array)("acknowledged"));
                          _this7.removeSession(context);
                        }
                      } else {
                        _this7.warn('unhandled media key message type "' + messageType + '"');
                      }
                    };
                    context.mediaKeysSession.onkeystatuseschange = function(event) {
                      var keySession = context.mediaKeysSession;
                      if (!keySession) {
                        licenseStatus.emit("error", new Error("invalid state"));
                        return;
                      }
                      _this7.onKeyStatusChange(context);
                      var keyStatus = context.keyStatus;
                      licenseStatus.emit("keyStatus", keyStatus);
                      if (keyStatus === "expired") {
                        _this7.warn(context.keySystem + " expired for key " + keyId);
                        _this7.renewKeySession(context);
                      }
                    };
                    var keyUsablePromise = new Promise(function(resolve, reject) {
                      licenseStatus.on("error", reject);
                      licenseStatus.on("keyStatus", function(keyStatus) {
                        if (keyStatus.startsWith("usable")) {
                          resolve();
                        } else if (keyStatus === "output-restricted") {
                          reject(new EMEKeyError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                            fatal: false
                          }, "HDCP level output restricted"));
                        } else if (keyStatus === "internal-error") {
                          reject(new EMEKeyError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                            fatal: true
                          }, 'key status changed to "' + keyStatus + '"'));
                        } else if (keyStatus === "expired") {
                          reject(new Error("key expired while generating request"));
                        } else {
                          _this7.warn('unhandled key status change "' + keyStatus + '"');
                        }
                      });
                    });
                    return context.mediaKeysSession.generateRequest(initDataType, initData).then(function() {
                      var _context$mediaKeysSes;
                      _this7.log('Request generated for key-session "' + ((_context$mediaKeysSes = context.mediaKeysSession) === null || _context$mediaKeysSes === void 0 ? void 0 : _context$mediaKeysSes.sessionId) + '" keyId: ' + keyId);
                    }).catch(function(error) {
                      throw new EMEKeyError({
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                        error,
                        fatal: false
                      }, "Error generating key-session request: " + error);
                    }).then(function() {
                      return keyUsablePromise;
                    }).catch(function(error) {
                      licenseStatus.removeAllListeners();
                      _this7.removeSession(context);
                      throw error;
                    }).then(function() {
                      licenseStatus.removeAllListeners();
                      return context;
                    });
                  };
                  _proto.onKeyStatusChange = function onKeyStatusChange(mediaKeySessionContext) {
                    var _this8 = this;
                    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach(function(status, keyId) {
                      _this8.log('key status change "' + status + '" for keyStatuses keyId: ' + _utils_hex__WEBPACK_IMPORTED_MODULE_7__["default"].hexDump("buffer" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId)) + " session keyId: " + _utils_hex__WEBPACK_IMPORTED_MODULE_7__["default"].hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || [])) + " uri: " + mediaKeySessionContext.decryptdata.uri);
                      mediaKeySessionContext.keyStatus = status;
                    });
                  };
                  _proto.fetchServerCertificate = function fetchServerCertificate(keySystem) {
                    var _this9 = this;
                    return new Promise(function(resolve, reject) {
                      var url = _this9.getServerCertificateUrl(keySystem);
                      if (!url) {
                        return resolve();
                      }
                      _this9.log('Fetching serverCertificate for "' + keySystem + '"');
                      var xhr = new XMLHttpRequest();
                      xhr.open("GET", url, true);
                      xhr.responseType = "arraybuffer";
                      xhr.onreadystatechange = function() {
                        if (xhr.readyState === XMLHttpRequest.DONE) {
                          if (xhr.status === 200) {
                            resolve(xhr.response);
                          } else {
                            reject(new EMEKeyError({
                              type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                              details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                              fatal: true,
                              networkDetails: xhr
                            }, '"' + keySystem + '" certificate request XHR failed (' + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")"));
                          }
                        }
                      };
                      xhr.send();
                    });
                  };
                  _proto.setMediaKeysServerCertificate = function setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
                    var _this10 = this;
                    return new Promise(function(resolve, reject) {
                      mediaKeys.setServerCertificate(cert).then(function(success) {
                        _this10.log("setServerCertificate " + (success ? "success" : "not supported by CDM") + " (" + (cert === null || cert === void 0 ? void 0 : cert.byteLength) + ') on "' + keySystem + '"');
                        resolve(mediaKeys);
                      }).catch(function(error) {
                        reject(new EMEKeyError({
                          type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                          details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                          error,
                          fatal: true
                        }, error.message));
                      });
                    });
                  };
                  _proto.renewLicense = function renewLicense(context, keyMessage) {
                    var _this11 = this;
                    return this.requestLicense(context, new Uint8Array(keyMessage)).then(function(data) {
                      return _this11.updateKeySession(context, new Uint8Array(data)).catch(function(error) {
                        throw new EMEKeyError({
                          type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                          details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                          error,
                          fatal: true
                        }, error.message);
                      });
                    });
                  };
                  _proto.setupLicenseXHR = function setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {
                    var _this12 = this;
                    var licenseXhrSetup = this.config.licenseXhrSetup;
                    if (!licenseXhrSetup) {
                      xhr.open("POST", url, true);
                      return Promise.resolve({
                        xhr,
                        licenseChallenge
                      });
                    }
                    return Promise.resolve().then(function() {
                      if (!keysListItem.decryptdata) {
                        throw new Error("Key removed");
                      }
                      return licenseXhrSetup.call(_this12.hls, xhr, url, keysListItem, licenseChallenge);
                    }).catch(function(error) {
                      if (!keysListItem.decryptdata) {
                        throw error;
                      }
                      xhr.open("POST", url, true);
                      return licenseXhrSetup.call(_this12.hls, xhr, url, keysListItem, licenseChallenge);
                    }).then(function(licenseXhrSetupResult) {
                      if (!xhr.readyState) {
                        xhr.open("POST", url, true);
                      }
                      var finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
                      return {
                        xhr,
                        licenseChallenge: finalLicenseChallenge
                      };
                    });
                  };
                  _proto.requestLicense = function requestLicense(keySessionContext, licenseChallenge) {
                    var _this13 = this;
                    return new Promise(function(resolve, reject) {
                      var url = _this13.getLicenseServerUrl(keySessionContext.keySystem);
                      _this13.log("Sending license request to URL: " + url);
                      var xhr = new XMLHttpRequest();
                      xhr.responseType = "arraybuffer";
                      xhr.onreadystatechange = function() {
                        if (!_this13.hls || !keySessionContext.mediaKeysSession) {
                          return reject(new Error("invalid state"));
                        }
                        if (xhr.readyState === 4) {
                          if (xhr.status === 200) {
                            _this13._requestLicenseFailureCount = 0;
                            var data = xhr.response;
                            _this13.log("License received " + (data instanceof ArrayBuffer ? data.byteLength : data));
                            var licenseResponseCallback = _this13.config.licenseResponseCallback;
                            if (licenseResponseCallback) {
                              try {
                                data = licenseResponseCallback.call(_this13.hls, xhr, url, keySessionContext);
                              } catch (error) {
                                _this13.error(error);
                              }
                            }
                            resolve(data);
                          } else {
                            _this13._requestLicenseFailureCount++;
                            if (_this13._requestLicenseFailureCount > MAX_LICENSE_REQUEST_FAILURES || xhr.status >= 400 && xhr.status < 500) {
                              reject(new EMEKeyError({
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.KEY_SYSTEM_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                fatal: true,
                                networkDetails: xhr
                              }, "License Request XHR failed (" + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")"));
                            } else {
                              var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - _this13._requestLicenseFailureCount + 1;
                              _this13.warn("Retrying license request, " + attemptsLeft + " attempts left");
                              _this13.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
                            }
                          }
                        }
                      };
                      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
                        keySessionContext.licenseXhr.abort();
                      }
                      keySessionContext.licenseXhr = xhr;
                      _this13.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(function(_ref5) {
                        var xhr2 = _ref5.xhr, licenseChallenge2 = _ref5.licenseChallenge;
                        xhr2.send(licenseChallenge2);
                      });
                    });
                  };
                  _proto.onMediaAttached = function onMediaAttached(event, data) {
                    if (!this.config.emeEnabled) {
                      return;
                    }
                    var media = data.media;
                    this.media = media;
                    media.addEventListener("encrypted", this.onMediaEncrypted);
                    media.addEventListener("waitingforkey", this.onWaitingForKey);
                  };
                  _proto.onMediaDetached = function onMediaDetached() {
                    var _this14 = this;
                    var media = this.media;
                    var mediaKeysList = this.mediaKeySessions;
                    if (media) {
                      media.removeEventListener("encrypted", this.onMediaEncrypted);
                      media.removeEventListener("waitingforkey", this.onWaitingForKey);
                      this.media = null;
                    }
                    this._requestLicenseFailureCount = 0;
                    this.setMediaKeysQueue = [];
                    this.mediaKeySessions = [];
                    this.keyIdToKeySessionPromise = {};
                    _loader_level_key__WEBPACK_IMPORTED_MODULE_6__.LevelKey.clearKeyUriToKeyIdMap();
                    var keySessionCount = mediaKeysList.length;
                    EMEController2.CDMCleanupPromise = Promise.all(mediaKeysList.map(function(mediaKeySessionContext) {
                      return _this14.removeSession(mediaKeySessionContext);
                    }).concat(media === null || media === void 0 ? void 0 : media.setMediaKeys(null).catch(function(error) {
                      _this14.log("Could not clear media keys: " + error + ". media.src: " + (media === null || media === void 0 ? void 0 : media.src));
                    }))).then(function() {
                      if (keySessionCount) {
                        _this14.log("finished closing key sessions and clearing media keys");
                        mediaKeysList.length = 0;
                      }
                    }).catch(function(error) {
                      _this14.log("Could not close sessions and clear media keys: " + error + ". media.src: " + (media === null || media === void 0 ? void 0 : media.src));
                    });
                  };
                  _proto.onManifestLoaded = function onManifestLoaded(event, _ref6) {
                    var sessionKeys = _ref6.sessionKeys;
                    if (!sessionKeys || !this.config.emeEnabled) {
                      return;
                    }
                    if (!this.keyFormatPromise) {
                      var keyFormats = sessionKeys.reduce(function(formats, sessionKey) {
                        if (formats.indexOf(sessionKey.keyFormat) === -1) {
                          formats.push(sessionKey.keyFormat);
                        }
                        return formats;
                      }, []);
                      this.log("Selecting key-system from session-keys " + keyFormats.join(", "));
                      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
                    }
                  };
                  _proto.removeSession = function removeSession(mediaKeySessionContext) {
                    var _this15 = this;
                    var mediaKeysSession = mediaKeySessionContext.mediaKeysSession, licenseXhr = mediaKeySessionContext.licenseXhr;
                    if (mediaKeysSession) {
                      this.log("Remove licenses and keys and close session " + mediaKeysSession.sessionId);
                      mediaKeysSession.onmessage = null;
                      mediaKeysSession.onkeystatuseschange = null;
                      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
                        licenseXhr.abort();
                      }
                      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = void 0;
                      var index = this.mediaKeySessions.indexOf(mediaKeySessionContext);
                      if (index > -1) {
                        this.mediaKeySessions.splice(index, 1);
                      }
                      return mediaKeysSession.remove().catch(function(error) {
                        _this15.log("Could not remove session: " + error);
                      }).then(function() {
                        return mediaKeysSession.close();
                      }).catch(function(error) {
                        _this15.log("Could not close session: " + error);
                      });
                    }
                  };
                  return EMEController2;
                }();
                EMEController.CDMCleanupPromise = void 0;
                var EMEKeyError = function(_Error) {
                  _inheritsLoose(EMEKeyError2, _Error);
                  function EMEKeyError2(data, message) {
                    var _this16;
                    _this16 = _Error.call(this, message) || this;
                    _this16.data = void 0;
                    _this16.data = data;
                    data.err = data.error;
                    return _this16;
                  }
                  return EMEKeyError2;
                }(_wrapNativeSuper(Error));
                const __WEBPACK_DEFAULT_EXPORT__ = EMEController;
              }
            ),
            /***/
            "./src/controller/fps-controller.ts": (
              /*!******************************************!*\
                !*** ./src/controller/fps-controller.ts ***!
                \******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var FPSController = function() {
                  function FPSController2(hls) {
                    this.hls = void 0;
                    this.isVideoPlaybackQualityAvailable = false;
                    this.timer = void 0;
                    this.media = null;
                    this.lastTime = void 0;
                    this.lastDroppedFrames = 0;
                    this.lastDecodedFrames = 0;
                    this.streamController = void 0;
                    this.hls = hls;
                    this.registerListeners();
                  }
                  var _proto = FPSController2.prototype;
                  _proto.setStreamController = function setStreamController(streamController) {
                    this.streamController = streamController;
                  };
                  _proto.registerListeners = function registerListeners() {
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHING, this.onMediaAttaching);
                  };
                  _proto.destroy = function destroy() {
                    if (this.timer) {
                      clearInterval(this.timer);
                    }
                    this.unregisterListeners();
                    this.isVideoPlaybackQualityAvailable = false;
                    this.media = null;
                  };
                  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                    var config = this.hls.config;
                    if (config.capLevelOnFPSDrop) {
                      var media = data.media instanceof self.HTMLVideoElement ? data.media : null;
                      this.media = media;
                      if (media && typeof media.getVideoPlaybackQuality === "function") {
                        this.isVideoPlaybackQualityAvailable = true;
                      }
                      self.clearInterval(this.timer);
                      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
                    }
                  };
                  _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
                    var currentTime = performance.now();
                    if (decodedFrames) {
                      if (this.lastTime) {
                        var currentPeriod = currentTime - this.lastTime;
                        var currentDropped = droppedFrames - this.lastDroppedFrames;
                        var currentDecoded = decodedFrames - this.lastDecodedFrames;
                        var droppedFPS = 1e3 * currentDropped / currentPeriod;
                        var hls = this.hls;
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP, {
                          currentDropped,
                          currentDecoded,
                          totalDroppedFrames: droppedFrames
                        });
                        if (droppedFPS > 0) {
                          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                            var currentLevel = hls.currentLevel;
                            _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
                            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                              currentLevel = currentLevel - 1;
                              hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FPS_DROP_LEVEL_CAPPING, {
                                level: currentLevel,
                                droppedLevel: hls.currentLevel
                              });
                              hls.autoLevelCapping = currentLevel;
                              this.streamController.nextLevelSwitch();
                            }
                          }
                        }
                      }
                      this.lastTime = currentTime;
                      this.lastDroppedFrames = droppedFrames;
                      this.lastDecodedFrames = decodedFrames;
                    }
                  };
                  _proto.checkFPSInterval = function checkFPSInterval() {
                    var video = this.media;
                    if (video) {
                      if (this.isVideoPlaybackQualityAvailable) {
                        var videoPlaybackQuality = video.getVideoPlaybackQuality();
                        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
                      } else {
                        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
                      }
                    }
                  };
                  return FPSController2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = FPSController;
              }
            ),
            /***/
            "./src/controller/fragment-finders.ts": (
              /*!********************************************!*\
                !*** ./src/controller/fragment-finders.ts ***!
                \********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "findFragWithCC": () => (
                    /* binding */
                    findFragWithCC
                  ),
                  /* harmony export */
                  "findFragmentByPDT": () => (
                    /* binding */
                    findFragmentByPDT
                  ),
                  /* harmony export */
                  "findFragmentByPTS": () => (
                    /* binding */
                    findFragmentByPTS
                  ),
                  /* harmony export */
                  "fragmentWithinToleranceTest": () => (
                    /* binding */
                    fragmentWithinToleranceTest
                  ),
                  /* harmony export */
                  "pdtWithinToleranceTest": () => (
                    /* binding */
                    pdtWithinToleranceTest
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/binary-search */
                  "./src/utils/binary-search.ts"
                );
                function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
                  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(PDTValue)) {
                    return null;
                  }
                  var startPDT = fragments[0].programDateTime;
                  if (PDTValue < (startPDT || 0)) {
                    return null;
                  }
                  var endPDT = fragments[fragments.length - 1].endProgramDateTime;
                  if (PDTValue >= (endPDT || 0)) {
                    return null;
                  }
                  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
                  for (var seg = 0; seg < fragments.length; ++seg) {
                    var frag = fragments[seg];
                    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
                      return frag;
                    }
                  }
                  return null;
                }
                function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
                  if (bufferEnd === void 0) {
                    bufferEnd = 0;
                  }
                  if (maxFragLookUpTolerance === void 0) {
                    maxFragLookUpTolerance = 0;
                  }
                  var fragNext = null;
                  if (fragPrevious) {
                    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
                  } else if (bufferEnd === 0 && fragments[0].start === 0) {
                    fragNext = fragments[0];
                  }
                  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {
                    return fragNext;
                  }
                  var foundFragment = _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__["default"].search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
                  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
                    return foundFragment;
                  }
                  return fragNext;
                }
                function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
                  if (bufferEnd === void 0) {
                    bufferEnd = 0;
                  }
                  if (maxFragLookUpTolerance === void 0) {
                    maxFragLookUpTolerance = 0;
                  }
                  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
                    return 0;
                  }
                  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
                  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                    return 1;
                  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                    return -1;
                  }
                  return 0;
                }
                function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
                  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
                  var endProgramDateTime = candidate.endProgramDateTime || 0;
                  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
                }
                function findFragWithCC(fragments, cc) {
                  return _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__["default"].search(fragments, function(candidate) {
                    if (candidate.cc < cc) {
                      return 1;
                    } else if (candidate.cc > cc) {
                      return -1;
                    } else {
                      return 0;
                    }
                  });
                }
              }
            ),
            /***/
            "./src/controller/fragment-tracker.ts": (
              /*!********************************************!*\
                !*** ./src/controller/fragment-tracker.ts ***!
                \********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "FragmentState": () => (
                    /* binding */
                    FragmentState
                  ),
                  /* harmony export */
                  "FragmentTracker": () => (
                    /* binding */
                    FragmentTracker
                  )
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var FragmentState;
                (function(FragmentState2) {
                  FragmentState2["NOT_LOADED"] = "NOT_LOADED";
                  FragmentState2["APPENDING"] = "APPENDING";
                  FragmentState2["PARTIAL"] = "PARTIAL";
                  FragmentState2["OK"] = "OK";
                })(FragmentState || (FragmentState = {}));
                var FragmentTracker = function() {
                  function FragmentTracker2(hls) {
                    this.activeFragment = null;
                    this.activeParts = null;
                    this.endListFragments = /* @__PURE__ */ Object.create(null);
                    this.fragments = /* @__PURE__ */ Object.create(null);
                    this.timeRanges = /* @__PURE__ */ Object.create(null);
                    this.bufferPadding = 0.2;
                    this.hls = void 0;
                    this.hls = hls;
                    this._registerListeners();
                  }
                  var _proto = FragmentTracker2.prototype;
                  _proto._registerListeners = function _registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_APPENDED, this.onBufferAppended, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_LOADED, this.onFragLoaded, this);
                  };
                  _proto._unregisterListeners = function _unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_APPENDED, this.onBufferAppended, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_LOADED, this.onFragLoaded, this);
                  };
                  _proto.destroy = function destroy() {
                    this._unregisterListeners();
                    this.fragments = // @ts-ignore
                    this.endListFragments = this.timeRanges = this.activeFragment = this.activeParts = null;
                  };
                  _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {
                    if (levelType === _types_loader__WEBPACK_IMPORTED_MODULE_1__.PlaylistLevelType.MAIN) {
                      var activeFragment = this.activeFragment, activeParts = this.activeParts;
                      if (!activeFragment) {
                        return null;
                      }
                      if (activeParts) {
                        for (var i = activeParts.length; i--; ) {
                          var activePart = activeParts[i];
                          var appendedPTS = activePart ? activePart.end : activeFragment.appendedPTS;
                          if (activePart.start <= position && appendedPTS !== void 0 && position <= appendedPTS) {
                            if (i > 9) {
                              this.activeParts = activeParts.slice(i - 9);
                            }
                            return activePart;
                          }
                        }
                      } else if (activeFragment.start <= position && activeFragment.appendedPTS !== void 0 && position <= activeFragment.appendedPTS) {
                        return activeFragment;
                      }
                    }
                    return this.getBufferedFrag(position, levelType);
                  };
                  _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
                    var fragments = this.fragments;
                    var keys = Object.keys(fragments);
                    for (var i = keys.length; i--; ) {
                      var fragmentEntity = fragments[keys[i]];
                      if ((fragmentEntity === null || fragmentEntity === void 0 ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
                        var frag = fragmentEntity.body;
                        if (frag.start <= position && position <= frag.end) {
                          return frag;
                        }
                      }
                    }
                    return null;
                  };
                  _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType) {
                    var _this = this;
                    if (this.timeRanges) {
                      this.timeRanges[elementaryStream] = timeRange;
                    }
                    Object.keys(this.fragments).forEach(function(key) {
                      var fragmentEntity = _this.fragments[key];
                      if (!fragmentEntity) {
                        return;
                      }
                      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
                        if (fragmentEntity.body.type === playlistType) {
                          _this.removeFragment(fragmentEntity.body);
                        }
                        return;
                      }
                      var esData = fragmentEntity.range[elementaryStream];
                      if (!esData) {
                        return;
                      }
                      esData.time.some(function(time) {
                        var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
                        if (isNotBuffered) {
                          _this.removeFragment(fragmentEntity.body);
                        }
                        return isNotBuffered;
                      });
                    });
                  };
                  _proto.detectPartialFragments = function detectPartialFragments(data) {
                    var _this2 = this;
                    var timeRanges = this.timeRanges;
                    var frag = data.frag, part = data.part;
                    if (!timeRanges || frag.sn === "initSegment") {
                      return;
                    }
                    var fragKey = getFragmentKey(frag);
                    var fragmentEntity = this.fragments[fragKey];
                    if (!fragmentEntity) {
                      return;
                    }
                    Object.keys(timeRanges).forEach(function(elementaryStream) {
                      var streamInfo = frag.elementaryStreams[elementaryStream];
                      if (!streamInfo) {
                        return;
                      }
                      var timeRange = timeRanges[elementaryStream];
                      var partial = part !== null || streamInfo.partial === true;
                      fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);
                    });
                    fragmentEntity.loaded = null;
                    if (Object.keys(fragmentEntity.range).length) {
                      fragmentEntity.buffered = true;
                      if (fragmentEntity.body.endList) {
                        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
                      }
                    } else {
                      this.removeFragment(fragmentEntity.body);
                    }
                  };
                  _proto.fragBuffered = function fragBuffered(frag) {
                    var fragKey = getFragmentKey(frag);
                    var fragmentEntity = this.fragments[fragKey];
                    if (fragmentEntity) {
                      fragmentEntity.loaded = null;
                      fragmentEntity.buffered = true;
                    }
                  };
                  _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {
                    var buffered = {
                      time: [],
                      partial
                    };
                    var startPTS = part ? part.start : fragment.start;
                    var endPTS = part ? part.end : fragment.end;
                    var minEndPTS = fragment.minEndPTS || endPTS;
                    var maxStartPTS = fragment.maxStartPTS || startPTS;
                    for (var i = 0; i < timeRange.length; i++) {
                      var startTime = timeRange.start(i) - this.bufferPadding;
                      var endTime = timeRange.end(i) + this.bufferPadding;
                      if (maxStartPTS >= startTime && minEndPTS <= endTime) {
                        buffered.time.push({
                          startPTS: Math.max(startPTS, timeRange.start(i)),
                          endPTS: Math.min(endPTS, timeRange.end(i))
                        });
                        break;
                      } else if (startPTS < endTime && endPTS > startTime) {
                        buffered.partial = true;
                        buffered.time.push({
                          startPTS: Math.max(startPTS, timeRange.start(i)),
                          endPTS: Math.min(endPTS, timeRange.end(i))
                        });
                      } else if (endPTS <= startTime) {
                        break;
                      }
                    }
                    return buffered;
                  };
                  _proto.getPartialFragment = function getPartialFragment(time) {
                    var bestFragment = null;
                    var timePadding;
                    var startTime;
                    var endTime;
                    var bestOverlap = 0;
                    var bufferPadding = this.bufferPadding, fragments = this.fragments;
                    Object.keys(fragments).forEach(function(key) {
                      var fragmentEntity = fragments[key];
                      if (!fragmentEntity) {
                        return;
                      }
                      if (isPartial(fragmentEntity)) {
                        startTime = fragmentEntity.body.start - bufferPadding;
                        endTime = fragmentEntity.body.end + bufferPadding;
                        if (time >= startTime && time <= endTime) {
                          timePadding = Math.min(time - startTime, endTime - time);
                          if (bestOverlap <= timePadding) {
                            bestFragment = fragmentEntity.body;
                            bestOverlap = timePadding;
                          }
                        }
                      }
                    });
                    return bestFragment;
                  };
                  _proto.isEndListAppended = function isEndListAppended(type) {
                    var lastFragmentEntity = this.endListFragments[type];
                    return lastFragmentEntity !== void 0 && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
                  };
                  _proto.getState = function getState(fragment) {
                    var fragKey = getFragmentKey(fragment);
                    var fragmentEntity = this.fragments[fragKey];
                    if (fragmentEntity) {
                      if (!fragmentEntity.buffered) {
                        return FragmentState.APPENDING;
                      } else if (isPartial(fragmentEntity)) {
                        return FragmentState.PARTIAL;
                      } else {
                        return FragmentState.OK;
                      }
                    }
                    return FragmentState.NOT_LOADED;
                  };
                  _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
                    var startTime;
                    var endTime;
                    for (var i = 0; i < timeRange.length; i++) {
                      startTime = timeRange.start(i) - this.bufferPadding;
                      endTime = timeRange.end(i) + this.bufferPadding;
                      if (startPTS >= startTime && endPTS <= endTime) {
                        return true;
                      }
                      if (endPTS <= startTime) {
                        return false;
                      }
                    }
                    return false;
                  };
                  _proto.onFragLoaded = function onFragLoaded(event, data) {
                    var frag = data.frag, part = data.part;
                    if (frag.sn === "initSegment" || frag.bitrateTest || part) {
                      return;
                    }
                    var fragKey = getFragmentKey(frag);
                    this.fragments[fragKey] = {
                      body: frag,
                      loaded: data,
                      buffered: false,
                      range: /* @__PURE__ */ Object.create(null)
                    };
                  };
                  _proto.onBufferAppended = function onBufferAppended(event, data) {
                    var _this3 = this;
                    var frag = data.frag, part = data.part, timeRanges = data.timeRanges;
                    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_1__.PlaylistLevelType.MAIN) {
                      if (this.activeFragment !== frag) {
                        this.activeFragment = frag;
                        frag.appendedPTS = void 0;
                      }
                      if (part) {
                        var activeParts = this.activeParts;
                        if (!activeParts) {
                          this.activeParts = activeParts = [];
                        }
                        activeParts.push(part);
                      } else {
                        this.activeParts = null;
                      }
                    }
                    this.timeRanges = timeRanges;
                    Object.keys(timeRanges).forEach(function(elementaryStream) {
                      var timeRange = timeRanges[elementaryStream];
                      _this3.detectEvictedFragments(elementaryStream, timeRange);
                      if (!part && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_1__.PlaylistLevelType.MAIN) {
                        var streamInfo = frag.elementaryStreams[elementaryStream];
                        if (!streamInfo) {
                          return;
                        }
                        for (var i = 0; i < timeRange.length; i++) {
                          var rangeEnd = timeRange.end(i);
                          if (rangeEnd <= streamInfo.endPTS && rangeEnd > streamInfo.startPTS) {
                            frag.appendedPTS = Math.max(rangeEnd, frag.appendedPTS || 0);
                          } else {
                            frag.appendedPTS = streamInfo.endPTS;
                          }
                        }
                      }
                    });
                  };
                  _proto.onFragBuffered = function onFragBuffered(event, data) {
                    this.detectPartialFragments(data);
                  };
                  _proto.hasFragment = function hasFragment(fragment) {
                    var fragKey = getFragmentKey(fragment);
                    return !!this.fragments[fragKey];
                  };
                  _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType) {
                    var _this4 = this;
                    Object.keys(this.fragments).forEach(function(key) {
                      var fragmentEntity = _this4.fragments[key];
                      if (!fragmentEntity) {
                        return;
                      }
                      if (fragmentEntity.buffered) {
                        var frag = fragmentEntity.body;
                        if (frag.type === playlistType && frag.start < end && frag.end > start) {
                          _this4.removeFragment(frag);
                        }
                      }
                    });
                  };
                  _proto.removeFragment = function removeFragment(fragment) {
                    var fragKey = getFragmentKey(fragment);
                    fragment.stats.loaded = 0;
                    fragment.clearElementaryStreamInfo();
                    fragment.appendedPTS = void 0;
                    delete this.fragments[fragKey];
                    if (fragment.endList) {
                      delete this.endListFragments[fragment.type];
                    }
                  };
                  _proto.removeAllFragments = function removeAllFragments() {
                    this.fragments = /* @__PURE__ */ Object.create(null);
                    this.endListFragments = /* @__PURE__ */ Object.create(null);
                    this.activeFragment = null;
                    this.activeParts = null;
                  };
                  return FragmentTracker2;
                }();
                function isPartial(fragmentEntity) {
                  var _fragmentEntity$range, _fragmentEntity$range2;
                  return fragmentEntity.buffered && (((_fragmentEntity$range = fragmentEntity.range.video) === null || _fragmentEntity$range === void 0 ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) === null || _fragmentEntity$range2 === void 0 ? void 0 : _fragmentEntity$range2.partial));
                }
                function getFragmentKey(fragment) {
                  return fragment.type + "_" + fragment.level + "_" + fragment.urlId + "_" + fragment.sn;
                }
              }
            ),
            /***/
            "./src/controller/gap-controller.ts": (
              /*!******************************************!*\
                !*** ./src/controller/gap-controller.ts ***!
                \******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "MAX_START_GAP_JUMP": () => (
                    /* binding */
                    MAX_START_GAP_JUMP
                  ),
                  /* harmony export */
                  "SKIP_BUFFER_HOLE_STEP_SECONDS": () => (
                    /* binding */
                    SKIP_BUFFER_HOLE_STEP_SECONDS
                  ),
                  /* harmony export */
                  "SKIP_BUFFER_RANGE_START": () => (
                    /* binding */
                    SKIP_BUFFER_RANGE_START
                  ),
                  /* harmony export */
                  "STALL_MINIMUM_DURATION_MS": () => (
                    /* binding */
                    STALL_MINIMUM_DURATION_MS
                  ),
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    GapController
                  )
                  /* harmony export */
                });
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/buffer-helper */
                  "./src/utils/buffer-helper.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var STALL_MINIMUM_DURATION_MS = 250;
                var MAX_START_GAP_JUMP = 2;
                var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
                var SKIP_BUFFER_RANGE_START = 0.05;
                var GapController = function() {
                  function GapController2(config, media, fragmentTracker, hls) {
                    this.config = void 0;
                    this.media = null;
                    this.fragmentTracker = void 0;
                    this.hls = void 0;
                    this.nudgeRetry = 0;
                    this.stallReported = false;
                    this.stalled = null;
                    this.moved = false;
                    this.seeking = false;
                    this.config = config;
                    this.media = media;
                    this.fragmentTracker = fragmentTracker;
                    this.hls = hls;
                  }
                  var _proto = GapController2.prototype;
                  _proto.destroy = function destroy() {
                    this.media = null;
                    this.hls = this.fragmentTracker = null;
                  };
                  _proto.poll = function poll(lastCurrentTime, activeFrag) {
                    var config = this.config, media = this.media, stalled = this.stalled;
                    if (media === null) {
                      return;
                    }
                    var currentTime = media.currentTime, seeking = media.seeking;
                    var seeked = this.seeking && !seeking;
                    var beginSeek = !this.seeking && seeking;
                    this.seeking = seeking;
                    if (currentTime !== lastCurrentTime) {
                      this.moved = true;
                      if (stalled !== null) {
                        if (this.stallReported) {
                          var _stalledDuration = self.performance.now() - stalled;
                          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(_stalledDuration) + "ms");
                          this.stallReported = false;
                        }
                        this.stalled = null;
                        this.nudgeRetry = 0;
                      }
                      return;
                    }
                    if (beginSeek || seeked) {
                      this.stalled = null;
                    }
                    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.getBuffered(media).length) {
                      return;
                    }
                    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.bufferInfo(media, currentTime, 0);
                    var isBuffered = bufferInfo.len > 0;
                    var nextStart = bufferInfo.nextStart || 0;
                    if (!isBuffered && !nextStart) {
                      return;
                    }
                    if (seeking) {
                      var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
                      var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
                      if (hasEnoughBuffer || noBufferGap) {
                        return;
                      }
                      this.moved = false;
                    }
                    if (!this.moved && this.stalled !== null) {
                      var _level$details;
                      var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
                      var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
                      var isLive = level === null || level === void 0 ? void 0 : (_level$details = level.details) === null || _level$details === void 0 ? void 0 : _level$details.live;
                      var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
                      if (startJump > 0 && startJump <= maxStartGapJump) {
                        this._trySkipBufferHole(null);
                        return;
                      }
                    }
                    var tnow = self.performance.now();
                    if (stalled === null) {
                      this.stalled = tnow;
                      return;
                    }
                    var stalledDuration = tnow - stalled;
                    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
                      this._reportStall(bufferInfo);
                      if (!this.media) {
                        return;
                      }
                    }
                    var bufferedWithHoles = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
                    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
                  };
                  _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {
                    var config = this.config, fragmentTracker = this.fragmentTracker, media = this.media;
                    if (media === null) {
                      return;
                    }
                    var currentTime = media.currentTime;
                    var partial = fragmentTracker.getPartialFragment(currentTime);
                    if (partial) {
                      var targetTime = this._trySkipBufferHole(partial);
                      if (targetTime || !this.media) {
                        return;
                      }
                    }
                    if (bufferInfo.len > config.maxBufferHole && stalledDurationMs > config.highBufferWatchdogPeriod * 1e3) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Trying to nudge playhead over buffer-hole");
                      this.stalled = null;
                      this._tryNudgeBuffer();
                    }
                  };
                  _proto._reportStall = function _reportStall(bufferInfo) {
                    var hls = this.hls, media = this.media, stallReported = this.stallReported;
                    if (!stallReported && media) {
                      this.stallReported = true;
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Playback stalling at @" + media.currentTime + " due to low buffer (" + JSON.stringify(bufferInfo) + ")");
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_STALLED_ERROR,
                        fatal: false,
                        buffer: bufferInfo.len
                      });
                    }
                  };
                  _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
                    var config = this.config, hls = this.hls, media = this.media;
                    if (media === null) {
                      return 0;
                    }
                    var currentTime = media.currentTime;
                    var lastEndTime = 0;
                    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__.BufferHelper.getBuffered(media);
                    for (var i = 0; i < buffered.length; i++) {
                      var startTime = buffered.start(i);
                      if (currentTime + config.maxBufferHole >= lastEndTime && currentTime < startTime) {
                        var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("skipping hole, adjusting currentTime from " + currentTime + " to " + targetTime);
                        this.moved = true;
                        this.stalled = null;
                        media.currentTime = targetTime;
                        if (partial) {
                          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                            fatal: false,
                            reason: "fragment loaded with buffer holes, seeking from " + currentTime + " to " + targetTime,
                            frag: partial
                          });
                        }
                        return targetTime;
                      }
                      lastEndTime = buffered.end(i);
                    }
                    return 0;
                  };
                  _proto._tryNudgeBuffer = function _tryNudgeBuffer() {
                    var config = this.config, hls = this.hls, media = this.media, nudgeRetry = this.nudgeRetry;
                    if (media === null) {
                      return;
                    }
                    var currentTime = media.currentTime;
                    this.nudgeRetry++;
                    if (nudgeRetry < config.nudgeMaxRetry) {
                      var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Nudging 'currentTime' from " + currentTime + " to " + targetTime);
                      media.currentTime = targetTime;
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_NUDGE_ON_STALL,
                        fatal: false
                      });
                    } else {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error("Playhead still not moving while enough data buffered @" + currentTime + " after " + config.nudgeMaxRetry + " nudges");
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.BUFFER_STALLED_ERROR,
                        fatal: true
                      });
                    }
                  };
                  return GapController2;
                }();
              }
            ),
            /***/
            "./src/controller/id3-track-controller.ts": (
              /*!************************************************!*\
                !*** ./src/controller/id3-track-controller.ts ***!
                \************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/texttrack-utils */
                  "./src/utils/texttrack-utils.ts"
                );
                var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../demux/id3 */
                  "./src/demux/id3.ts"
                );
                var _loader_date_range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../loader/date-range */
                  "./src/loader/date-range.ts"
                );
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../types/demuxer */
                  "./src/types/demuxer.ts"
                );
                var MIN_CUE_DURATION = 0.25;
                function getCueClass() {
                  return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;
                }
                var MAX_CUE_ENDTIME = function() {
                  var Cue = getCueClass();
                  try {
                    new Cue(0, Number.POSITIVE_INFINITY, "");
                  } catch (e) {
                    return Number.MAX_VALUE;
                  }
                  return Number.POSITIVE_INFINITY;
                }();
                function dateRangeDateToTimelineSeconds(date, offset) {
                  return date.getTime() / 1e3 - offset;
                }
                function hexToArrayBuffer(str) {
                  return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
                }
                var ID3TrackController = function() {
                  function ID3TrackController2(hls) {
                    this.hls = void 0;
                    this.id3Track = null;
                    this.media = null;
                    this.dateRangeCuesAppended = {};
                    this.hls = hls;
                    this._registerListeners();
                  }
                  var _proto = ID3TrackController2.prototype;
                  _proto.destroy = function destroy() {
                    this._unregisterListeners();
                    this.id3Track = null;
                    this.media = null;
                    this.dateRangeCuesAppended = {};
                    this.hls = null;
                  };
                  _proto._registerListeners = function _registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);
                  };
                  _proto._unregisterListeners = function _unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);
                  };
                  _proto.onMediaAttached = function onMediaAttached(event, data) {
                    this.media = data.media;
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    if (!this.id3Track) {
                      return;
                    }
                    (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.clearCurrentCues)(this.id3Track);
                    this.id3Track = null;
                    this.media = null;
                    this.dateRangeCuesAppended = {};
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.dateRangeCuesAppended = {};
                  };
                  _proto.createTrack = function createTrack(media) {
                    var track = this.getID3Track(media.textTracks);
                    track.mode = "hidden";
                    return track;
                  };
                  _proto.getID3Track = function getID3Track(textTracks) {
                    if (!this.media) {
                      return;
                    }
                    for (var i = 0; i < textTracks.length; i++) {
                      var textTrack = textTracks[i];
                      if (textTrack.kind === "metadata" && textTrack.label === "id3") {
                        (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.sendAddTrackEvent)(textTrack, this.media);
                        return textTrack;
                      }
                    }
                    return this.media.addTextTrack("metadata", "id3");
                  };
                  _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {
                    if (!this.media) {
                      return;
                    }
                    var _this$hls$config = this.hls.config, enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;
                    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
                      return;
                    }
                    var samples = data.samples;
                    if (!this.id3Track) {
                      this.id3Track = this.createTrack(this.media);
                    }
                    var Cue = getCueClass();
                    for (var i = 0; i < samples.length; i++) {
                      var type = samples[i].type;
                      if (type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
                        continue;
                      }
                      var frames = _demux_id3__WEBPACK_IMPORTED_MODULE_3__.getID3Frames(samples[i].data);
                      if (frames) {
                        var startTime = samples[i].pts;
                        var endTime = startTime + samples[i].duration;
                        if (endTime > MAX_CUE_ENDTIME) {
                          endTime = MAX_CUE_ENDTIME;
                        }
                        var timeDiff = endTime - startTime;
                        if (timeDiff <= 0) {
                          endTime = startTime + MIN_CUE_DURATION;
                        }
                        for (var j = 0; j < frames.length; j++) {
                          var frame = frames[j];
                          if (!_demux_id3__WEBPACK_IMPORTED_MODULE_3__.isTimeStampFrame(frame)) {
                            this.updateId3CueEnds(startTime);
                            var cue = new Cue(startTime, endTime, "");
                            cue.value = frame;
                            if (type) {
                              cue.type = type;
                            }
                            this.id3Track.addCue(cue);
                          }
                        }
                      }
                    }
                  };
                  _proto.updateId3CueEnds = function updateId3CueEnds(startTime) {
                    var _this$id3Track;
                    var cues = (_this$id3Track = this.id3Track) === null || _this$id3Track === void 0 ? void 0 : _this$id3Track.cues;
                    if (cues) {
                      for (var i = cues.length; i--; ) {
                        var cue = cues[i];
                        if (cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
                          cue.endTime = startTime;
                        }
                      }
                    }
                  };
                  _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {
                    var startOffset = _ref.startOffset, endOffset = _ref.endOffset, type = _ref.type;
                    var id3Track = this.id3Track, hls = this.hls;
                    if (!hls) {
                      return;
                    }
                    var _hls$config = hls.config, enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _hls$config.enableID3MetadataCues;
                    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
                      var predicate;
                      if (type === "audio") {
                        predicate = function predicate2(cue) {
                          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.audioId3 && enableID3MetadataCues;
                        };
                      } else if (type === "video") {
                        predicate = function predicate2(cue) {
                          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.emsg && enableEmsgMetadataCues;
                        };
                      } else {
                        predicate = function predicate2(cue) {
                          return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.emsg && enableEmsgMetadataCues;
                        };
                      }
                      (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.removeCuesInRange)(id3Track, startOffset, endOffset, predicate);
                    }
                  };
                  _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {
                    var _this = this;
                    var details = _ref2.details;
                    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
                      return;
                    }
                    var dateRangeCuesAppended = this.dateRangeCuesAppended, id3Track = this.id3Track;
                    var dateRanges = details.dateRanges;
                    var ids = Object.keys(dateRanges);
                    if (id3Track) {
                      var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function(id) {
                        return !ids.includes(id);
                      });
                      var _loop = function _loop3(i2) {
                        var id = idsToRemove[i2];
                        Object.keys(dateRangeCuesAppended[id].cues).forEach(function(key) {
                          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
                        });
                        delete dateRangeCuesAppended[id];
                      };
                      for (var i = idsToRemove.length; i--; ) {
                        _loop(i);
                      }
                    }
                    var lastFragment = details.fragments[details.fragments.length - 1];
                    if (ids.length === 0 || !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(lastFragment === null || lastFragment === void 0 ? void 0 : lastFragment.programDateTime)) {
                      return;
                    }
                    if (!this.id3Track) {
                      this.id3Track = this.createTrack(this.media);
                    }
                    var dateTimeOffset = lastFragment.programDateTime / 1e3 - lastFragment.start;
                    var Cue = getCueClass();
                    var _loop2 = function _loop22(_i2) {
                      var id = ids[_i2];
                      var dateRange = dateRanges[id];
                      var appendedDateRangeCues = dateRangeCuesAppended[id];
                      var cues = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.cues) || {};
                      var durationKnown = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.durationKnown) || false;
                      var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);
                      var endTime = MAX_CUE_ENDTIME;
                      var endDate = dateRange.endDate;
                      if (endDate) {
                        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
                        durationKnown = true;
                      } else if (dateRange.endOnNext && !durationKnown) {
                        var nextDateRangeWithSameClass = ids.reduce(function(filterMapArray, id2) {
                          var candidate = dateRanges[id2];
                          if (candidate.class === dateRange.class && candidate.id !== id2 && candidate.startDate > dateRange.startDate) {
                            filterMapArray.push(candidate);
                          }
                          return filterMapArray;
                        }, []).sort(function(a, b) {
                          return a.startDate.getTime() - b.startDate.getTime();
                        })[0];
                        if (nextDateRangeWithSameClass) {
                          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
                          durationKnown = true;
                        }
                      }
                      var attributes = Object.keys(dateRange.attr);
                      for (var j = 0; j < attributes.length; j++) {
                        var key = attributes[j];
                        if (key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.ID || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.CLASS || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.START_DATE || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.DURATION || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.END_DATE || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.END_ON_NEXT) {
                          continue;
                        }
                        var cue = cues[key];
                        if (cue) {
                          if (durationKnown && !appendedDateRangeCues.durationKnown) {
                            cue.endTime = endTime;
                          }
                        } else {
                          var data = dateRange.attr[key];
                          cue = new Cue(startTime, endTime, "");
                          if (key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.SCTE35_OUT || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__.DateRangeAttribute.SCTE35_IN) {
                            data = hexToArrayBuffer(data);
                          }
                          cue.value = {
                            key,
                            data
                          };
                          cue.type = _types_demuxer__WEBPACK_IMPORTED_MODULE_5__.MetadataSchema.dateRange;
                          _this.id3Track.addCue(cue);
                          cues[key] = cue;
                        }
                      }
                      dateRangeCuesAppended[id] = {
                        cues,
                        dateRange,
                        durationKnown
                      };
                    };
                    for (var _i = 0; _i < ids.length; _i++) {
                      _loop2(_i);
                    }
                  };
                  return ID3TrackController2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = ID3TrackController;
              }
            ),
            /***/
            "./src/controller/latency-controller.ts": (
              /*!**********************************************!*\
                !*** ./src/controller/latency-controller.ts ***!
                \**********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    LatencyController
                  )
                  /* harmony export */
                });
                var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var LatencyController = function() {
                  function LatencyController2(hls) {
                    var _this = this;
                    this.hls = void 0;
                    this.config = void 0;
                    this.media = null;
                    this.levelDetails = null;
                    this.currentTime = 0;
                    this.stallCount = 0;
                    this._latency = null;
                    this.timeupdateHandler = function() {
                      return _this.timeupdate();
                    };
                    this.hls = hls;
                    this.config = hls.config;
                    this.registerListeners();
                  }
                  var _proto = LatencyController2.prototype;
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.onMediaDetaching();
                    this.levelDetails = null;
                    this.hls = this.timeupdateHandler = null;
                  };
                  _proto.registerListeners = function registerListeners() {
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated, this);
                    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHED, this.onMediaAttached);
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching);
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading);
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_UPDATED, this.onLevelUpdated);
                    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError);
                  };
                  _proto.onMediaAttached = function onMediaAttached(event, data) {
                    this.media = data.media;
                    this.media.addEventListener("timeupdate", this.timeupdateHandler);
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    if (this.media) {
                      this.media.removeEventListener("timeupdate", this.timeupdateHandler);
                      this.media = null;
                    }
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.levelDetails = null;
                    this._latency = null;
                    this.stallCount = 0;
                  };
                  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
                    var details = _ref.details;
                    this.levelDetails = details;
                    if (details.advanced) {
                      this.timeupdate();
                    }
                    if (!details.live && this.media) {
                      this.media.removeEventListener("timeupdate", this.timeupdateHandler);
                    }
                  };
                  _proto.onError = function onError(event, data) {
                    if (data.details !== _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.BUFFER_STALLED_ERROR) {
                      return;
                    }
                    this.stallCount++;
                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency");
                  };
                  _proto.timeupdate = function timeupdate() {
                    var media = this.media, levelDetails = this.levelDetails;
                    if (!media || !levelDetails) {
                      return;
                    }
                    this.currentTime = media.currentTime;
                    var latency = this.computeLatency();
                    if (latency === null) {
                      return;
                    }
                    this._latency = latency;
                    var _this$config = this.config, lowLatencyMode = _this$config.lowLatencyMode, maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;
                    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {
                      return;
                    }
                    var targetLatency = this.targetLatency;
                    if (targetLatency === null) {
                      return;
                    }
                    var distanceFromTarget = latency - targetLatency;
                    var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
                    var inLiveRange = distanceFromTarget < liveMinLatencyDuration;
                    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
                      var max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
                      var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
                      media.playbackRate = Math.min(max, Math.max(1, rate));
                    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
                      media.playbackRate = 1;
                    }
                  };
                  _proto.estimateLiveEdge = function estimateLiveEdge() {
                    var levelDetails = this.levelDetails;
                    if (levelDetails === null) {
                      return null;
                    }
                    return levelDetails.edge + levelDetails.age;
                  };
                  _proto.computeLatency = function computeLatency() {
                    var liveEdge = this.estimateLiveEdge();
                    if (liveEdge === null) {
                      return null;
                    }
                    return liveEdge - this.currentTime;
                  };
                  _createClass(LatencyController2, [{
                    key: "latency",
                    get: function get() {
                      return this._latency || 0;
                    }
                  }, {
                    key: "maxLatency",
                    get: function get() {
                      var config = this.config, levelDetails = this.levelDetails;
                      if (config.liveMaxLatencyDuration !== void 0) {
                        return config.liveMaxLatencyDuration;
                      }
                      return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
                    }
                  }, {
                    key: "targetLatency",
                    get: function get() {
                      var levelDetails = this.levelDetails;
                      if (levelDetails === null) {
                        return null;
                      }
                      var holdBack = levelDetails.holdBack, partHoldBack = levelDetails.partHoldBack, targetduration = levelDetails.targetduration;
                      var _this$config2 = this.config, liveSyncDuration = _this$config2.liveSyncDuration, liveSyncDurationCount = _this$config2.liveSyncDurationCount, lowLatencyMode = _this$config2.lowLatencyMode;
                      var userConfig = this.hls.userConfig;
                      var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
                      if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
                        targetLatency = liveSyncDuration !== void 0 ? liveSyncDuration : liveSyncDurationCount * targetduration;
                      }
                      var maxLiveSyncOnStallIncrease = targetduration;
                      var liveSyncOnStallIncrease = 1;
                      return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
                    }
                  }, {
                    key: "liveSyncPosition",
                    get: function get() {
                      var liveEdge = this.estimateLiveEdge();
                      var targetLatency = this.targetLatency;
                      var levelDetails = this.levelDetails;
                      if (liveEdge === null || targetLatency === null || levelDetails === null) {
                        return null;
                      }
                      var edge = levelDetails.edge;
                      var syncPosition = liveEdge - targetLatency - this.edgeStalled;
                      var min = edge - levelDetails.totalduration;
                      var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
                      return Math.min(Math.max(min, syncPosition), max);
                    }
                  }, {
                    key: "drift",
                    get: function get() {
                      var levelDetails = this.levelDetails;
                      if (levelDetails === null) {
                        return 1;
                      }
                      return levelDetails.drift;
                    }
                  }, {
                    key: "edgeStalled",
                    get: function get() {
                      var levelDetails = this.levelDetails;
                      if (levelDetails === null) {
                        return 0;
                      }
                      var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
                      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
                    }
                  }, {
                    key: "forwardBufferLength",
                    get: function get() {
                      var media = this.media, levelDetails = this.levelDetails;
                      if (!media || !levelDetails) {
                        return 0;
                      }
                      var bufferedRanges = media.buffered.length;
                      return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
                    }
                  }]);
                  return LatencyController2;
                }();
              }
            ),
            /***/
            "./src/controller/level-controller.ts": (
              /*!********************************************!*\
                !*** ./src/controller/level-controller.ts ***!
                \********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    LevelController
                  )
                  /* harmony export */
                });
                var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../types/level */
                  "./src/types/level.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _utils_codecs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/codecs */
                  "./src/utils/codecs.ts"
                );
                var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./level-helper */
                  "./src/controller/level-helper.ts"
                );
                var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./base-playlist-controller */
                  "./src/controller/base-playlist-controller.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
                var LevelController = function(_BasePlaylistControll) {
                  _inheritsLoose(LevelController2, _BasePlaylistControll);
                  function LevelController2(hls) {
                    var _this;
                    _this = _BasePlaylistControll.call(this, hls, "[level-controller]") || this;
                    _this._levels = [];
                    _this._firstLevel = -1;
                    _this._startLevel = void 0;
                    _this.currentLevelIndex = -1;
                    _this.manualLevelIndex = -1;
                    _this.onParsedComplete = void 0;
                    _this._registerListeners();
                    return _this;
                  }
                  var _proto = LevelController2.prototype;
                  _proto._registerListeners = function _registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError, this);
                  };
                  _proto._unregisterListeners = function _unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, this.onError, this);
                  };
                  _proto.destroy = function destroy() {
                    this._unregisterListeners();
                    this.manualLevelIndex = -1;
                    this._levels.length = 0;
                    _BasePlaylistControll.prototype.destroy.call(this);
                  };
                  _proto.startLoad = function startLoad() {
                    var levels = this._levels;
                    levels.forEach(function(level) {
                      level.loadError = 0;
                    });
                    _BasePlaylistControll.prototype.startLoad.call(this);
                  };
                  _proto.onManifestLoaded = function onManifestLoaded(event, data) {
                    var levels = [];
                    var audioTracks = [];
                    var subtitleTracks = [];
                    var bitrateStart;
                    var levelSet = {};
                    var levelFromSet;
                    var resolutionFound = false;
                    var videoCodecFound = false;
                    var audioCodecFound = false;
                    data.levels.forEach(function(levelParsed) {
                      var attributes = levelParsed.attrs;
                      resolutionFound = resolutionFound || !!(levelParsed.width && levelParsed.height);
                      videoCodecFound = videoCodecFound || !!levelParsed.videoCodec;
                      audioCodecFound = audioCodecFound || !!levelParsed.audioCodec;
                      if (chromeOrFirefox && levelParsed.audioCodec && levelParsed.audioCodec.indexOf("mp4a.40.34") !== -1) {
                        levelParsed.audioCodec = void 0;
                      }
                      var levelKey = levelParsed.bitrate + "-" + levelParsed.attrs.RESOLUTION + "-" + levelParsed.attrs.CODECS;
                      levelFromSet = levelSet[levelKey];
                      if (!levelFromSet) {
                        levelFromSet = new _types_level__WEBPACK_IMPORTED_MODULE_0__.Level(levelParsed);
                        levelSet[levelKey] = levelFromSet;
                        levels.push(levelFromSet);
                      } else {
                        levelFromSet.url.push(levelParsed.url);
                      }
                      if (attributes) {
                        if (attributes.AUDIO) {
                          (0, _level_helper__WEBPACK_IMPORTED_MODULE_4__.addGroupId)(levelFromSet, "audio", attributes.AUDIO);
                        }
                        if (attributes.SUBTITLES) {
                          (0, _level_helper__WEBPACK_IMPORTED_MODULE_4__.addGroupId)(levelFromSet, "text", attributes.SUBTITLES);
                        }
                      }
                    });
                    if ((resolutionFound || videoCodecFound) && audioCodecFound) {
                      levels = levels.filter(function(_ref) {
                        var videoCodec = _ref.videoCodec, width = _ref.width, height = _ref.height;
                        return !!videoCodec || !!(width && height);
                      });
                    }
                    levels = levels.filter(function(_ref2) {
                      var audioCodec = _ref2.audioCodec, videoCodec = _ref2.videoCodec;
                      return (!audioCodec || (0, _utils_codecs__WEBPACK_IMPORTED_MODULE_3__.isCodecSupportedInMp4)(audioCodec, "audio")) && (!videoCodec || (0, _utils_codecs__WEBPACK_IMPORTED_MODULE_3__.isCodecSupportedInMp4)(videoCodec, "video"));
                    });
                    if (data.audioTracks) {
                      audioTracks = data.audioTracks.filter(function(track) {
                        return !track.audioCodec || (0, _utils_codecs__WEBPACK_IMPORTED_MODULE_3__.isCodecSupportedInMp4)(track.audioCodec, "audio");
                      });
                      (0, _level_helper__WEBPACK_IMPORTED_MODULE_4__.assignTrackIdsByGroup)(audioTracks);
                    }
                    if (data.subtitles) {
                      subtitleTracks = data.subtitles;
                      (0, _level_helper__WEBPACK_IMPORTED_MODULE_4__.assignTrackIdsByGroup)(subtitleTracks);
                    }
                    if (levels.length > 0) {
                      bitrateStart = levels[0].bitrate;
                      levels.sort(function(a, b) {
                        if (a.attrs["HDCP-LEVEL"] !== b.attrs["HDCP-LEVEL"]) {
                          return (a.attrs["HDCP-LEVEL"] || "") > (b.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
                        }
                        if (a.bitrate !== b.bitrate) {
                          return a.bitrate - b.bitrate;
                        }
                        if (a.attrs.SCORE !== b.attrs.SCORE) {
                          return a.attrs.decimalFloatingPoint("SCORE") - b.attrs.decimalFloatingPoint("SCORE");
                        }
                        if (resolutionFound && a.height !== b.height) {
                          return a.height - b.height;
                        }
                        return 0;
                      });
                      this._levels = levels;
                      for (var i = 0; i < levels.length; i++) {
                        if (levels[i].bitrate === bitrateStart) {
                          this._firstLevel = i;
                          this.log("manifest loaded, " + levels.length + " level(s) found, first bitrate: " + bitrateStart);
                          break;
                        }
                      }
                      var audioOnly = audioCodecFound && !videoCodecFound;
                      var edata = {
                        levels,
                        audioTracks,
                        subtitleTracks,
                        sessionData: data.sessionData,
                        sessionKeys: data.sessionKeys,
                        firstLevel: this._firstLevel,
                        stats: data.stats,
                        audio: audioCodecFound,
                        video: videoCodecFound,
                        altAudio: !audioOnly && audioTracks.some(function(t) {
                          return !!t.url;
                        })
                      };
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_PARSED, edata);
                      if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
                        this.hls.startLoad(this.hls.config.startPosition);
                      }
                    } else {
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                        fatal: true,
                        url: data.url,
                        reason: "no level with compatible codecs found in manifest"
                      });
                    }
                  };
                  _proto.onError = function onError(event, data) {
                    var _data$frag, _data$level;
                    _BasePlaylistControll.prototype.onError.call(this, event, data);
                    if (data.fatal) {
                      return;
                    }
                    var context = data.context;
                    var level = this._levels[this.currentLevelIndex];
                    if (context && (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistContextType.AUDIO_TRACK && level.audioGroupIds && context.groupId === level.audioGroupIds[level.urlId] || context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistContextType.SUBTITLE_TRACK && level.textGroupIds && context.groupId === level.textGroupIds[level.urlId])) {
                      this.redundantFailover(this.currentLevelIndex);
                      return;
                    }
                    var levelError = false;
                    var levelSwitch = true;
                    var levelIndex;
                    switch (data.details) {
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.FRAG_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.FRAG_LOAD_TIMEOUT:
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_LOAD_TIMEOUT:
                        if (data.frag) {
                          var variantLevelIndex = data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN ? data.frag.level : this.currentLevelIndex;
                          var _level = this._levels[variantLevelIndex];
                          if (_level) {
                            _level.fragmentError++;
                            if (_level.fragmentError > this.hls.config.fragLoadingMaxRetry) {
                              levelIndex = variantLevelIndex;
                            }
                          } else {
                            levelIndex = variantLevelIndex;
                          }
                        }
                        break;
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: {
                        var restrictedHdcpLevel = level.attrs["HDCP-LEVEL"];
                        if (restrictedHdcpLevel) {
                          this.hls.maxHdcpLevel = _types_level__WEBPACK_IMPORTED_MODULE_0__.HdcpLevels[_types_level__WEBPACK_IMPORTED_MODULE_0__.HdcpLevels.indexOf(restrictedHdcpLevel) - 1];
                          this.warn('Restricting playback to HDCP-LEVEL of "' + this.hls.maxHdcpLevel + '" or lower');
                        }
                      }
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.FRAG_PARSING_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.KEY_SYSTEM_NO_SESSION:
                        levelIndex = ((_data$frag = data.frag) === null || _data$frag === void 0 ? void 0 : _data$frag.type) === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN ? data.frag.level : this.currentLevelIndex;
                        data.levelRetry = false;
                        break;
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                        if (context) {
                          if (context.deliveryDirectives) {
                            levelSwitch = false;
                          }
                          levelIndex = context.level;
                        }
                        levelError = true;
                        break;
                      case _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.REMUX_ALLOC_ERROR:
                        levelIndex = (_data$level = data.level) != null ? _data$level : this.currentLevelIndex;
                        levelError = true;
                        break;
                    }
                    if (levelIndex !== void 0) {
                      this.recoverLevel(data, levelIndex, levelError, levelSwitch);
                    }
                  };
                  _proto.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, levelSwitch) {
                    var errorDetails = errorEvent.details;
                    var level = this._levels[levelIndex];
                    level.loadError++;
                    if (levelError) {
                      var retrying = this.retryLoadingOrFail(errorEvent);
                      if (retrying) {
                        errorEvent.levelRetry = true;
                      } else {
                        this.currentLevelIndex = -1;
                        return;
                      }
                    }
                    if (levelSwitch) {
                      var redundantLevels = level.url.length;
                      if (redundantLevels > 1 && level.loadError < redundantLevels) {
                        errorEvent.levelRetry = true;
                        this.redundantFailover(levelIndex);
                      } else if (this.manualLevelIndex === -1) {
                        var nextLevel = -1;
                        var levels = this._levels;
                        for (var i = levels.length; i--; ) {
                          var candidate = (i + this.currentLevelIndex) % levels.length;
                          if (candidate !== this.currentLevelIndex && levels[candidate].loadError === 0) {
                            nextLevel = candidate;
                            break;
                          }
                        }
                        if (nextLevel > -1 && this.currentLevelIndex !== nextLevel) {
                          this.warn(errorDetails + ": switch to " + nextLevel);
                          errorEvent.levelRetry = true;
                          this.hls.nextAutoLevel = nextLevel;
                        } else if (errorEvent.levelRetry === false) {
                          errorEvent.fatal = true;
                        }
                      }
                    }
                  };
                  _proto.redundantFailover = function redundantFailover(levelIndex) {
                    var level = this._levels[levelIndex];
                    var redundantLevels = level.url.length;
                    if (redundantLevels > 1) {
                      var newUrlId = (level.urlId + 1) % redundantLevels;
                      this.warn("Switching to redundant URL-id " + newUrlId);
                      this._levels.forEach(function(level2) {
                        level2.urlId = newUrlId;
                      });
                      this.level = levelIndex;
                    }
                  };
                  _proto.onFragLoaded = function onFragLoaded(event, _ref3) {
                    var frag = _ref3.frag;
                    if (frag !== void 0 && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN) {
                      var level = this._levels[frag.level];
                      if (level !== void 0) {
                        level.fragmentError = 0;
                        level.loadError = 0;
                      }
                    }
                  };
                  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                    var _data$deliveryDirecti2;
                    var level = data.level, details = data.details;
                    var curLevel = this._levels[level];
                    if (!curLevel) {
                      var _data$deliveryDirecti;
                      this.warn("Invalid level index " + level);
                      if ((_data$deliveryDirecti = data.deliveryDirectives) !== null && _data$deliveryDirecti !== void 0 && _data$deliveryDirecti.skip) {
                        details.deltaUpdateFailed = true;
                      }
                      return;
                    }
                    if (level === this.currentLevelIndex) {
                      if (curLevel.fragmentError === 0) {
                        curLevel.loadError = 0;
                        this.retryCount = 0;
                      }
                      this.playlistLoaded(level, data, curLevel.details);
                    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) !== null && _data$deliveryDirecti2 !== void 0 && _data$deliveryDirecti2.skip) {
                      details.deltaUpdateFailed = true;
                    }
                  };
                  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
                    var currentLevel = this.hls.levels[this.currentLevelIndex];
                    if (!currentLevel) {
                      return;
                    }
                    if (currentLevel.audioGroupIds) {
                      var urlId = -1;
                      var audioGroupId = this.hls.audioTracks[data.id].groupId;
                      for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
                        if (currentLevel.audioGroupIds[i] === audioGroupId) {
                          urlId = i;
                          break;
                        }
                      }
                      if (urlId !== currentLevel.urlId) {
                        currentLevel.urlId = urlId;
                        this.startLoad();
                      }
                    }
                  };
                  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
                    _BasePlaylistControll.prototype.loadPlaylist.call(this);
                    var level = this.currentLevelIndex;
                    var currentLevel = this._levels[level];
                    if (this.canLoad && currentLevel && currentLevel.url.length > 0) {
                      var id = currentLevel.urlId;
                      var url = currentLevel.url[id];
                      if (hlsUrlParameters) {
                        try {
                          url = hlsUrlParameters.addDirectives(url);
                        } catch (error) {
                          this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
                        }
                      }
                      this.log("Attempt loading level index " + level + ((hlsUrlParameters === null || hlsUrlParameters === void 0 ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : "") + " with URL-id " + id + " " + url);
                      this.clearTimer();
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADING, {
                        url,
                        level,
                        id,
                        deliveryDirectives: hlsUrlParameters || null
                      });
                    }
                  };
                  _proto.removeLevel = function removeLevel(levelIndex, urlId) {
                    var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex2(url, id) {
                      return id !== urlId;
                    };
                    var levels = this._levels.filter(function(level, index) {
                      if (index !== levelIndex) {
                        return true;
                      }
                      if (level.url.length > 1 && urlId !== void 0) {
                        level.url = level.url.filter(filterLevelAndGroupByIdIndex);
                        if (level.audioGroupIds) {
                          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);
                        }
                        if (level.textGroupIds) {
                          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);
                        }
                        level.urlId = 0;
                        return true;
                      }
                      return false;
                    }).map(function(level, index) {
                      var details = level.details;
                      if (details !== null && details !== void 0 && details.fragments) {
                        details.fragments.forEach(function(fragment) {
                          fragment.level = index;
                        });
                      }
                      return level;
                    });
                    this._levels = levels;
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVELS_UPDATED, {
                      levels
                    });
                  };
                  _createClass(LevelController2, [{
                    key: "levels",
                    get: function get() {
                      if (this._levels.length === 0) {
                        return null;
                      }
                      return this._levels;
                    }
                  }, {
                    key: "level",
                    get: function get() {
                      return this.currentLevelIndex;
                    },
                    set: function set(newLevel) {
                      var _levels$newLevel;
                      var levels = this._levels;
                      if (levels.length === 0) {
                        return;
                      }
                      if (this.currentLevelIndex === newLevel && (_levels$newLevel = levels[newLevel]) !== null && _levels$newLevel !== void 0 && _levels$newLevel.details) {
                        return;
                      }
                      if (newLevel < 0 || newLevel >= levels.length) {
                        var fatal = newLevel < 0;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                          type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.OTHER_ERROR,
                          details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_SWITCH_ERROR,
                          level: newLevel,
                          fatal,
                          reason: "invalid level idx"
                        });
                        if (fatal) {
                          return;
                        }
                        newLevel = Math.min(newLevel, levels.length - 1);
                      }
                      this.clearTimer();
                      var lastLevelIndex = this.currentLevelIndex;
                      var lastLevel = levels[lastLevelIndex];
                      var level = levels[newLevel];
                      this.log("switching to level " + newLevel + " from " + lastLevelIndex);
                      this.currentLevelIndex = newLevel;
                      var levelSwitchingData = _extends({}, level, {
                        level: newLevel,
                        maxBitrate: level.maxBitrate,
                        uri: level.uri,
                        urlId: level.urlId
                      });
                      delete levelSwitchingData._urlId;
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_SWITCHING, levelSwitchingData);
                      var levelDetails = level.details;
                      if (!levelDetails || levelDetails.live) {
                        var hlsUrlParameters = this.switchParams(level.uri, lastLevel === null || lastLevel === void 0 ? void 0 : lastLevel.details);
                        this.loadPlaylist(hlsUrlParameters);
                      }
                    }
                  }, {
                    key: "manualLevel",
                    get: function get() {
                      return this.manualLevelIndex;
                    },
                    set: function set(newLevel) {
                      this.manualLevelIndex = newLevel;
                      if (this._startLevel === void 0) {
                        this._startLevel = newLevel;
                      }
                      if (newLevel !== -1) {
                        this.level = newLevel;
                      }
                    }
                  }, {
                    key: "firstLevel",
                    get: function get() {
                      return this._firstLevel;
                    },
                    set: function set(newLevel) {
                      this._firstLevel = newLevel;
                    }
                  }, {
                    key: "startLevel",
                    get: function get() {
                      if (this._startLevel === void 0) {
                        var configStartLevel = this.hls.config.startLevel;
                        if (configStartLevel !== void 0) {
                          return configStartLevel;
                        } else {
                          return this._firstLevel;
                        }
                      } else {
                        return this._startLevel;
                      }
                    },
                    set: function set(newLevel) {
                      this._startLevel = newLevel;
                    }
                  }, {
                    key: "nextLoadLevel",
                    get: function get() {
                      if (this.manualLevelIndex !== -1) {
                        return this.manualLevelIndex;
                      } else {
                        return this.hls.nextAutoLevel;
                      }
                    },
                    set: function set(nextLevel) {
                      this.level = nextLevel;
                      if (this.manualLevelIndex === -1) {
                        this.hls.nextAutoLevel = nextLevel;
                      }
                    }
                  }]);
                  return LevelController2;
                }(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__["default"]);
              }
            ),
            /***/
            "./src/controller/level-helper.ts": (
              /*!****************************************!*\
                !*** ./src/controller/level-helper.ts ***!
                \****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "addGroupId": () => (
                    /* binding */
                    addGroupId
                  ),
                  /* harmony export */
                  "addSliding": () => (
                    /* binding */
                    addSliding
                  ),
                  /* harmony export */
                  "adjustSliding": () => (
                    /* binding */
                    adjustSliding
                  ),
                  /* harmony export */
                  "assignTrackIdsByGroup": () => (
                    /* binding */
                    assignTrackIdsByGroup
                  ),
                  /* harmony export */
                  "computeReloadInterval": () => (
                    /* binding */
                    computeReloadInterval
                  ),
                  /* harmony export */
                  "getFragmentWithSN": () => (
                    /* binding */
                    getFragmentWithSN
                  ),
                  /* harmony export */
                  "getPartWith": () => (
                    /* binding */
                    getPartWith
                  ),
                  /* harmony export */
                  "mapFragmentIntersection": () => (
                    /* binding */
                    mapFragmentIntersection
                  ),
                  /* harmony export */
                  "mapPartIntersection": () => (
                    /* binding */
                    mapPartIntersection
                  ),
                  /* harmony export */
                  "mergeDetails": () => (
                    /* binding */
                    mergeDetails
                  ),
                  /* harmony export */
                  "updateFragPTSDTS": () => (
                    /* binding */
                    updateFragPTSDTS
                  ),
                  /* harmony export */
                  "updatePTS": () => (
                    /* binding */
                    updatePTS
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _loader_date_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../loader/date-range */
                  "./src/loader/date-range.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                function addGroupId(level, type, id) {
                  switch (type) {
                    case "audio":
                      if (!level.audioGroupIds) {
                        level.audioGroupIds = [];
                      }
                      level.audioGroupIds.push(id);
                      break;
                    case "text":
                      if (!level.textGroupIds) {
                        level.textGroupIds = [];
                      }
                      level.textGroupIds.push(id);
                      break;
                  }
                }
                function assignTrackIdsByGroup(tracks) {
                  var groups = {};
                  tracks.forEach(function(track) {
                    var groupId = track.groupId || "";
                    track.id = groups[groupId] = groups[groupId] || 0;
                    groups[groupId]++;
                  });
                }
                function updatePTS(fragments, fromIdx, toIdx) {
                  var fragFrom = fragments[fromIdx];
                  var fragTo = fragments[toIdx];
                  updateFromToPTS(fragFrom, fragTo);
                }
                function updateFromToPTS(fragFrom, fragTo) {
                  var fragToPTS = fragTo.startPTS;
                  if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(fragToPTS)) {
                    var duration = 0;
                    var frag;
                    if (fragTo.sn > fragFrom.sn) {
                      duration = fragToPTS - fragFrom.start;
                      frag = fragFrom;
                    } else {
                      duration = fragFrom.start - fragToPTS;
                      frag = fragTo;
                    }
                    if (frag.duration !== duration) {
                      frag.duration = duration;
                    }
                  } else if (fragTo.sn > fragFrom.sn) {
                    var contiguous = fragFrom.cc === fragTo.cc;
                    if (contiguous && fragFrom.minEndPTS) {
                      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
                    } else {
                      fragTo.start = fragFrom.start + fragFrom.duration;
                    }
                  } else {
                    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
                  }
                }
                function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
                  var parsedMediaDuration = endPTS - startPTS;
                  if (parsedMediaDuration <= 0) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn("Fragment should have a positive duration", frag);
                    endPTS = startPTS + frag.duration;
                    endDTS = startDTS + frag.duration;
                  }
                  var maxStartPTS = startPTS;
                  var minEndPTS = endPTS;
                  var fragStartPts = frag.startPTS;
                  var fragEndPts = frag.endPTS;
                  if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(fragStartPts)) {
                    var deltaPTS = Math.abs(fragStartPts - startPTS);
                    if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.deltaPTS)) {
                      frag.deltaPTS = deltaPTS;
                    } else {
                      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
                    }
                    maxStartPTS = Math.max(startPTS, fragStartPts);
                    startPTS = Math.min(startPTS, fragStartPts);
                    startDTS = Math.min(startDTS, frag.startDTS);
                    minEndPTS = Math.min(endPTS, fragEndPts);
                    endPTS = Math.max(endPTS, fragEndPts);
                    endDTS = Math.max(endDTS, frag.endDTS);
                  }
                  frag.duration = endPTS - startPTS;
                  var drift = startPTS - frag.start;
                  frag.start = frag.startPTS = startPTS;
                  frag.maxStartPTS = maxStartPTS;
                  frag.startDTS = startDTS;
                  frag.endPTS = endPTS;
                  frag.minEndPTS = minEndPTS;
                  frag.endDTS = endDTS;
                  var sn = frag.sn;
                  if (!details || sn < details.startSN || sn > details.endSN) {
                    return 0;
                  }
                  var i;
                  var fragIdx = sn - details.startSN;
                  var fragments = details.fragments;
                  fragments[fragIdx] = frag;
                  for (i = fragIdx; i > 0; i--) {
                    updateFromToPTS(fragments[i], fragments[i - 1]);
                  }
                  for (i = fragIdx; i < fragments.length - 1; i++) {
                    updateFromToPTS(fragments[i], fragments[i + 1]);
                  }
                  if (details.fragmentHint) {
                    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
                  }
                  details.PTSKnown = details.alignedSliding = true;
                  return drift;
                }
                function mergeDetails(oldDetails, newDetails) {
                  var currentInitSegment = null;
                  var oldFragments = oldDetails.fragments;
                  for (var i = oldFragments.length - 1; i >= 0; i--) {
                    var oldInit = oldFragments[i].initSegment;
                    if (oldInit) {
                      currentInitSegment = oldInit;
                      break;
                    }
                  }
                  if (oldDetails.fragmentHint) {
                    delete oldDetails.fragmentHint.endPTS;
                  }
                  var ccOffset = 0;
                  var PTSFrag;
                  mapFragmentIntersection(oldDetails, newDetails, function(oldFrag, newFrag) {
                    if (oldFrag.relurl) {
                      ccOffset = oldFrag.cc - newFrag.cc;
                    }
                    if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(oldFrag.startPTS) && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(oldFrag.endPTS)) {
                      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
                      newFrag.startDTS = oldFrag.startDTS;
                      newFrag.appendedPTS = oldFrag.appendedPTS;
                      newFrag.maxStartPTS = oldFrag.maxStartPTS;
                      newFrag.endPTS = oldFrag.endPTS;
                      newFrag.endDTS = oldFrag.endDTS;
                      newFrag.minEndPTS = oldFrag.minEndPTS;
                      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
                      if (newFrag.duration) {
                        PTSFrag = newFrag;
                      }
                      newDetails.PTSKnown = newDetails.alignedSliding = true;
                    }
                    newFrag.elementaryStreams = oldFrag.elementaryStreams;
                    newFrag.loader = oldFrag.loader;
                    newFrag.stats = oldFrag.stats;
                    newFrag.urlId = oldFrag.urlId;
                    if (oldFrag.initSegment) {
                      newFrag.initSegment = oldFrag.initSegment;
                      currentInitSegment = oldFrag.initSegment;
                    }
                  });
                  if (currentInitSegment) {
                    var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
                    fragmentsToCheck.forEach(function(frag) {
                      var _currentInitSegment;
                      if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) === null || _currentInitSegment === void 0 ? void 0 : _currentInitSegment.relurl)) {
                        frag.initSegment = currentInitSegment;
                      }
                    });
                  }
                  if (newDetails.skippedSegments) {
                    newDetails.deltaUpdateFailed = newDetails.fragments.some(function(frag) {
                      return !frag;
                    });
                    if (newDetails.deltaUpdateFailed) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                      for (var _i = newDetails.skippedSegments; _i--; ) {
                        newDetails.fragments.shift();
                      }
                      newDetails.startSN = newDetails.fragments[0].sn;
                      newDetails.startCC = newDetails.fragments[0].cc;
                    } else if (newDetails.canSkipDateRanges) {
                      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
                    }
                  }
                  var newFragments = newDetails.fragments;
                  if (ccOffset) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn("discontinuity sliding from playlist, take drift into account");
                    for (var _i2 = 0; _i2 < newFragments.length; _i2++) {
                      newFragments[_i2].cc += ccOffset;
                    }
                  }
                  if (newDetails.skippedSegments) {
                    newDetails.startCC = newDetails.fragments[0].cc;
                  }
                  mapPartIntersection(oldDetails.partList, newDetails.partList, function(oldPart, newPart) {
                    newPart.elementaryStreams = oldPart.elementaryStreams;
                    newPart.stats = oldPart.stats;
                  });
                  if (PTSFrag) {
                    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
                  } else {
                    adjustSliding(oldDetails, newDetails);
                  }
                  if (newFragments.length) {
                    newDetails.totalduration = newDetails.edge - newFragments[0].start;
                  }
                  newDetails.driftStartTime = oldDetails.driftStartTime;
                  newDetails.driftStart = oldDetails.driftStart;
                  var advancedDateTime = newDetails.advancedDateTime;
                  if (newDetails.advanced && advancedDateTime) {
                    var edge = newDetails.edge;
                    if (!newDetails.driftStart) {
                      newDetails.driftStartTime = advancedDateTime;
                      newDetails.driftStart = edge;
                    }
                    newDetails.driftEndTime = advancedDateTime;
                    newDetails.driftEnd = edge;
                  } else {
                    newDetails.driftEndTime = oldDetails.driftEndTime;
                    newDetails.driftEnd = oldDetails.driftEnd;
                    newDetails.advancedDateTime = oldDetails.advancedDateTime;
                  }
                }
                function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
                  var dateRanges = _extends({}, oldDateRanges);
                  if (recentlyRemovedDateranges) {
                    recentlyRemovedDateranges.forEach(function(id) {
                      delete dateRanges[id];
                    });
                  }
                  Object.keys(deltaDateRanges).forEach(function(id) {
                    var dateRange = new _loader_date_range__WEBPACK_IMPORTED_MODULE_2__.DateRange(deltaDateRanges[id].attr, dateRanges[id]);
                    if (dateRange.isValid) {
                      dateRanges[id] = dateRange;
                    } else {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_1__.logger.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(deltaDateRanges[id].attr) + '"');
                    }
                  });
                  return dateRanges;
                }
                function mapPartIntersection(oldParts, newParts, intersectionFn) {
                  if (oldParts && newParts) {
                    var delta = 0;
                    for (var i = 0, len = oldParts.length; i <= len; i++) {
                      var _oldPart = oldParts[i];
                      var _newPart = newParts[i + delta];
                      if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {
                        intersectionFn(_oldPart, _newPart);
                      } else {
                        delta--;
                      }
                    }
                  }
                }
                function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
                  var skippedSegments = newDetails.skippedSegments;
                  var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
                  var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
                  var delta = newDetails.startSN - oldDetails.startSN;
                  var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
                  var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
                  for (var i = start; i <= end; i++) {
                    var _oldFrag = oldFrags[delta + i];
                    var _newFrag = newFrags[i];
                    if (skippedSegments && !_newFrag && i < skippedSegments) {
                      _newFrag = newDetails.fragments[i] = _oldFrag;
                    }
                    if (_oldFrag && _newFrag) {
                      intersectionFn(_oldFrag, _newFrag);
                    }
                  }
                }
                function adjustSliding(oldDetails, newDetails) {
                  var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
                  var oldFragments = oldDetails.fragments;
                  if (delta < 0 || delta >= oldFragments.length) {
                    return;
                  }
                  addSliding(newDetails, oldFragments[delta].start);
                }
                function addSliding(details, start) {
                  if (start) {
                    var fragments = details.fragments;
                    for (var i = details.skippedSegments; i < fragments.length; i++) {
                      fragments[i].start += start;
                    }
                    if (details.fragmentHint) {
                      details.fragmentHint.start += start;
                    }
                  }
                }
                function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {
                  if (distanceToLiveEdgeMs === void 0) {
                    distanceToLiveEdgeMs = Infinity;
                  }
                  var reloadInterval = 1e3 * newDetails.targetduration;
                  if (newDetails.updated) {
                    var fragments = newDetails.fragments;
                    var liveEdgeMaxTargetDurations = 4;
                    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
                      var lastSegmentDuration = fragments[fragments.length - 1].duration * 1e3;
                      if (lastSegmentDuration < reloadInterval) {
                        reloadInterval = lastSegmentDuration;
                      }
                    }
                  } else {
                    reloadInterval /= 2;
                  }
                  return Math.round(reloadInterval);
                }
                function getFragmentWithSN(level, sn, fragCurrent) {
                  if (!level || !level.details) {
                    return null;
                  }
                  var levelDetails = level.details;
                  var fragment = levelDetails.fragments[sn - levelDetails.startSN];
                  if (fragment) {
                    return fragment;
                  }
                  fragment = levelDetails.fragmentHint;
                  if (fragment && fragment.sn === sn) {
                    return fragment;
                  }
                  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
                    return fragCurrent;
                  }
                  return null;
                }
                function getPartWith(level, sn, partIndex) {
                  if (!level || !level.details) {
                    return null;
                  }
                  var partList = level.details.partList;
                  if (partList) {
                    for (var i = partList.length; i--; ) {
                      var part = partList[i];
                      if (part.index === partIndex && part.fragment.sn === sn) {
                        return part;
                      }
                    }
                  }
                  return null;
                }
              }
            ),
            /***/
            "./src/controller/stream-controller.ts": (
              /*!*********************************************!*\
                !*** ./src/controller/stream-controller.ts ***!
                \*********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    StreamController
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./base-stream-controller */
                  "./src/controller/base-stream-controller.ts"
                );
                var _is_supported__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../is-supported */
                  "./src/is-supported.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/buffer-helper */
                  "./src/utils/buffer-helper.ts"
                );
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./fragment-tracker */
                  "./src/controller/fragment-tracker.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../loader/fragment */
                  "./src/loader/fragment.ts"
                );
                var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../demux/transmuxer-interface */
                  "./src/demux/transmuxer-interface.ts"
                );
                var _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ../types/transmuxer */
                  "./src/types/transmuxer.ts"
                );
                var _gap_controller__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                  /*! ./gap-controller */
                  "./src/controller/gap-controller.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var TICK_INTERVAL = 100;
                var StreamController = function(_BaseStreamController) {
                  _inheritsLoose(StreamController2, _BaseStreamController);
                  function StreamController2(hls, fragmentTracker, keyLoader) {
                    var _this;
                    _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[stream-controller]") || this;
                    _this.audioCodecSwap = false;
                    _this.gapController = null;
                    _this.level = -1;
                    _this._forceStartLoad = false;
                    _this.altAudio = false;
                    _this.audioOnly = false;
                    _this.fragPlaying = null;
                    _this.onvplaying = null;
                    _this.onvseeked = null;
                    _this.fragLastKbps = 0;
                    _this.couldBacktrack = false;
                    _this.backtrackFragment = null;
                    _this.audioCodecSwitch = false;
                    _this.videoBuffer = null;
                    _this._registerListeners();
                    return _this;
                  }
                  var _proto = StreamController2.prototype;
                  _proto._registerListeners = function _registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_LOADING, this.onLevelLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, this.onError, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_CREATED, this.onBufferCreated, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                  };
                  _proto._unregisterListeners = function _unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, this.onError, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_CREATED, this.onBufferCreated, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                  };
                  _proto.onHandlerDestroying = function onHandlerDestroying() {
                    this._unregisterListeners();
                    this.onMediaDetaching();
                  };
                  _proto.startLoad = function startLoad(startPosition) {
                    if (this.levels) {
                      var lastCurrentTime = this.lastCurrentTime, hls = this.hls;
                      this.stopLoad();
                      this.setInterval(TICK_INTERVAL);
                      this.level = -1;
                      this.fragLoadError = 0;
                      if (!this.startFragRequested) {
                        var startLevel = hls.startLevel;
                        if (startLevel === -1) {
                          if (hls.config.testBandwidth && this.levels.length > 1) {
                            startLevel = 0;
                            this.bitrateTest = true;
                          } else {
                            startLevel = hls.nextAutoLevel;
                          }
                        }
                        this.level = hls.nextLoadLevel = startLevel;
                        this.loadedmetadata = false;
                      }
                      if (lastCurrentTime > 0 && startPosition === -1) {
                        this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                        startPosition = lastCurrentTime;
                      }
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
                      this.tick();
                    } else {
                      this._forceStartLoad = true;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.STOPPED;
                    }
                  };
                  _proto.stopLoad = function stopLoad() {
                    this._forceStartLoad = false;
                    _BaseStreamController.prototype.stopLoad.call(this);
                  };
                  _proto.doTick = function doTick() {
                    switch (this.state) {
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE:
                        this.doTickIdle();
                        break;
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL: {
                        var _levels$level;
                        var levels = this.levels, level = this.level;
                        var details = levels === null || levels === void 0 ? void 0 : (_levels$level = levels[level]) === null || _levels$level === void 0 ? void 0 : _levels$level.details;
                        if (details && (!details.live || this.levelLastLoaded === this.level)) {
                          if (this.waitForCdnTuneIn(details)) {
                            break;
                          }
                          this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                          break;
                        }
                        break;
                      }
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY:
                        {
                          var _this$media;
                          var now = self.performance.now();
                          var retryDate = this.retryDate;
                          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {
                            this.log("retryDate reached, switch back to IDLE state");
                            this.resetStartWhenNotLoaded(this.level);
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                          }
                        }
                        break;
                      default:
                        break;
                    }
                    this.onTickEnd();
                  };
                  _proto.onTickEnd = function onTickEnd() {
                    _BaseStreamController.prototype.onTickEnd.call(this);
                    this.checkBuffer();
                    this.checkFragmentChanged();
                  };
                  _proto.doTickIdle = function doTickIdle() {
                    var hls = this.hls, levelLastLoaded = this.levelLastLoaded, levels = this.levels, media = this.media;
                    var config = hls.config, level = hls.nextLoadLevel;
                    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {
                      return;
                    }
                    if (this.altAudio && this.audioOnly) {
                      return;
                    }
                    if (!levels || !levels[level]) {
                      return;
                    }
                    var levelInfo = levels[level];
                    var bufferInfo = this.getMainFwdBufferInfo();
                    if (bufferInfo === null) {
                      return;
                    }
                    var lastDetails = this.getLevelDetails();
                    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
                      var data = {};
                      if (this.altAudio) {
                        data.type = "video";
                      }
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_EOS, data);
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ENDED;
                      return;
                    }
                    this.level = hls.nextLoadLevel = level;
                    var levelDetails = levelInfo.details;
                    if (!levelDetails || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {
                      this.level = level;
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL;
                      return;
                    }
                    var bufferLen = bufferInfo.len;
                    var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
                    if (bufferLen >= maxBufLen) {
                      return;
                    }
                    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
                      this.backtrackFragment = null;
                    }
                    var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
                    var frag = this.getNextFragment(targetBufferTime, levelDetails);
                    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== "initSegment" && this.fragmentTracker.getState(frag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.OK) {
                      var _this$backtrackFragme;
                      var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
                      var fragIdx = backtrackSn - levelDetails.startSN;
                      var backtrackFrag = levelDetails.fragments[fragIdx - 1];
                      if (backtrackFrag && frag.cc === backtrackFrag.cc) {
                        frag = backtrackFrag;
                        this.fragmentTracker.removeFragment(backtrackFrag);
                      }
                    } else if (this.backtrackFragment && bufferInfo.len) {
                      this.backtrackFragment = null;
                    }
                    if (frag && this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.OK && this.nextLoadPosition > targetBufferTime) {
                      var type = this.audioOnly && !this.altAudio ? _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO : _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.VIDEO;
                      var mediaBuffer = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                      if (mediaBuffer) {
                        this.afterBufferFlushed(mediaBuffer, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);
                      }
                      frag = this.getNextFragment(this.nextLoadPosition, levelDetails);
                    }
                    if (!frag) {
                      return;
                    }
                    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
                      frag = frag.initSegment;
                    }
                    this.loadFragment(frag, levelDetails, targetBufferTime);
                  };
                  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
                    var _this$media2;
                    var fragState = this.fragmentTracker.getState(frag);
                    this.fragCurrent = frag;
                    if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.NOT_LOADED) {
                      if (frag.sn === "initSegment") {
                        this._loadInitSegment(frag, levelDetails);
                      } else if (this.bitrateTest) {
                        this.log("Fragment " + frag.sn + " of level " + frag.level + " is being downloaded to test bitrate and will not be buffered");
                        this._loadBitrateTestFrag(frag, levelDetails);
                      } else {
                        this.startFragRequested = true;
                        _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);
                      }
                    } else if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.APPENDING) {
                      if (this.reduceMaxBufferLength(frag.duration)) {
                        this.fragmentTracker.removeFragment(frag);
                      }
                    } else if (((_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.buffered.length) === 0) {
                      this.fragmentTracker.removeAllFragments();
                    }
                  };
                  _proto.getAppendedFrag = function getAppendedFrag(position) {
                    var fragOrPart = this.fragmentTracker.getAppendedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);
                    if (fragOrPart && "fragment" in fragOrPart) {
                      return fragOrPart.fragment;
                    }
                    return fragOrPart;
                  };
                  _proto.getBufferedFrag = function getBufferedFrag(position) {
                    return this.fragmentTracker.getBufferedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);
                  };
                  _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
                    if (frag) {
                      return this.getBufferedFrag(frag.end + 0.5);
                    }
                    return null;
                  };
                  _proto.immediateLevelSwitch = function immediateLevelSwitch() {
                    this.abortCurrentFrag();
                    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                  };
                  _proto.nextLevelSwitch = function nextLevelSwitch() {
                    var levels = this.levels, media = this.media;
                    if (media !== null && media !== void 0 && media.readyState) {
                      var fetchdelay;
                      var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
                      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
                        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
                      }
                      if (!media.paused && levels) {
                        var nextLevelId = this.hls.nextLoadLevel;
                        var nextLevel = levels[nextLevelId];
                        var fragLastKbps = this.fragLastKbps;
                        if (fragLastKbps && this.fragCurrent) {
                          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1e3 * fragLastKbps) + 1;
                        } else {
                          fetchdelay = 0;
                        }
                      } else {
                        fetchdelay = 0;
                      }
                      var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
                      if (bufferedFrag) {
                        var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
                        if (nextBufferedFrag) {
                          this.abortCurrentFrag();
                          var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
                          var fragDuration = nextBufferedFrag.duration;
                          var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));
                          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
                        }
                      }
                    }
                  };
                  _proto.abortCurrentFrag = function abortCurrentFrag() {
                    var fragCurrent = this.fragCurrent;
                    this.fragCurrent = null;
                    this.backtrackFragment = null;
                    if (fragCurrent) {
                      fragCurrent.abortRequests();
                    }
                    switch (this.state) {
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.KEY_LOADING:
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING:
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY:
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING:
                      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED:
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                        break;
                    }
                    this.nextLoadPosition = this.getLoadPosition();
                  };
                  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
                    _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? "video" : null);
                  };
                  _proto.onMediaAttached = function onMediaAttached(event, data) {
                    _BaseStreamController.prototype.onMediaAttached.call(this, event, data);
                    var media = data.media;
                    this.onvplaying = this.onMediaPlaying.bind(this);
                    this.onvseeked = this.onMediaSeeked.bind(this);
                    media.addEventListener("playing", this.onvplaying);
                    media.addEventListener("seeked", this.onvseeked);
                    this.gapController = new _gap_controller__WEBPACK_IMPORTED_MODULE_10__["default"](this.config, media, this.fragmentTracker, this.hls);
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    var media = this.media;
                    if (media && this.onvplaying && this.onvseeked) {
                      media.removeEventListener("playing", this.onvplaying);
                      media.removeEventListener("seeked", this.onvseeked);
                      this.onvplaying = this.onvseeked = null;
                      this.videoBuffer = null;
                    }
                    this.fragPlaying = null;
                    if (this.gapController) {
                      this.gapController.destroy();
                      this.gapController = null;
                    }
                    _BaseStreamController.prototype.onMediaDetaching.call(this);
                  };
                  _proto.onMediaPlaying = function onMediaPlaying() {
                    this.tick();
                  };
                  _proto.onMediaSeeked = function onMediaSeeked() {
                    var media = this.media;
                    var currentTime = media ? media.currentTime : null;
                    if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(currentTime)) {
                      this.log("Media seeked to " + currentTime.toFixed(3));
                    }
                    this.tick();
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.log("Trigger BUFFER_RESET");
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_RESET, void 0);
                    this.fragmentTracker.removeAllFragments();
                    this.couldBacktrack = false;
                    this.startPosition = this.lastCurrentTime = 0;
                    this.fragPlaying = null;
                    this.backtrackFragment = null;
                  };
                  _proto.onManifestParsed = function onManifestParsed(event, data) {
                    var aac = false;
                    var heaac = false;
                    var codec;
                    data.levels.forEach(function(level) {
                      codec = level.audioCodec;
                      if (codec) {
                        if (codec.indexOf("mp4a.40.2") !== -1) {
                          aac = true;
                        }
                        if (codec.indexOf("mp4a.40.5") !== -1) {
                          heaac = true;
                        }
                      }
                    });
                    this.audioCodecSwitch = aac && heaac && !(0, _is_supported__WEBPACK_IMPORTED_MODULE_2__.changeTypeSupported)();
                    if (this.audioCodecSwitch) {
                      this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
                    }
                    this.levels = data.levels;
                    this.startFragRequested = false;
                  };
                  _proto.onLevelLoading = function onLevelLoading(event, data) {
                    var levels = this.levels;
                    if (!levels || this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE) {
                      return;
                    }
                    var level = levels[data.level];
                    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL;
                    }
                  };
                  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                    var _curLevel$details;
                    var levels = this.levels;
                    var newLevelId = data.level;
                    var newDetails = data.details;
                    var duration = newDetails.totalduration;
                    if (!levels) {
                      this.warn("Levels were reset while loading level " + newLevelId);
                      return;
                    }
                    this.log("Level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "], cc [" + newDetails.startCC + ", " + newDetails.endCC + "] duration:" + duration);
                    var fragCurrent = this.fragCurrent;
                    if (fragCurrent && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.FRAG_LOADING_WAITING_RETRY)) {
                      if (fragCurrent.level !== data.level && fragCurrent.loader) {
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                        this.backtrackFragment = null;
                        fragCurrent.abortRequests();
                      }
                    }
                    var curLevel = levels[newLevelId];
                    var sliding = 0;
                    if (newDetails.live || (_curLevel$details = curLevel.details) !== null && _curLevel$details !== void 0 && _curLevel$details.live) {
                      if (!newDetails.fragments[0]) {
                        newDetails.deltaUpdateFailed = true;
                      }
                      if (newDetails.deltaUpdateFailed) {
                        return;
                      }
                      sliding = this.alignPlaylists(newDetails, curLevel.details);
                    }
                    curLevel.details = newDetails;
                    this.levelLastLoaded = newLevelId;
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_UPDATED, {
                      details: newDetails,
                      level: newLevelId
                    });
                    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL) {
                      if (this.waitForCdnTuneIn(newDetails)) {
                        return;
                      }
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                    }
                    if (!this.startFragRequested) {
                      this.setStartPosition(newDetails, sliding);
                    } else if (newDetails.live) {
                      this.synchronizeToLiveEdge(newDetails);
                    }
                    this.tick();
                  };
                  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
                    var _frag$initSegment;
                    var frag = data.frag, part = data.part, payload = data.payload;
                    var levels = this.levels;
                    if (!levels) {
                      this.warn("Levels were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
                      return;
                    }
                    var currentLevel = levels[frag.level];
                    var details = currentLevel.details;
                    if (!details) {
                      this.warn("Dropping fragment " + frag.sn + " of level " + frag.level + " after level details were reset");
                      return;
                    }
                    var videoCodec = currentLevel.videoCodec;
                    var accurateTimeOffset = details.PTSKnown || !details.live;
                    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;
                    var audioCodec = this._getAudioCodec(currentLevel);
                    var transmuxer = this.transmuxer = this.transmuxer || new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__["default"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
                    var partIndex = part ? part.index : -1;
                    var partial = partIndex !== -1;
                    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__.ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
                    var initPTS = this.initPTS[frag.cc];
                    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
                  };
                  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
                    var fromAltAudio = this.altAudio;
                    var altAudio = !!data.url;
                    var trackId = data.id;
                    if (!altAudio) {
                      if (this.mediaBuffer !== this.media) {
                        this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
                        this.mediaBuffer = this.media;
                        var fragCurrent = this.fragCurrent;
                        if (fragCurrent) {
                          this.log("Switching to main audio track, cancel main fragment load");
                          fragCurrent.abortRequests();
                        }
                        this.resetTransmuxer();
                        this.resetLoadingState();
                      } else if (this.audioOnly) {
                        this.resetTransmuxer();
                      }
                      var hls = this.hls;
                      if (fromAltAudio) {
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_FLUSHING, {
                          startOffset: 0,
                          endOffset: Number.POSITIVE_INFINITY,
                          type: "audio"
                        });
                      }
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.AUDIO_TRACK_SWITCHED, {
                        id: trackId
                      });
                    }
                  };
                  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
                    var trackId = data.id;
                    var altAudio = !!this.hls.audioTracks[trackId].url;
                    if (altAudio) {
                      var videoBuffer = this.videoBuffer;
                      if (videoBuffer && this.mediaBuffer !== videoBuffer) {
                        this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
                        this.mediaBuffer = videoBuffer;
                      }
                    }
                    this.altAudio = altAudio;
                    this.tick();
                  };
                  _proto.onBufferCreated = function onBufferCreated(event, data) {
                    var tracks = data.tracks;
                    var mediaTrack;
                    var name;
                    var alternate = false;
                    for (var type in tracks) {
                      var track = tracks[type];
                      if (track.id === "main") {
                        name = type;
                        mediaTrack = track;
                        if (type === "video") {
                          var videoTrack = tracks[type];
                          if (videoTrack) {
                            this.videoBuffer = videoTrack.buffer;
                          }
                        }
                      } else {
                        alternate = true;
                      }
                    }
                    if (alternate && mediaTrack) {
                      this.log("Alternate track found, use " + name + ".buffered to schedule main fragment loading");
                      this.mediaBuffer = mediaTrack.buffer;
                    } else {
                      this.mediaBuffer = this.media;
                    }
                  };
                  _proto.onFragBuffered = function onFragBuffered(event, data) {
                    var frag = data.frag, part = data.part;
                    if (frag && frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN) {
                      return;
                    }
                    if (this.fragContextChanged(frag)) {
                      this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state);
                      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED) {
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                      }
                      return;
                    }
                    var stats = part ? part.stats : frag.stats;
                    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
                    if (frag.sn !== "initSegment") {
                      this.fragPrevious = frag;
                    }
                    this.fragBufferedComplete(frag, part);
                  };
                  _proto.onError = function onError(event, data) {
                    if (data.type === _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorTypes.KEY_SYSTEM_ERROR) {
                      this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN, data);
                      return;
                    }
                    switch (data.details) {
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.FRAG_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.FRAG_LOAD_TIMEOUT:
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.FRAG_PARSING_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.KEY_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.KEY_LOAD_TIMEOUT:
                        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN, data);
                        break;
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.LEVEL_LOAD_ERROR:
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR) {
                          if (data.fatal) {
                            this.warn("" + data.details);
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.ERROR;
                          } else {
                            if (!data.levelRetry && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.WAITING_LEVEL) {
                              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                            }
                          }
                        }
                        break;
                      case _errors__WEBPACK_IMPORTED_MODULE_11__.ErrorDetails.BUFFER_FULL_ERROR:
                        if (data.parent === "main" && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSED)) {
                          var flushBuffer = true;
                          var bufferedInfo = this.getFwdBufferInfo(this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);
                          if (bufferedInfo && bufferedInfo.len > 0.5) {
                            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);
                          }
                          if (flushBuffer) {
                            this.warn("buffer full error also media.currentTime is not buffered, flush main");
                            this.immediateLevelSwitch();
                          }
                          this.resetLoadingState();
                        }
                        break;
                      default:
                        break;
                    }
                  };
                  _proto.checkBuffer = function checkBuffer() {
                    var media = this.media, gapController = this.gapController;
                    if (!media || !gapController || !media.readyState) {
                      return;
                    }
                    if (this.loadedmetadata || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(media).length) {
                      var activeFrag = this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE ? this.fragCurrent : null;
                      gapController.poll(this.lastCurrentTime, activeFrag);
                    }
                    this.lastCurrentTime = media.currentTime;
                  };
                  _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                    if (!this.loadedmetadata) {
                      this.startFragRequested = false;
                      this.nextLoadPosition = this.startPosition;
                    }
                    this.tickImmediate();
                  };
                  _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {
                    var type = _ref.type;
                    if (type !== _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
                      var mediaBuffer = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                      this.afterBufferFlushed(mediaBuffer, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);
                    }
                  };
                  _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
                    this.levels = data.levels;
                  };
                  _proto.swapAudioCodec = function swapAudioCodec() {
                    this.audioCodecSwap = !this.audioCodecSwap;
                  };
                  _proto.seekToStartPos = function seekToStartPos() {
                    var media = this.media;
                    if (!media) {
                      return;
                    }
                    var currentTime = media.currentTime;
                    var startPosition = this.startPosition;
                    if (startPosition >= 0 && currentTime < startPosition) {
                      if (media.seeking) {
                        this.log("could not seek to " + startPosition + ", already seeking at " + currentTime);
                        return;
                      }
                      var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.getBuffered(media);
                      var bufferStart = buffered.length ? buffered.start(0) : 0;
                      var delta = bufferStart - startPosition;
                      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
                        this.log("adjusting start position by " + delta + " to match buffer start");
                        startPosition += delta;
                        this.startPosition = startPosition;
                      }
                      this.log("seek to target start position " + startPosition + " from current time " + currentTime);
                      media.currentTime = startPosition;
                    }
                  };
                  _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
                    var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
                    if (this.audioCodecSwap && audioCodec) {
                      this.log("Swapping audio codec");
                      if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                        audioCodec = "mp4a.40.2";
                      } else {
                        audioCodec = "mp4a.40.5";
                      }
                    }
                    return audioCodec;
                  };
                  _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag, levelDetails) {
                    var _this2 = this;
                    frag.bitrateTest = true;
                    this._doFragLoad(frag, levelDetails).then(function(data) {
                      var hls = _this2.hls;
                      if (!data || _this2.fragContextChanged(frag)) {
                        return;
                      }
                      _this2.fragLoadError = 0;
                      _this2.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                      _this2.startFragRequested = false;
                      _this2.bitrateTest = false;
                      var stats = frag.stats;
                      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_LOADED, data);
                      frag.bitrateTest = false;
                    });
                  };
                  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
                    var _id3$samples;
                    var id = "main";
                    var hls = this.hls;
                    var remuxResult = transmuxResult.remuxResult, chunkMeta = transmuxResult.chunkMeta;
                    var context = this.getCurrentContext(chunkMeta);
                    if (!context) {
                      this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
                      this.resetStartWhenNotLoaded(chunkMeta.level);
                      return;
                    }
                    var frag = context.frag, part = context.part, level = context.level;
                    var video = remuxResult.video, text = remuxResult.text, id3 = remuxResult.id3, initSegment = remuxResult.initSegment;
                    var details = level.details;
                    var audio = this.altAudio ? void 0 : remuxResult.audio;
                    if (this.fragContextChanged(frag)) {
                      return;
                    }
                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING;
                    if (initSegment) {
                      if (initSegment.tracks) {
                        this._bufferInitSegment(level, initSegment.tracks, frag, chunkMeta);
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_PARSING_INIT_SEGMENT, {
                          frag,
                          id,
                          tracks: initSegment.tracks
                        });
                      }
                      var initPTS = initSegment.initPTS;
                      var timescale = initSegment.timescale;
                      if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(initPTS)) {
                        this.initPTS[frag.cc] = initPTS;
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.INIT_PTS_FOUND, {
                          frag,
                          id,
                          initPTS,
                          timescale
                        });
                      }
                    }
                    if (video && remuxResult.independent !== false) {
                      if (details) {
                        var startPTS = video.startPTS, endPTS = video.endPTS, startDTS = video.startDTS, endDTS = video.endDTS;
                        if (part) {
                          part.elementaryStreams[video.type] = {
                            startPTS,
                            endPTS,
                            startDTS,
                            endDTS
                          };
                        } else {
                          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1) {
                            this.couldBacktrack = true;
                          }
                          if (video.dropped && video.independent) {
                            var bufferInfo = this.getMainFwdBufferInfo();
                            var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
                            var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
                            if (targetBufferTime < startTime - this.config.maxBufferHole) {
                              this.backtrack(frag);
                              return;
                            }
                            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
                          }
                        }
                        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
                        if (this.backtrackFragment) {
                          this.backtrackFragment = frag;
                        }
                        this.bufferFragmentData(video, frag, part, chunkMeta);
                      }
                    } else if (remuxResult.independent === false) {
                      this.backtrack(frag);
                      return;
                    }
                    if (audio) {
                      var _startPTS = audio.startPTS, _endPTS = audio.endPTS, _startDTS = audio.startDTS, _endDTS = audio.endDTS;
                      if (part) {
                        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO] = {
                          startPTS: _startPTS,
                          endPTS: _endPTS,
                          startDTS: _startDTS,
                          endDTS: _endDTS
                        };
                      }
                      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__.ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);
                      this.bufferFragmentData(audio, frag, part, chunkMeta);
                    }
                    if (details && id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {
                      var emittedID3 = {
                        id,
                        frag,
                        details,
                        samples: id3.samples
                      };
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_PARSING_METADATA, emittedID3);
                    }
                    if (details && text) {
                      var emittedText = {
                        id,
                        frag,
                        details,
                        samples: text.samples
                      };
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_PARSING_USERDATA, emittedText);
                    }
                  };
                  _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
                    var _this3 = this;
                    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.PARSING) {
                      return;
                    }
                    this.audioOnly = !!tracks.audio && !tracks.video;
                    if (this.altAudio && !this.audioOnly) {
                      delete tracks.audio;
                    }
                    var audio = tracks.audio, video = tracks.video, audiovideo = tracks.audiovideo;
                    if (audio) {
                      var audioCodec = currentLevel.audioCodec;
                      var ua = navigator.userAgent.toLowerCase();
                      if (this.audioCodecSwitch) {
                        if (audioCodec) {
                          if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                            audioCodec = "mp4a.40.2";
                          } else {
                            audioCodec = "mp4a.40.5";
                          }
                        }
                        if (audio.metadata.channelCount !== 1 && ua.indexOf("firefox") === -1) {
                          audioCodec = "mp4a.40.5";
                        }
                      }
                      if (ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
                        audioCodec = "mp4a.40.2";
                        this.log("Android: force audio codec to " + audioCodec);
                      }
                      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
                        this.log('Swapping manifest audio codec "' + currentLevel.audioCodec + '" for "' + audioCodec + '"');
                      }
                      audio.levelCodec = audioCodec;
                      audio.id = "main";
                      this.log("Init audio buffer, container:" + audio.container + ", codecs[selected/level/parsed]=[" + (audioCodec || "") + "/" + (currentLevel.audioCodec || "") + "/" + audio.codec + "]");
                    }
                    if (video) {
                      video.levelCodec = currentLevel.videoCodec;
                      video.id = "main";
                      this.log("Init video buffer, container:" + video.container + ", codecs[level/parsed]=[" + (currentLevel.videoCodec || "") + "/" + video.codec + "]");
                    }
                    if (audiovideo) {
                      this.log("Init audiovideo buffer, container:" + audiovideo.container + ", codecs[level/parsed]=[" + (currentLevel.attrs.CODECS || "") + "/" + audiovideo.codec + "]");
                    }
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_CODECS, tracks);
                    Object.keys(tracks).forEach(function(trackName) {
                      var track = tracks[trackName];
                      var initSegment = track.initSegment;
                      if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {
                        _this3.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.BUFFER_APPENDING, {
                          type: trackName,
                          data: initSegment,
                          frag,
                          part: null,
                          chunkMeta,
                          parent: frag.type
                        });
                      }
                    });
                    this.tick();
                  };
                  _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {
                    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.MAIN);
                  };
                  _proto.backtrack = function backtrack(frag) {
                    this.couldBacktrack = true;
                    this.backtrackFragment = frag;
                    this.resetTransmuxer();
                    this.flushBufferGap(frag);
                    this.fragmentTracker.removeFragment(frag);
                    this.fragPrevious = null;
                    this.nextLoadPosition = frag.start;
                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__.State.IDLE;
                  };
                  _proto.checkFragmentChanged = function checkFragmentChanged() {
                    var video = this.media;
                    var fragPlayingCurrent = null;
                    if (video && video.readyState > 1 && video.seeking === false) {
                      var currentTime = video.currentTime;
                      if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.isBuffered(video, currentTime)) {
                        fragPlayingCurrent = this.getAppendedFrag(currentTime);
                      } else if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__.BufferHelper.isBuffered(video, currentTime + 0.1)) {
                        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
                      }
                      if (fragPlayingCurrent) {
                        this.backtrackFragment = null;
                        var fragPlaying = this.fragPlaying;
                        var fragCurrentLevel = fragPlayingCurrent.level;
                        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {
                          this.fragPlaying = fragPlayingCurrent;
                          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.FRAG_CHANGED, {
                            frag: fragPlayingCurrent
                          });
                          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__.Events.LEVEL_SWITCHED, {
                              level: fragCurrentLevel
                            });
                          }
                        }
                      }
                    }
                  };
                  _createClass(StreamController2, [{
                    key: "nextLevel",
                    get: function get() {
                      var frag = this.nextBufferedFrag;
                      if (frag) {
                        return frag.level;
                      }
                      return -1;
                    }
                  }, {
                    key: "currentFrag",
                    get: function get() {
                      var media = this.media;
                      if (media) {
                        return this.fragPlaying || this.getAppendedFrag(media.currentTime);
                      }
                      return null;
                    }
                  }, {
                    key: "currentProgramDateTime",
                    get: function get() {
                      var media = this.media;
                      if (media) {
                        var currentTime = media.currentTime;
                        var frag = this.currentFrag;
                        if (frag && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(currentTime) && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.programDateTime)) {
                          var epocMs = frag.programDateTime + (currentTime - frag.start) * 1e3;
                          return new Date(epocMs);
                        }
                      }
                      return null;
                    }
                  }, {
                    key: "currentLevel",
                    get: function get() {
                      var frag = this.currentFrag;
                      if (frag) {
                        return frag.level;
                      }
                      return -1;
                    }
                  }, {
                    key: "nextBufferedFrag",
                    get: function get() {
                      var frag = this.currentFrag;
                      if (frag) {
                        return this.followingBufferedFrag(frag);
                      }
                      return null;
                    }
                  }, {
                    key: "forceStartLoad",
                    get: function get() {
                      return this._forceStartLoad;
                    }
                  }]);
                  return StreamController2;
                }(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"]);
              }
            ),
            /***/
            "./src/controller/subtitle-stream-controller.ts": (
              /*!******************************************************!*\
                !*** ./src/controller/subtitle-stream-controller.ts ***!
                \******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "SubtitleStreamController": () => (
                    /* binding */
                    SubtitleStreamController
                  )
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/buffer-helper */
                  "./src/utils/buffer-helper.ts"
                );
                var _fragment_finders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./fragment-finders */
                  "./src/controller/fragment-finders.ts"
                );
                var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/discontinuities */
                  "./src/utils/discontinuities.ts"
                );
                var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./level-helper */
                  "./src/controller/level-helper.ts"
                );
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./fragment-tracker */
                  "./src/controller/fragment-tracker.ts"
                );
                var _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ./base-stream-controller */
                  "./src/controller/base-stream-controller.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var _types_level__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../types/level */
                  "./src/types/level.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var TICK_INTERVAL = 500;
                var SubtitleStreamController = function(_BaseStreamController) {
                  _inheritsLoose(SubtitleStreamController2, _BaseStreamController);
                  function SubtitleStreamController2(hls, fragmentTracker, keyLoader) {
                    var _this;
                    _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[subtitle-stream-controller]") || this;
                    _this.levels = [];
                    _this.currentTrackId = -1;
                    _this.tracksBuffered = [];
                    _this.mainDetails = null;
                    _this._registerListeners();
                    return _this;
                  }
                  var _proto = SubtitleStreamController2.prototype;
                  _proto.onHandlerDestroying = function onHandlerDestroying() {
                    this._unregisterListeners();
                    this.mainDetails = null;
                  };
                  _proto._registerListeners = function _registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                  };
                  _proto._unregisterListeners = function _unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADED, this.onLevelLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_BUFFERED, this.onFragBuffered, this);
                  };
                  _proto.startLoad = function startLoad(startPosition) {
                    this.stopLoad();
                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;
                    this.setInterval(TICK_INTERVAL);
                    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
                    this.tick();
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.mainDetails = null;
                    this.fragmentTracker.removeAllFragments();
                  };
                  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                    this.mainDetails = data.details;
                  };
                  _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {
                    var frag = data.frag, success = data.success;
                    this.fragPrevious = frag;
                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;
                    if (!success) {
                      return;
                    }
                    var buffered = this.tracksBuffered[this.currentTrackId];
                    if (!buffered) {
                      return;
                    }
                    var timeRange;
                    var fragStart = frag.start;
                    for (var i = 0; i < buffered.length; i++) {
                      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
                        timeRange = buffered[i];
                        break;
                      }
                    }
                    var fragEnd = frag.start + frag.duration;
                    if (timeRange) {
                      timeRange.end = fragEnd;
                    } else {
                      timeRange = {
                        start: fragStart,
                        end: fragEnd
                      };
                      buffered.push(timeRange);
                    }
                    this.fragmentTracker.fragBuffered(frag);
                  };
                  _proto.onBufferFlushing = function onBufferFlushing(event, data) {
                    var startOffset = data.startOffset, endOffset = data.endOffset;
                    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
                      var currentTrackId = this.currentTrackId, levels = this.levels;
                      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {
                        return;
                      }
                      var trackDetails = levels[currentTrackId].details;
                      var targetDuration = trackDetails.targetduration;
                      var endOffsetSubtitles = endOffset - targetDuration;
                      if (endOffsetSubtitles <= 0) {
                        return;
                      }
                      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
                      this.tracksBuffered.forEach(function(buffered) {
                        for (var i = 0; i < buffered.length; ) {
                          if (buffered[i].end <= endOffsetSubtitles) {
                            buffered.shift();
                            continue;
                          } else if (buffered[i].start < endOffsetSubtitles) {
                            buffered[i].start = endOffsetSubtitles;
                          } else {
                            break;
                          }
                          i++;
                        }
                      });
                      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.SUBTITLE);
                    }
                  };
                  _proto.onFragBuffered = function onFragBuffered(event, data) {
                    if (!this.loadedmetadata && data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.MAIN) {
                      var _this$media;
                      if ((_this$media = this.media) !== null && _this$media !== void 0 && _this$media.buffered.length) {
                        this.loadedmetadata = true;
                      }
                    }
                  };
                  _proto.onError = function onError(event, data) {
                    var frag = data.frag;
                    if (!frag || frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.SUBTITLE) {
                      return;
                    }
                    if (this.fragCurrent) {
                      this.fragCurrent.abortRequests();
                    }
                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;
                  };
                  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {
                    var _this2 = this;
                    var subtitleTracks = _ref.subtitleTracks;
                    this.tracksBuffered = [];
                    this.levels = subtitleTracks.map(function(mediaPlaylist) {
                      return new _types_level__WEBPACK_IMPORTED_MODULE_8__.Level(mediaPlaylist);
                    });
                    this.fragmentTracker.removeAllFragments();
                    this.fragPrevious = null;
                    this.levels.forEach(function(level) {
                      _this2.tracksBuffered[level.id] = [];
                    });
                    this.mediaBuffer = null;
                  };
                  _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {
                    this.currentTrackId = data.id;
                    if (!this.levels.length || this.currentTrackId === -1) {
                      this.clearInterval();
                      return;
                    }
                    var currentTrack = this.levels[this.currentTrackId];
                    if (currentTrack !== null && currentTrack !== void 0 && currentTrack.details) {
                      this.mediaBuffer = this.mediaBufferTimeRanges;
                    } else {
                      this.mediaBuffer = null;
                    }
                    if (currentTrack) {
                      this.setInterval(TICK_INTERVAL);
                    }
                  };
                  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
                    var _track$details;
                    var newDetails = data.details, trackId = data.id;
                    var currentTrackId = this.currentTrackId, levels = this.levels;
                    if (!levels.length) {
                      return;
                    }
                    var track = levels[currentTrackId];
                    if (trackId >= levels.length || trackId !== currentTrackId || !track) {
                      return;
                    }
                    this.mediaBuffer = this.mediaBufferTimeRanges;
                    var sliding = 0;
                    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {
                      var mainDetails = this.mainDetails;
                      if (newDetails.deltaUpdateFailed || !mainDetails) {
                        return;
                      }
                      var mainSlidingStartFragment = mainDetails.fragments[0];
                      if (!track.details) {
                        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
                          (0, _utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__.alignMediaPlaylistByPDT)(newDetails, mainDetails);
                          sliding = newDetails.fragments[0].start;
                        } else if (mainSlidingStartFragment) {
                          sliding = mainSlidingStartFragment.start;
                          (0, _level_helper__WEBPACK_IMPORTED_MODULE_4__.addSliding)(newDetails, sliding);
                        }
                      } else {
                        sliding = this.alignPlaylists(newDetails, track.details);
                        if (sliding === 0 && mainSlidingStartFragment) {
                          sliding = mainSlidingStartFragment.start;
                          (0, _level_helper__WEBPACK_IMPORTED_MODULE_4__.addSliding)(newDetails, sliding);
                        }
                      }
                    }
                    track.details = newDetails;
                    this.levelLastLoaded = trackId;
                    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
                      this.setStartPosition(track.details, sliding);
                    }
                    this.tick();
                    if (newDetails.live && !this.fragCurrent && this.media && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE) {
                      var foundFrag = (0, _fragment_finders__WEBPACK_IMPORTED_MODULE_2__.findFragmentByPTS)(null, newDetails.fragments, this.media.currentTime, 0);
                      if (!foundFrag) {
                        this.warn("Subtitle playlist not aligned with playback");
                        track.details = void 0;
                      }
                    }
                  };
                  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
                    var _this3 = this;
                    var frag = fragLoadedData.frag, payload = fragLoadedData.payload;
                    var decryptData = frag.decryptdata;
                    var hls = this.hls;
                    if (this.fragContextChanged(frag)) {
                      return;
                    }
                    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
                      var startTime = performance.now();
                      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function(decryptedData) {
                        var endTime = performance.now();
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.FRAG_DECRYPTED, {
                          frag,
                          payload: decryptedData,
                          stats: {
                            tstart: startTime,
                            tdecrypt: endTime
                          }
                        });
                      }).catch(function(err) {
                        _this3.warn(err.name + ": " + err.message);
                        _this3.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;
                      });
                    }
                  };
                  _proto.doTick = function doTick() {
                    if (!this.media) {
                      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE;
                      return;
                    }
                    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__.State.IDLE) {
                      var currentTrackId = this.currentTrackId, levels = this.levels;
                      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {
                        return;
                      }
                      var trackDetails = levels[currentTrackId].details;
                      var targetDuration = trackDetails.targetduration;
                      var config = this.config;
                      var currentTime = this.getLoadPosition();
                      var bufferedInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__.BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime - targetDuration, config.maxBufferHole);
                      var targetBufferTime = bufferedInfo.end, bufferLen = bufferedInfo.len;
                      var mainBufferInfo = this.getFwdBufferInfo(this.media, _types_loader__WEBPACK_IMPORTED_MODULE_7__.PlaylistLevelType.MAIN);
                      var maxBufLen = this.getMaxBufferLength(mainBufferInfo === null || mainBufferInfo === void 0 ? void 0 : mainBufferInfo.len) + targetDuration;
                      if (bufferLen > maxBufLen) {
                        return;
                      }
                      console.assert(trackDetails, "Subtitle track details are defined on idle subtitle stream controller tick");
                      var fragments = trackDetails.fragments;
                      var fragLen = fragments.length;
                      var end = trackDetails.edge;
                      var foundFrag = null;
                      var fragPrevious = this.fragPrevious;
                      if (targetBufferTime < end) {
                        var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                        foundFrag = (0, _fragment_finders__WEBPACK_IMPORTED_MODULE_2__.findFragmentByPTS)(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), maxFragLookUpTolerance);
                        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
                          foundFrag = fragments[0];
                        }
                      } else {
                        foundFrag = fragments[fragLen - 1];
                      }
                      if (!foundFrag) {
                        return;
                      }
                      foundFrag = this.mapToInitFragWhenRequired(foundFrag);
                      if (this.fragmentTracker.getState(foundFrag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentState.NOT_LOADED) {
                        this.loadFragment(foundFrag, trackDetails, targetBufferTime);
                      }
                    }
                  };
                  _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {
                    var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);
                    if (!mainBufferLength) {
                      return maxConfigBuffer;
                    }
                    return Math.max(maxConfigBuffer, mainBufferLength);
                  };
                  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
                    this.fragCurrent = frag;
                    if (frag.sn === "initSegment") {
                      this._loadInitSegment(frag, levelDetails);
                    } else {
                      this.startFragRequested = true;
                      _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);
                    }
                  };
                  _createClass(SubtitleStreamController2, [{
                    key: "mediaBufferTimeRanges",
                    get: function get() {
                      return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
                    }
                  }]);
                  return SubtitleStreamController2;
                }(_base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["default"]);
                var BufferableInstance = function BufferableInstance2(timeranges) {
                  this.buffered = void 0;
                  var getRange = function getRange2(name, index, length) {
                    index = index >>> 0;
                    if (index > length - 1) {
                      throw new DOMException("Failed to execute '" + name + "' on 'TimeRanges': The index provided (" + index + ") is greater than the maximum bound (" + length + ")");
                    }
                    return timeranges[index][name];
                  };
                  this.buffered = {
                    get length() {
                      return timeranges.length;
                    },
                    end: function end(index) {
                      return getRange("end", index, timeranges.length);
                    },
                    start: function start(index) {
                      return getRange("start", index, timeranges.length);
                    }
                  };
                };
              }
            ),
            /***/
            "./src/controller/subtitle-track-controller.ts": (
              /*!*****************************************************!*\
                !*** ./src/controller/subtitle-track-controller.ts ***!
                \*****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/texttrack-utils */
                  "./src/utils/texttrack-utils.ts"
                );
                var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./base-playlist-controller */
                  "./src/controller/base-playlist-controller.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var SubtitleTrackController = function(_BasePlaylistControll) {
                  _inheritsLoose(SubtitleTrackController2, _BasePlaylistControll);
                  function SubtitleTrackController2(hls) {
                    var _this;
                    _this = _BasePlaylistControll.call(this, hls, "[subtitle-track-controller]") || this;
                    _this.media = null;
                    _this.tracks = [];
                    _this.groupId = null;
                    _this.tracksInGroup = [];
                    _this.trackId = -1;
                    _this.selectDefaultTrack = true;
                    _this.queuedDefaultTrack = -1;
                    _this.trackChangeListener = function() {
                      return _this.onTextTracksChanged();
                    };
                    _this.asyncPollTrackChange = function() {
                      return _this.pollTrackChange(0);
                    };
                    _this.useTextTrackPolling = false;
                    _this.subtitlePollingInterval = -1;
                    _this._subtitleDisplay = true;
                    _this.registerListeners();
                    return _this;
                  }
                  var _proto = SubtitleTrackController2.prototype;
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.tracks.length = 0;
                    this.tracksInGroup.length = 0;
                    this.trackChangeListener = this.asyncPollTrackChange = null;
                    _BasePlaylistControll.prototype.destroy.call(this);
                  };
                  _proto.registerListeners = function registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_ATTACHED, this.onMediaAttached, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.MANIFEST_PARSED, this.onManifestParsed, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_LOADING, this.onLevelLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, this.onError, this);
                  };
                  _proto.onMediaAttached = function onMediaAttached(event, data) {
                    this.media = data.media;
                    if (!this.media) {
                      return;
                    }
                    if (this.queuedDefaultTrack > -1) {
                      this.subtitleTrack = this.queuedDefaultTrack;
                      this.queuedDefaultTrack = -1;
                    }
                    this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks);
                    if (this.useTextTrackPolling) {
                      this.pollTrackChange(500);
                    } else {
                      this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
                    }
                  };
                  _proto.pollTrackChange = function pollTrackChange(timeout) {
                    self.clearInterval(this.subtitlePollingInterval);
                    this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    if (!this.media) {
                      return;
                    }
                    self.clearInterval(this.subtitlePollingInterval);
                    if (!this.useTextTrackPolling) {
                      this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
                    }
                    if (this.trackId > -1) {
                      this.queuedDefaultTrack = this.trackId;
                    }
                    var textTracks = filterSubtitleTracks(this.media.textTracks);
                    textTracks.forEach(function(track) {
                      (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__.clearCurrentCues)(track);
                    });
                    this.subtitleTrack = -1;
                    this.media = null;
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.tracks = [];
                    this.groupId = null;
                    this.tracksInGroup = [];
                    this.trackId = -1;
                    this.selectDefaultTrack = true;
                  };
                  _proto.onManifestParsed = function onManifestParsed(event, data) {
                    this.tracks = data.subtitleTracks;
                  };
                  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
                    var id = data.id, details = data.details;
                    var trackId = this.trackId;
                    var currentTrack = this.tracksInGroup[trackId];
                    if (!currentTrack) {
                      this.warn("Invalid subtitle track id " + id);
                      return;
                    }
                    var curDetails = currentTrack.details;
                    currentTrack.details = data.details;
                    this.log("subtitle track " + id + " loaded [" + details.startSN + "-" + details.endSN + "]");
                    if (id === this.trackId) {
                      this.retryCount = 0;
                      this.playlistLoaded(id, data, curDetails);
                    }
                  };
                  _proto.onLevelLoading = function onLevelLoading(event, data) {
                    this.switchLevel(data.level);
                  };
                  _proto.onLevelSwitching = function onLevelSwitching(event, data) {
                    this.switchLevel(data.level);
                  };
                  _proto.switchLevel = function switchLevel(levelIndex) {
                    var levelInfo = this.hls.levels[levelIndex];
                    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.textGroupIds)) {
                      return;
                    }
                    var textGroupId = levelInfo.textGroupIds[levelInfo.urlId];
                    if (this.groupId !== textGroupId) {
                      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                      var subtitleTracks = this.tracks.filter(function(track) {
                        return !textGroupId || track.groupId === textGroupId;
                      });
                      this.tracksInGroup = subtitleTracks;
                      var initialTrackId = this.findTrackId(lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.name) || this.findTrackId();
                      this.groupId = textGroupId;
                      var subtitleTracksUpdated = {
                        subtitleTracks
                      };
                      this.log("Updating subtitle tracks, " + subtitleTracks.length + ' track(s) found in "' + textGroupId + '" group-id');
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
                      if (initialTrackId !== -1) {
                        this.setSubtitleTrack(initialTrackId, lastTrack);
                      }
                    }
                  };
                  _proto.findTrackId = function findTrackId(name) {
                    var textTracks = this.tracksInGroup;
                    for (var i = 0; i < textTracks.length; i++) {
                      var track = textTracks[i];
                      if (!this.selectDefaultTrack || track.default) {
                        if (!name || name === track.name) {
                          return track.id;
                        }
                      }
                    }
                    return -1;
                  };
                  _proto.onError = function onError(event, data) {
                    _BasePlaylistControll.prototype.onError.call(this, event, data);
                    if (data.fatal || !data.context) {
                      return;
                    }
                    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__.PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
                      this.retryLoadingOrFail(data);
                    }
                  };
                  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
                    _BasePlaylistControll.prototype.loadPlaylist.call(this);
                    var currentTrack = this.tracksInGroup[this.trackId];
                    if (this.shouldLoadTrack(currentTrack)) {
                      var id = currentTrack.id;
                      var groupId = currentTrack.groupId;
                      var url = currentTrack.url;
                      if (hlsUrlParameters) {
                        try {
                          url = hlsUrlParameters.addDirectives(url);
                        } catch (error) {
                          this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
                        }
                      }
                      this.log("Loading subtitle playlist for id " + id);
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_LOADING, {
                        url,
                        id,
                        groupId,
                        deliveryDirectives: hlsUrlParameters || null
                      });
                    }
                  };
                  _proto.toggleTrackModes = function toggleTrackModes(newId) {
                    var _this2 = this;
                    var media = this.media, trackId = this.trackId;
                    if (!media) {
                      return;
                    }
                    var textTracks = filterSubtitleTracks(media.textTracks);
                    var groupTracks = textTracks.filter(function(track) {
                      return track.groupId === _this2.groupId;
                    });
                    if (newId === -1) {
                      [].slice.call(textTracks).forEach(function(track) {
                        track.mode = "disabled";
                      });
                    } else {
                      var oldTrack = groupTracks[trackId];
                      if (oldTrack) {
                        oldTrack.mode = "disabled";
                      }
                    }
                    var nextTrack = groupTracks[newId];
                    if (nextTrack) {
                      nextTrack.mode = this.subtitleDisplay ? "showing" : "hidden";
                    }
                  };
                  _proto.setSubtitleTrack = function setSubtitleTrack(newId, lastTrack) {
                    var _tracks$newId;
                    var tracks = this.tracksInGroup;
                    if (!this.media) {
                      this.queuedDefaultTrack = newId;
                      return;
                    }
                    if (this.trackId !== newId) {
                      this.toggleTrackModes(newId);
                    }
                    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) !== null && _tracks$newId !== void 0 && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {
                      return;
                    }
                    this.clearTimer();
                    var track = tracks[newId];
                    this.log("Switching to subtitle track " + newId);
                    this.trackId = newId;
                    if (track) {
                      var id = track.id, _track$groupId = track.groupId, groupId = _track$groupId === void 0 ? "" : _track$groupId, name = track.name, type = track.type, url = track.url;
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, {
                        id,
                        groupId,
                        name,
                        type,
                        url
                      });
                      var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);
                      this.loadPlaylist(hlsUrlParameters);
                    } else {
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__.Events.SUBTITLE_TRACK_SWITCH, {
                        id: newId
                      });
                    }
                  };
                  _proto.onTextTracksChanged = function onTextTracksChanged() {
                    if (!this.useTextTrackPolling) {
                      self.clearInterval(this.subtitlePollingInterval);
                    }
                    if (!this.media || !this.hls.config.renderTextTracksNatively) {
                      return;
                    }
                    var trackId = -1;
                    var tracks = filterSubtitleTracks(this.media.textTracks);
                    for (var id = 0; id < tracks.length; id++) {
                      if (tracks[id].mode === "hidden") {
                        trackId = id;
                      } else if (tracks[id].mode === "showing") {
                        trackId = id;
                        break;
                      }
                    }
                    if (this.subtitleTrack !== trackId) {
                      this.subtitleTrack = trackId;
                    }
                  };
                  _createClass(SubtitleTrackController2, [{
                    key: "subtitleDisplay",
                    get: function get() {
                      return this._subtitleDisplay;
                    },
                    set: function set(value) {
                      this._subtitleDisplay = value;
                      if (this.trackId > -1) {
                        this.toggleTrackModes(this.trackId);
                      }
                    }
                  }, {
                    key: "subtitleTracks",
                    get: function get() {
                      return this.tracksInGroup;
                    }
                    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
                  }, {
                    key: "subtitleTrack",
                    get: function get() {
                      return this.trackId;
                    },
                    set: function set(newId) {
                      this.selectDefaultTrack = false;
                      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                      this.setSubtitleTrack(newId, lastTrack);
                    }
                  }]);
                  return SubtitleTrackController2;
                }(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__["default"]);
                function filterSubtitleTracks(textTrackList) {
                  var tracks = [];
                  for (var i = 0; i < textTrackList.length; i++) {
                    var track = textTrackList[i];
                    if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
                      tracks.push(textTrackList[i]);
                    }
                  }
                  return tracks;
                }
                const __WEBPACK_DEFAULT_EXPORT__ = SubtitleTrackController;
              }
            ),
            /***/
            "./src/controller/timeline-controller.ts": (
              /*!***********************************************!*\
                !*** ./src/controller/timeline-controller.ts ***!
                \***********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "TimelineController": () => (
                    /* binding */
                    TimelineController
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/cea-608-parser */
                  "./src/utils/cea-608-parser.ts"
                );
                var _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/output-filter */
                  "./src/utils/output-filter.ts"
                );
                var _utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/webvtt-parser */
                  "./src/utils/webvtt-parser.ts"
                );
                var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/texttrack-utils */
                  "./src/utils/texttrack-utils.ts"
                );
                var _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../utils/imsc1-ttml-parser */
                  "./src/utils/imsc1-ttml-parser.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var TimelineController = function() {
                  function TimelineController2(hls) {
                    this.hls = void 0;
                    this.media = null;
                    this.config = void 0;
                    this.enabled = true;
                    this.Cues = void 0;
                    this.textTracks = [];
                    this.tracks = [];
                    this.initPTS = [];
                    this.timescale = [];
                    this.unparsedVttFrags = [];
                    this.captionsTracks = {};
                    this.nonNativeCaptionsTracks = {};
                    this.cea608Parser1 = void 0;
                    this.cea608Parser2 = void 0;
                    this.lastSn = -1;
                    this.lastPartIndex = -1;
                    this.prevCC = -1;
                    this.vttCCs = newVTTCCs();
                    this.captionsProperties = void 0;
                    this.hls = hls;
                    this.config = hls.config;
                    this.Cues = hls.config.cueHandler;
                    this.captionsProperties = {
                      textTrack1: {
                        label: this.config.captionsTextTrack1Label,
                        languageCode: this.config.captionsTextTrack1LanguageCode
                      },
                      textTrack2: {
                        label: this.config.captionsTextTrack2Label,
                        languageCode: this.config.captionsTextTrack2LanguageCode
                      },
                      textTrack3: {
                        label: this.config.captionsTextTrack3Label,
                        languageCode: this.config.captionsTextTrack3LanguageCode
                      },
                      textTrack4: {
                        label: this.config.captionsTextTrack4Label,
                        languageCode: this.config.captionsTextTrack4LanguageCode
                      }
                    };
                    if (this.config.enableCEA708Captions) {
                      var channel1 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack1");
                      var channel2 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack2");
                      var channel3 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack3");
                      var channel4 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack4");
                      this.cea608Parser1 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__["default"](1, channel1, channel2);
                      this.cea608Parser2 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__["default"](3, channel3, channel4);
                    }
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADING, this.onFragLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                  }
                  var _proto = TimelineController2.prototype;
                  _proto.destroy = function destroy() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, this.onManifestLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADING, this.onFragLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, this.onFragLoaded, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
                    this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;
                  };
                  _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {
                    var merged = false;
                    for (var i = cueRanges.length; i--; ) {
                      var cueRange = cueRanges[i];
                      var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
                      if (overlap >= 0) {
                        cueRange[0] = Math.min(cueRange[0], startTime);
                        cueRange[1] = Math.max(cueRange[1], endTime);
                        merged = true;
                        if (overlap / (endTime - startTime) > 0.5) {
                          return;
                        }
                      }
                    }
                    if (!merged) {
                      cueRanges.push([startTime, endTime]);
                    }
                    if (this.config.renderTextTracksNatively) {
                      var track = this.captionsTracks[trackName];
                      this.Cues.newCue(track, startTime, endTime, screen);
                    } else {
                      var cues = this.Cues.newCue(null, startTime, endTime, screen);
                      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.CUES_PARSED, {
                        type: "captions",
                        cues,
                        track: trackName
                      });
                    }
                  };
                  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
                    var _this = this;
                    var frag = _ref.frag, id = _ref.id, initPTS = _ref.initPTS, timescale = _ref.timescale;
                    var unparsedVttFrags = this.unparsedVttFrags;
                    if (id === "main") {
                      this.initPTS[frag.cc] = initPTS;
                      this.timescale[frag.cc] = timescale;
                    }
                    if (unparsedVttFrags.length) {
                      this.unparsedVttFrags = [];
                      unparsedVttFrags.forEach(function(frag2) {
                        _this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, frag2);
                      });
                    }
                  };
                  _proto.getExistingTrack = function getExistingTrack(trackName) {
                    var media = this.media;
                    if (media) {
                      for (var i = 0; i < media.textTracks.length; i++) {
                        var textTrack = media.textTracks[i];
                        if (textTrack[trackName]) {
                          return textTrack;
                        }
                      }
                    }
                    return null;
                  };
                  _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {
                    if (this.config.renderTextTracksNatively) {
                      this.createNativeTrack(trackName);
                    } else {
                      this.createNonNativeTrack(trackName);
                    }
                  };
                  _proto.createNativeTrack = function createNativeTrack(trackName) {
                    if (this.captionsTracks[trackName]) {
                      return;
                    }
                    var captionsProperties = this.captionsProperties, captionsTracks = this.captionsTracks, media = this.media;
                    var _captionsProperties$t = captionsProperties[trackName], label = _captionsProperties$t.label, languageCode = _captionsProperties$t.languageCode;
                    var existingTrack = this.getExistingTrack(trackName);
                    if (!existingTrack) {
                      var textTrack = this.createTextTrack("captions", label, languageCode);
                      if (textTrack) {
                        textTrack[trackName] = true;
                        captionsTracks[trackName] = textTrack;
                      }
                    } else {
                      captionsTracks[trackName] = existingTrack;
                      (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(captionsTracks[trackName]);
                      (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.sendAddTrackEvent)(captionsTracks[trackName], media);
                    }
                  };
                  _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {
                    if (this.nonNativeCaptionsTracks[trackName]) {
                      return;
                    }
                    var trackProperties = this.captionsProperties[trackName];
                    if (!trackProperties) {
                      return;
                    }
                    var label = trackProperties.label;
                    var track = {
                      _id: trackName,
                      label,
                      kind: "captions",
                      default: trackProperties.media ? !!trackProperties.media.default : false,
                      closedCaptions: trackProperties.media
                    };
                    this.nonNativeCaptionsTracks[trackName] = track;
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
                      tracks: [track]
                    });
                  };
                  _proto.createTextTrack = function createTextTrack(kind, label, lang) {
                    var media = this.media;
                    if (!media) {
                      return;
                    }
                    return media.addTextTrack(kind, label, lang);
                  };
                  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                    this.media = data.media;
                    this._cleanTracks();
                  };
                  _proto.onMediaDetaching = function onMediaDetaching() {
                    var captionsTracks = this.captionsTracks;
                    Object.keys(captionsTracks).forEach(function(trackName) {
                      (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(captionsTracks[trackName]);
                      delete captionsTracks[trackName];
                    });
                    this.nonNativeCaptionsTracks = {};
                  };
                  _proto.onManifestLoading = function onManifestLoading() {
                    this.lastSn = -1;
                    this.lastPartIndex = -1;
                    this.prevCC = -1;
                    this.vttCCs = newVTTCCs();
                    this._cleanTracks();
                    this.tracks = [];
                    this.captionsTracks = {};
                    this.nonNativeCaptionsTracks = {};
                    this.textTracks = [];
                    this.unparsedVttFrags = this.unparsedVttFrags || [];
                    this.initPTS = [];
                    this.timescale = [];
                    if (this.cea608Parser1 && this.cea608Parser2) {
                      this.cea608Parser1.reset();
                      this.cea608Parser2.reset();
                    }
                  };
                  _proto._cleanTracks = function _cleanTracks() {
                    var media = this.media;
                    if (!media) {
                      return;
                    }
                    var textTracks = media.textTracks;
                    if (textTracks) {
                      for (var i = 0; i < textTracks.length; i++) {
                        (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(textTracks[i]);
                      }
                    }
                  };
                  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {
                    var _this2 = this;
                    this.textTracks = [];
                    var tracks = data.subtitleTracks || [];
                    var hasIMSC1 = tracks.some(function(track) {
                      return track.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.IMSC1_CODEC;
                    });
                    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
                      var sameTracks = this.tracks && tracks && this.tracks.length === tracks.length;
                      this.tracks = tracks || [];
                      if (this.config.renderTextTracksNatively) {
                        var inUseTracks = this.media ? this.media.textTracks : [];
                        this.tracks.forEach(function(track, index) {
                          var textTrack;
                          if (index < inUseTracks.length) {
                            var inUseTrack = null;
                            for (var i = 0; i < inUseTracks.length; i++) {
                              if (canReuseVttTextTrack(inUseTracks[i], track)) {
                                inUseTrack = inUseTracks[i];
                                break;
                              }
                            }
                            if (inUseTrack) {
                              textTrack = inUseTrack;
                            }
                          }
                          if (textTrack) {
                            (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.clearCurrentCues)(textTrack);
                          } else {
                            var textTrackKind = _this2._captionsOrSubtitlesFromCharacteristics(track);
                            textTrack = _this2.createTextTrack(textTrackKind, track.name, track.lang);
                            if (textTrack) {
                              textTrack.mode = "disabled";
                            }
                          }
                          if (textTrack) {
                            textTrack.groupId = track.groupId;
                            _this2.textTracks.push(textTrack);
                          }
                        });
                      } else if (!sameTracks && this.tracks && this.tracks.length) {
                        var tracksList = this.tracks.map(function(track) {
                          return {
                            label: track.name,
                            kind: track.type.toLowerCase(),
                            default: track.default,
                            subtitleTrack: track
                          };
                        });
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
                          tracks: tracksList
                        });
                      }
                    }
                  };
                  _proto._captionsOrSubtitlesFromCharacteristics = function _captionsOrSubtitlesFromCharacteristics(track) {
                    var _track$attrs;
                    if ((_track$attrs = track.attrs) !== null && _track$attrs !== void 0 && _track$attrs.CHARACTERISTICS) {
                      var transcribesSpokenDialog = /transcribes-spoken-dialog/gi.test(track.attrs.CHARACTERISTICS);
                      var describesMusicAndSound = /describes-music-and-sound/gi.test(track.attrs.CHARACTERISTICS);
                      if (transcribesSpokenDialog && describesMusicAndSound) {
                        return "captions";
                      }
                    }
                    return "subtitles";
                  };
                  _proto.onManifestLoaded = function onManifestLoaded(event, data) {
                    var _this3 = this;
                    if (this.config.enableCEA708Captions && data.captions) {
                      data.captions.forEach(function(captionsTrack) {
                        var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
                        if (!instreamIdMatch) {
                          return;
                        }
                        var trackName = "textTrack" + instreamIdMatch[1];
                        var trackProperties = _this3.captionsProperties[trackName];
                        if (!trackProperties) {
                          return;
                        }
                        trackProperties.label = captionsTrack.name;
                        if (captionsTrack.lang) {
                          trackProperties.languageCode = captionsTrack.lang;
                        }
                        trackProperties.media = captionsTrack;
                      });
                    }
                  };
                  _proto.closedCaptionsForLevel = function closedCaptionsForLevel(frag) {
                    var level = this.hls.levels[frag.level];
                    return level === null || level === void 0 ? void 0 : level.attrs["CLOSED-CAPTIONS"];
                  };
                  _proto.onFragLoading = function onFragLoading(event, data) {
                    var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2, lastSn = this.lastSn, lastPartIndex = this.lastPartIndex;
                    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
                      return;
                    }
                    if (data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.MAIN) {
                      var _data$part$index, _data$part;
                      var sn = data.frag.sn;
                      var partIndex = (_data$part$index = data === null || data === void 0 ? void 0 : (_data$part = data.part) === null || _data$part === void 0 ? void 0 : _data$part.index) != null ? _data$part$index : -1;
                      if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1)) {
                        cea608Parser1.reset();
                        cea608Parser2.reset();
                      }
                      this.lastSn = sn;
                      this.lastPartIndex = partIndex;
                    }
                  };
                  _proto.onFragLoaded = function onFragLoaded(event, data) {
                    var frag = data.frag, payload = data.payload;
                    var initPTS = this.initPTS, unparsedVttFrags = this.unparsedVttFrags;
                    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.SUBTITLE) {
                      if (payload.byteLength) {
                        if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(initPTS[frag.cc])) {
                          unparsedVttFrags.push(data);
                          if (initPTS.length) {
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {
                              success: false,
                              frag,
                              error: new Error("Missing initial subtitle PTS")
                            });
                          }
                          return;
                        }
                        var decryptData = frag.decryptdata;
                        var decrypted = "stats" in data;
                        if (decryptData == null || !decryptData.encrypted || decrypted) {
                          var trackPlaylistMedia = this.tracks[frag.level];
                          var vttCCs = this.vttCCs;
                          if (!vttCCs[frag.cc]) {
                            vttCCs[frag.cc] = {
                              start: frag.start,
                              prevCC: this.prevCC,
                              new: true
                            };
                            this.prevCC = frag.cc;
                          }
                          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.IMSC1_CODEC) {
                            this._parseIMSC1(frag, payload);
                          } else {
                            this._parseVTTs(frag, payload, vttCCs);
                          }
                        }
                      } else {
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {
                          success: false,
                          frag,
                          error: new Error("Empty subtitle payload")
                        });
                      }
                    }
                  };
                  _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {
                    var _this4 = this;
                    var hls = this.hls;
                    (0, _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.parseIMSC1)(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function(cues) {
                      _this4._appendCues(cues, frag.level);
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {
                        success: true,
                        frag
                      });
                    }, function(error) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("Failed to parse IMSC1: " + error);
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {
                        success: false,
                        frag,
                        error
                      });
                    });
                  };
                  _proto._parseVTTs = function _parseVTTs(frag, payload, vttCCs) {
                    var _frag$initSegment, _this5 = this;
                    var hls = this.hls;
                    var payloadWebVTT = (_frag$initSegment = frag.initSegment) !== null && _frag$initSegment !== void 0 && _frag$initSegment.data ? (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__.appendUint8Array)(frag.initSegment.data, new Uint8Array(payload)) : payload;
                    (0, _utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__.parseWebVTT)(payloadWebVTT, this.initPTS[frag.cc], this.timescale[frag.cc], vttCCs, frag.cc, frag.start, function(cues) {
                      _this5._appendCues(cues, frag.level);
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {
                        success: true,
                        frag
                      });
                    }, function(error) {
                      _this5._fallbackToIMSC1(frag, payload);
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("Failed to parse VTT cue: " + error);
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_FRAG_PROCESSED, {
                        success: false,
                        frag,
                        error
                      });
                    });
                  };
                  _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {
                    var _this6 = this;
                    var trackPlaylistMedia = this.tracks[frag.level];
                    if (!trackPlaylistMedia.textCodec) {
                      (0, _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.parseIMSC1)(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function() {
                        trackPlaylistMedia.textCodec = _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__.IMSC1_CODEC;
                        _this6._parseIMSC1(frag, payload);
                      }, function() {
                        trackPlaylistMedia.textCodec = "wvtt";
                      });
                    }
                  };
                  _proto._appendCues = function _appendCues(cues, fragLevel) {
                    var hls = this.hls;
                    if (this.config.renderTextTracksNatively) {
                      var textTrack = this.textTracks[fragLevel];
                      if (!textTrack || textTrack.mode === "disabled") {
                        return;
                      }
                      cues.forEach(function(cue) {
                        return (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.addCueToTrack)(textTrack, cue);
                      });
                    } else {
                      var currentTrack = this.tracks[fragLevel];
                      if (!currentTrack) {
                        return;
                      }
                      var track = currentTrack.default ? "default" : "subtitles" + fragLevel;
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.CUES_PARSED, {
                        type: "subtitles",
                        cues,
                        track
                      });
                    }
                  };
                  _proto.onFragDecrypted = function onFragDecrypted(event, data) {
                    var frag = data.frag;
                    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.SUBTITLE) {
                      if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.initPTS[frag.cc])) {
                        this.unparsedVttFrags.push(data);
                        return;
                      }
                      this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_LOADED, data);
                    }
                  };
                  _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {
                    this.tracks = [];
                    this.captionsTracks = {};
                  };
                  _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {
                    var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2;
                    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
                      return;
                    }
                    var frag = data.frag, samples = data.samples;
                    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__.PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
                      return;
                    }
                    for (var i = 0; i < samples.length; i++) {
                      var ccBytes = samples[i].bytes;
                      if (ccBytes) {
                        var ccdatas = this.extractCea608Data(ccBytes);
                        cea608Parser1.addData(samples[i].pts, ccdatas[0]);
                        cea608Parser2.addData(samples[i].pts, ccdatas[1]);
                      }
                    }
                  };
                  _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {
                    var startOffset = _ref2.startOffset, endOffset = _ref2.endOffset, endOffsetSubtitles = _ref2.endOffsetSubtitles, type = _ref2.type;
                    var media = this.media;
                    if (!media || media.currentTime < endOffset) {
                      return;
                    }
                    if (!type || type === "video") {
                      var captionsTracks = this.captionsTracks;
                      Object.keys(captionsTracks).forEach(function(trackName) {
                        return (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.removeCuesInRange)(captionsTracks[trackName], startOffset, endOffset);
                      });
                    }
                    if (this.config.renderTextTracksNatively) {
                      if (startOffset === 0 && endOffsetSubtitles !== void 0) {
                        var textTracks = this.textTracks;
                        Object.keys(textTracks).forEach(function(trackName) {
                          return (0, _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__.removeCuesInRange)(textTracks[trackName], startOffset, endOffsetSubtitles);
                        });
                      }
                    }
                  };
                  _proto.extractCea608Data = function extractCea608Data(byteArray) {
                    var actualCCBytes = [[], []];
                    var count = byteArray[0] & 31;
                    var position = 2;
                    for (var j = 0; j < count; j++) {
                      var tmpByte = byteArray[position++];
                      var ccbyte1 = 127 & byteArray[position++];
                      var ccbyte2 = 127 & byteArray[position++];
                      if (ccbyte1 === 0 && ccbyte2 === 0) {
                        continue;
                      }
                      var ccValid = (4 & tmpByte) !== 0;
                      if (ccValid) {
                        var ccType = 3 & tmpByte;
                        if (0 === ccType || 1 === ccType) {
                          actualCCBytes[ccType].push(ccbyte1);
                          actualCCBytes[ccType].push(ccbyte2);
                        }
                      }
                    }
                    return actualCCBytes;
                  };
                  return TimelineController2;
                }();
                function canReuseVttTextTrack(inUseTrack, manifestTrack) {
                  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
                }
                function intersection(x1, x2, y1, y2) {
                  return Math.min(x2, y2) - Math.max(x1, y1);
                }
                function newVTTCCs() {
                  return {
                    ccOffset: 0,
                    presentationOffset: 0,
                    0: {
                      start: 0,
                      prevCC: -1,
                      new: true
                    }
                  };
                }
              }
            ),
            /***/
            "./src/crypt/aes-crypto.ts": (
              /*!*********************************!*\
                !*** ./src/crypt/aes-crypto.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    AESCrypto
                  )
                  /* harmony export */
                });
                var AESCrypto = function() {
                  function AESCrypto2(subtle, iv) {
                    this.subtle = void 0;
                    this.aesIV = void 0;
                    this.subtle = subtle;
                    this.aesIV = iv;
                  }
                  var _proto = AESCrypto2.prototype;
                  _proto.decrypt = function decrypt(data, key) {
                    return this.subtle.decrypt({
                      name: "AES-CBC",
                      iv: this.aesIV
                    }, key, data);
                  };
                  return AESCrypto2;
                }();
              }
            ),
            /***/
            "./src/crypt/aes-decryptor.ts": (
              /*!************************************!*\
                !*** ./src/crypt/aes-decryptor.ts ***!
                \************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    AESDecryptor
                  ),
                  /* harmony export */
                  "removePadding": () => (
                    /* binding */
                    removePadding
                  )
                  /* harmony export */
                });
                var _utils_typed_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/typed-array */
                  "./src/utils/typed-array.ts"
                );
                function removePadding(array) {
                  var outputBytes = array.byteLength;
                  var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
                  if (paddingBytes) {
                    return (0, _utils_typed_array__WEBPACK_IMPORTED_MODULE_0__.sliceUint8)(array, 0, outputBytes - paddingBytes);
                  }
                  return array;
                }
                var AESDecryptor = function() {
                  function AESDecryptor2() {
                    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
                    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
                    this.sBox = new Uint32Array(256);
                    this.invSBox = new Uint32Array(256);
                    this.key = new Uint32Array(0);
                    this.ksRows = 0;
                    this.keySize = 0;
                    this.keySchedule = void 0;
                    this.invKeySchedule = void 0;
                    this.initTable();
                  }
                  var _proto = AESDecryptor2.prototype;
                  _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
                    var view = new DataView(arrayBuffer);
                    var newArray = new Uint32Array(4);
                    for (var i = 0; i < 4; i++) {
                      newArray[i] = view.getUint32(i * 4);
                    }
                    return newArray;
                  };
                  _proto.initTable = function initTable() {
                    var sBox = this.sBox;
                    var invSBox = this.invSBox;
                    var subMix = this.subMix;
                    var subMix0 = subMix[0];
                    var subMix1 = subMix[1];
                    var subMix2 = subMix[2];
                    var subMix3 = subMix[3];
                    var invSubMix = this.invSubMix;
                    var invSubMix0 = invSubMix[0];
                    var invSubMix1 = invSubMix[1];
                    var invSubMix2 = invSubMix[2];
                    var invSubMix3 = invSubMix[3];
                    var d = new Uint32Array(256);
                    var x = 0;
                    var xi = 0;
                    var i = 0;
                    for (i = 0; i < 256; i++) {
                      if (i < 128) {
                        d[i] = i << 1;
                      } else {
                        d[i] = i << 1 ^ 283;
                      }
                    }
                    for (i = 0; i < 256; i++) {
                      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                      sx = sx >>> 8 ^ sx & 255 ^ 99;
                      sBox[x] = sx;
                      invSBox[sx] = x;
                      var x2 = d[x];
                      var x4 = d[x2];
                      var x8 = d[x4];
                      var t = d[sx] * 257 ^ sx * 16843008;
                      subMix0[x] = t << 24 | t >>> 8;
                      subMix1[x] = t << 16 | t >>> 16;
                      subMix2[x] = t << 8 | t >>> 24;
                      subMix3[x] = t;
                      t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                      invSubMix0[sx] = t << 24 | t >>> 8;
                      invSubMix1[sx] = t << 16 | t >>> 16;
                      invSubMix2[sx] = t << 8 | t >>> 24;
                      invSubMix3[sx] = t;
                      if (!x) {
                        x = xi = 1;
                      } else {
                        x = x2 ^ d[d[d[x8 ^ x2]]];
                        xi ^= d[d[xi]];
                      }
                    }
                  };
                  _proto.expandKey = function expandKey(keyBuffer) {
                    var key = this.uint8ArrayToUint32Array_(keyBuffer);
                    var sameKey = true;
                    var offset = 0;
                    while (offset < key.length && sameKey) {
                      sameKey = key[offset] === this.key[offset];
                      offset++;
                    }
                    if (sameKey) {
                      return;
                    }
                    this.key = key;
                    var keySize = this.keySize = key.length;
                    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
                      throw new Error("Invalid aes key size=" + keySize);
                    }
                    var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
                    var ksRow;
                    var invKsRow;
                    var keySchedule = this.keySchedule = new Uint32Array(ksRows);
                    var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
                    var sbox = this.sBox;
                    var rcon = this.rcon;
                    var invSubMix = this.invSubMix;
                    var invSubMix0 = invSubMix[0];
                    var invSubMix1 = invSubMix[1];
                    var invSubMix2 = invSubMix[2];
                    var invSubMix3 = invSubMix[3];
                    var prev;
                    var t;
                    for (ksRow = 0; ksRow < ksRows; ksRow++) {
                      if (ksRow < keySize) {
                        prev = keySchedule[ksRow] = key[ksRow];
                        continue;
                      }
                      t = prev;
                      if (ksRow % keySize === 0) {
                        t = t << 8 | t >>> 24;
                        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
                        t ^= rcon[ksRow / keySize | 0] << 24;
                      } else if (keySize > 6 && ksRow % keySize === 4) {
                        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
                      }
                      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
                    }
                    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                      ksRow = ksRows - invKsRow;
                      if (invKsRow & 3) {
                        t = keySchedule[ksRow];
                      } else {
                        t = keySchedule[ksRow - 4];
                      }
                      if (invKsRow < 4 || ksRow <= 4) {
                        invKeySchedule[invKsRow] = t;
                      } else {
                        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 255]] ^ invSubMix2[sbox[t >>> 8 & 255]] ^ invSubMix3[sbox[t & 255]];
                      }
                      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
                    }
                  };
                  _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
                    return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
                  };
                  _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
                    var nRounds = this.keySize + 6;
                    var invKeySchedule = this.invKeySchedule;
                    var invSBOX = this.invSBox;
                    var invSubMix = this.invSubMix;
                    var invSubMix0 = invSubMix[0];
                    var invSubMix1 = invSubMix[1];
                    var invSubMix2 = invSubMix[2];
                    var invSubMix3 = invSubMix[3];
                    var initVector = this.uint8ArrayToUint32Array_(aesIV);
                    var initVector0 = initVector[0];
                    var initVector1 = initVector[1];
                    var initVector2 = initVector[2];
                    var initVector3 = initVector[3];
                    var inputInt32 = new Int32Array(inputArrayBuffer);
                    var outputInt32 = new Int32Array(inputInt32.length);
                    var t0, t1, t2, t3;
                    var s0, s1, s2, s3;
                    var inputWords0, inputWords1, inputWords2, inputWords3;
                    var ksRow, i;
                    var swapWord = this.networkToHostOrderSwap;
                    while (offset < inputInt32.length) {
                      inputWords0 = swapWord(inputInt32[offset]);
                      inputWords1 = swapWord(inputInt32[offset + 1]);
                      inputWords2 = swapWord(inputInt32[offset + 2]);
                      inputWords3 = swapWord(inputInt32[offset + 3]);
                      s0 = inputWords0 ^ invKeySchedule[0];
                      s1 = inputWords3 ^ invKeySchedule[1];
                      s2 = inputWords2 ^ invKeySchedule[2];
                      s3 = inputWords1 ^ invKeySchedule[3];
                      ksRow = 4;
                      for (i = 1; i < nRounds; i++) {
                        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
                        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
                        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
                        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
                        s0 = t0;
                        s1 = t1;
                        s2 = t2;
                        s3 = t3;
                        ksRow = ksRow + 4;
                      }
                      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
                      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
                      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
                      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
                      outputInt32[offset] = swapWord(t0 ^ initVector0);
                      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
                      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
                      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
                      initVector0 = inputWords0;
                      initVector1 = inputWords1;
                      initVector2 = inputWords2;
                      initVector3 = inputWords3;
                      offset = offset + 4;
                    }
                    return outputInt32.buffer;
                  };
                  return AESDecryptor2;
                }();
              }
            ),
            /***/
            "./src/crypt/decrypter.ts": (
              /*!********************************!*\
                !*** ./src/crypt/decrypter.ts ***!
                \********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    Decrypter
                  )
                  /* harmony export */
                });
                var _aes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./aes-crypto */
                  "./src/crypt/aes-crypto.ts"
                );
                var _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./fast-aes-key */
                  "./src/crypt/fast-aes-key.ts"
                );
                var _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./aes-decryptor */
                  "./src/crypt/aes-decryptor.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/typed-array */
                  "./src/utils/typed-array.ts"
                );
                var CHUNK_SIZE = 16;
                var Decrypter = function() {
                  function Decrypter2(config, _temp) {
                    var _ref = _temp === void 0 ? {} : _temp, _ref$removePKCS7Paddi = _ref.removePKCS7Padding, removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;
                    this.logEnabled = true;
                    this.removePKCS7Padding = void 0;
                    this.subtle = null;
                    this.softwareDecrypter = null;
                    this.key = null;
                    this.fastAesKey = null;
                    this.remainderData = null;
                    this.currentIV = null;
                    this.currentResult = null;
                    this.useSoftware = void 0;
                    this.useSoftware = config.enableSoftwareAES;
                    this.removePKCS7Padding = removePKCS7Padding;
                    if (removePKCS7Padding) {
                      try {
                        var browserCrypto = self.crypto;
                        if (browserCrypto) {
                          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
                        }
                      } catch (e) {
                      }
                    }
                    if (this.subtle === null) {
                      this.useSoftware = true;
                    }
                  }
                  var _proto = Decrypter2.prototype;
                  _proto.destroy = function destroy() {
                    this.subtle = null;
                    this.softwareDecrypter = null;
                    this.key = null;
                    this.fastAesKey = null;
                    this.remainderData = null;
                    this.currentIV = null;
                    this.currentResult = null;
                  };
                  _proto.isSync = function isSync() {
                    return this.useSoftware;
                  };
                  _proto.flush = function flush() {
                    var currentResult = this.currentResult, remainderData = this.remainderData;
                    if (!currentResult || remainderData) {
                      this.reset();
                      return null;
                    }
                    var data = new Uint8Array(currentResult);
                    this.reset();
                    if (this.removePKCS7Padding) {
                      return (0, _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__.removePadding)(data);
                    }
                    return data;
                  };
                  _proto.reset = function reset() {
                    this.currentResult = null;
                    this.currentIV = null;
                    this.remainderData = null;
                    if (this.softwareDecrypter) {
                      this.softwareDecrypter = null;
                    }
                  };
                  _proto.decrypt = function decrypt(data, key, iv) {
                    var _this = this;
                    if (this.useSoftware) {
                      return new Promise(function(resolve, reject) {
                        _this.softwareDecrypt(new Uint8Array(data), key, iv);
                        var decryptResult = _this.flush();
                        if (decryptResult) {
                          resolve(decryptResult.buffer);
                        } else {
                          reject(new Error("[softwareDecrypt] Failed to decrypt data"));
                        }
                      });
                    }
                    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
                  };
                  _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {
                    var currentIV = this.currentIV, currentResult = this.currentResult, remainderData = this.remainderData;
                    this.logOnce("JS AES decrypt");
                    if (remainderData) {
                      data = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__.appendUint8Array)(remainderData, data);
                      this.remainderData = null;
                    }
                    var currentChunk = this.getValidChunk(data);
                    if (!currentChunk.length) {
                      return null;
                    }
                    if (currentIV) {
                      iv = currentIV;
                    }
                    var softwareDecrypter = this.softwareDecrypter;
                    if (!softwareDecrypter) {
                      softwareDecrypter = this.softwareDecrypter = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__["default"]();
                    }
                    softwareDecrypter.expandKey(key);
                    var result = currentResult;
                    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
                    this.currentIV = (0, _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(currentChunk, -16).buffer;
                    if (!result) {
                      return null;
                    }
                    return result;
                  };
                  _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {
                    var _this2 = this;
                    var subtle = this.subtle;
                    if (this.key !== key || !this.fastAesKey) {
                      this.key = key;
                      this.fastAesKey = new _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__["default"](subtle, key);
                    }
                    return this.fastAesKey.expandKey().then(function(aesKey) {
                      if (!subtle) {
                        return Promise.reject(new Error("web crypto not initialized"));
                      }
                      _this2.logOnce("WebCrypto AES decrypt");
                      var crypto = new _aes_crypto__WEBPACK_IMPORTED_MODULE_0__["default"](subtle, new Uint8Array(iv));
                      return crypto.decrypt(data.buffer, aesKey);
                    }).catch(function(err) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("[decrypter]: WebCrypto Error, disable WebCrypto API, " + err.name + ": " + err.message);
                      return _this2.onWebCryptoError(data, key, iv);
                    });
                  };
                  _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {
                    this.useSoftware = true;
                    this.logEnabled = true;
                    this.softwareDecrypt(data, key, iv);
                    var decryptResult = this.flush();
                    if (decryptResult) {
                      return decryptResult.buffer;
                    }
                    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data");
                  };
                  _proto.getValidChunk = function getValidChunk(data) {
                    var currentChunk = data;
                    var splitPoint = data.length - data.length % CHUNK_SIZE;
                    if (splitPoint !== data.length) {
                      currentChunk = (0, _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(data, 0, splitPoint);
                      this.remainderData = (0, _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(data, splitPoint);
                    }
                    return currentChunk;
                  };
                  _proto.logOnce = function logOnce(msg) {
                    if (!this.logEnabled) {
                      return;
                    }
                    _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log("[decrypter]: " + msg);
                    this.logEnabled = false;
                  };
                  return Decrypter2;
                }();
              }
            ),
            /***/
            "./src/crypt/fast-aes-key.ts": (
              /*!***********************************!*\
                !*** ./src/crypt/fast-aes-key.ts ***!
                \***********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    FastAESKey
                  )
                  /* harmony export */
                });
                var FastAESKey = function() {
                  function FastAESKey2(subtle, key) {
                    this.subtle = void 0;
                    this.key = void 0;
                    this.subtle = subtle;
                    this.key = key;
                  }
                  var _proto = FastAESKey2.prototype;
                  _proto.expandKey = function expandKey() {
                    return this.subtle.importKey("raw", this.key, {
                      name: "AES-CBC"
                    }, false, ["encrypt", "decrypt"]);
                  };
                  return FastAESKey2;
                }();
              }
            ),
            /***/
            "./src/demux/aacdemuxer.ts": (
              /*!*********************************!*\
                !*** ./src/demux/aacdemuxer.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./base-audio-demuxer */
                  "./src/demux/base-audio-demuxer.ts"
                );
                var _adts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./adts */
                  "./src/demux/adts.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../demux/id3 */
                  "./src/demux/id3.ts"
                );
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var AACDemuxer = function(_BaseAudioDemuxer) {
                  _inheritsLoose(AACDemuxer2, _BaseAudioDemuxer);
                  function AACDemuxer2(observer, config) {
                    var _this;
                    _this = _BaseAudioDemuxer.call(this) || this;
                    _this.observer = void 0;
                    _this.config = void 0;
                    _this.observer = observer;
                    _this.config = config;
                    return _this;
                  }
                  var _proto = AACDemuxer2.prototype;
                  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
                    this._audioTrack = {
                      container: "audio/adts",
                      type: "audio",
                      id: 2,
                      pid: -1,
                      sequenceNumber: 0,
                      segmentCodec: "aac",
                      samples: [],
                      manifestCodec: audioCodec,
                      duration: trackDuration,
                      inputTimeScale: 9e4,
                      dropped: 0
                    };
                  };
                  AACDemuxer2.probe = function probe(data) {
                    if (!data) {
                      return false;
                    }
                    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_3__.getID3Data(data, 0) || [];
                    var offset = id3Data.length;
                    for (var length = data.length; offset < length; offset++) {
                      if (_adts__WEBPACK_IMPORTED_MODULE_1__.probe(data, offset)) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("ADTS sync word found !");
                        return true;
                      }
                    }
                    return false;
                  };
                  _proto.canParse = function canParse(data, offset) {
                    return _adts__WEBPACK_IMPORTED_MODULE_1__.canParse(data, offset);
                  };
                  _proto.appendFrame = function appendFrame(track, data, offset) {
                    _adts__WEBPACK_IMPORTED_MODULE_1__.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
                    var frame = _adts__WEBPACK_IMPORTED_MODULE_1__.appendFrame(track, data, offset, this.basePTS, this.frameIndex);
                    if (frame && frame.missing === 0) {
                      return frame;
                    }
                  };
                  return AACDemuxer2;
                }(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__["default"]);
                const __WEBPACK_DEFAULT_EXPORT__ = AACDemuxer;
              }
            ),
            /***/
            "./src/demux/adts.ts": (
              /*!***************************!*\
                !*** ./src/demux/adts.ts ***!
                \***************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "appendFrame": () => (
                    /* binding */
                    appendFrame
                  ),
                  /* harmony export */
                  "canGetFrameLength": () => (
                    /* binding */
                    canGetFrameLength
                  ),
                  /* harmony export */
                  "canParse": () => (
                    /* binding */
                    canParse
                  ),
                  /* harmony export */
                  "getAudioConfig": () => (
                    /* binding */
                    getAudioConfig
                  ),
                  /* harmony export */
                  "getFrameDuration": () => (
                    /* binding */
                    getFrameDuration
                  ),
                  /* harmony export */
                  "getFullFrameLength": () => (
                    /* binding */
                    getFullFrameLength
                  ),
                  /* harmony export */
                  "getHeaderLength": () => (
                    /* binding */
                    getHeaderLength
                  ),
                  /* harmony export */
                  "initTrackConfig": () => (
                    /* binding */
                    initTrackConfig
                  ),
                  /* harmony export */
                  "isHeader": () => (
                    /* binding */
                    isHeader
                  ),
                  /* harmony export */
                  "isHeaderPattern": () => (
                    /* binding */
                    isHeaderPattern
                  ),
                  /* harmony export */
                  "parseFrameHeader": () => (
                    /* binding */
                    parseFrameHeader
                  ),
                  /* harmony export */
                  "probe": () => (
                    /* binding */
                    probe
                  )
                  /* harmony export */
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                function getAudioConfig(observer, data, offset, audioCodec) {
                  var adtsObjectType;
                  var adtsExtensionSamplingIndex;
                  var adtsChannelConfig;
                  var config;
                  var userAgent = navigator.userAgent.toLowerCase();
                  var manifestCodec = audioCodec;
                  var adtsSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                  adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
                  var adtsSamplingIndex = (data[offset + 2] & 60) >>> 2;
                  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
                    observer.trigger(_events__WEBPACK_IMPORTED_MODULE_2__.Events.ERROR, {
                      type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,
                      details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_PARSING_ERROR,
                      fatal: true,
                      reason: "invalid ADTS sampling index:" + adtsSamplingIndex
                    });
                    return;
                  }
                  adtsChannelConfig = (data[offset + 2] & 1) << 2;
                  adtsChannelConfig |= (data[offset + 3] & 192) >>> 6;
                  _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.log("manifest codec:" + audioCodec + ", ADTS type:" + adtsObjectType + ", samplingIndex:" + adtsSamplingIndex);
                  if (/firefox/i.test(userAgent)) {
                    if (adtsSamplingIndex >= 6) {
                      adtsObjectType = 5;
                      config = new Array(4);
                      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
                    } else {
                      adtsObjectType = 2;
                      config = new Array(2);
                      adtsExtensionSamplingIndex = adtsSamplingIndex;
                    }
                  } else if (userAgent.indexOf("android") !== -1) {
                    adtsObjectType = 2;
                    config = new Array(2);
                    adtsExtensionSamplingIndex = adtsSamplingIndex;
                  } else {
                    adtsObjectType = 5;
                    config = new Array(4);
                    if (audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {
                      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
                    } else {
                      if (audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {
                        adtsObjectType = 2;
                        config = new Array(2);
                      }
                      adtsExtensionSamplingIndex = adtsSamplingIndex;
                    }
                  }
                  config[0] = adtsObjectType << 3;
                  config[0] |= (adtsSamplingIndex & 14) >> 1;
                  config[1] |= (adtsSamplingIndex & 1) << 7;
                  config[1] |= adtsChannelConfig << 3;
                  if (adtsObjectType === 5) {
                    config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
                    config[2] = (adtsExtensionSamplingIndex & 1) << 7;
                    config[2] |= 2 << 2;
                    config[3] = 0;
                  }
                  return {
                    config,
                    samplerate: adtsSamplingRates[adtsSamplingIndex],
                    channelCount: adtsChannelConfig,
                    codec: "mp4a.40." + adtsObjectType,
                    manifestCodec
                  };
                }
                function isHeaderPattern(data, offset) {
                  return data[offset] === 255 && (data[offset + 1] & 246) === 240;
                }
                function getHeaderLength(data, offset) {
                  return data[offset + 1] & 1 ? 7 : 9;
                }
                function getFullFrameLength(data, offset) {
                  return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
                }
                function canGetFrameLength(data, offset) {
                  return offset + 5 < data.length;
                }
                function isHeader(data, offset) {
                  return offset + 1 < data.length && isHeaderPattern(data, offset);
                }
                function canParse(data, offset) {
                  return canGetFrameLength(data, offset) && isHeaderPattern(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
                }
                function probe(data, offset) {
                  if (isHeader(data, offset)) {
                    var headerLength = getHeaderLength(data, offset);
                    if (offset + headerLength >= data.length) {
                      return false;
                    }
                    var frameLength = getFullFrameLength(data, offset);
                    if (frameLength <= headerLength) {
                      return false;
                    }
                    var newOffset = offset + frameLength;
                    return newOffset === data.length || isHeader(data, newOffset);
                  }
                  return false;
                }
                function initTrackConfig(track, observer, data, offset, audioCodec) {
                  if (!track.samplerate) {
                    var config = getAudioConfig(observer, data, offset, audioCodec);
                    if (!config) {
                      return;
                    }
                    track.config = config.config;
                    track.samplerate = config.samplerate;
                    track.channelCount = config.channelCount;
                    track.codec = config.codec;
                    track.manifestCodec = config.manifestCodec;
                    _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.log("parsed codec:" + track.codec + ", rate:" + config.samplerate + ", channels:" + config.channelCount);
                  }
                }
                function getFrameDuration(samplerate) {
                  return 1024 * 9e4 / samplerate;
                }
                function parseFrameHeader(data, offset) {
                  var headerLength = getHeaderLength(data, offset);
                  if (offset + headerLength <= data.length) {
                    var frameLength = getFullFrameLength(data, offset) - headerLength;
                    if (frameLength > 0) {
                      return {
                        headerLength,
                        frameLength
                      };
                    }
                  }
                }
                function appendFrame(track, data, offset, pts, frameIndex) {
                  var frameDuration = getFrameDuration(track.samplerate);
                  var stamp = pts + frameIndex * frameDuration;
                  var header = parseFrameHeader(data, offset);
                  var unit;
                  if (header) {
                    var frameLength = header.frameLength, headerLength = header.headerLength;
                    var _length = headerLength + frameLength;
                    var missing = Math.max(0, offset + _length - data.length);
                    if (missing) {
                      unit = new Uint8Array(_length - headerLength);
                      unit.set(data.subarray(offset + headerLength, data.length), 0);
                    } else {
                      unit = data.subarray(offset + headerLength, offset + _length);
                    }
                    var _sample = {
                      unit,
                      pts: stamp
                    };
                    if (!missing) {
                      track.samples.push(_sample);
                    }
                    return {
                      sample: _sample,
                      length: _length,
                      missing
                    };
                  }
                  var length = data.length - offset;
                  unit = new Uint8Array(length);
                  unit.set(data.subarray(offset, data.length), 0);
                  var sample = {
                    unit,
                    pts: stamp
                  };
                  return {
                    sample,
                    length,
                    missing: -1
                  };
                }
              }
            ),
            /***/
            "./src/demux/base-audio-demuxer.ts": (
              /*!*****************************************!*\
                !*** ./src/demux/base-audio-demuxer.ts ***!
                \*****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__,
                  /* harmony export */
                  "initPTSFn": () => (
                    /* binding */
                    initPTSFn
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../demux/id3 */
                  "./src/demux/id3.ts"
                );
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../types/demuxer */
                  "./src/types/demuxer.ts"
                );
                var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./dummy-demuxed-track */
                  "./src/demux/dummy-demuxed-track.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/typed-array */
                  "./src/utils/typed-array.ts"
                );
                var BaseAudioDemuxer = function() {
                  function BaseAudioDemuxer2() {
                    this._audioTrack = void 0;
                    this._id3Track = void 0;
                    this.frameIndex = 0;
                    this.cachedData = null;
                    this.basePTS = null;
                    this.initPTS = null;
                    this.lastPTS = null;
                  }
                  var _proto = BaseAudioDemuxer2.prototype;
                  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                    this._id3Track = {
                      type: "id3",
                      id: 3,
                      pid: -1,
                      inputTimeScale: 9e4,
                      sequenceNumber: 0,
                      samples: [],
                      dropped: 0
                    };
                  };
                  _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {
                    this.initPTS = deaultTimestamp;
                    this.resetContiguity();
                  };
                  _proto.resetContiguity = function resetContiguity() {
                    this.basePTS = null;
                    this.lastPTS = null;
                    this.frameIndex = 0;
                  };
                  _proto.canParse = function canParse(data, offset) {
                    return false;
                  };
                  _proto.appendFrame = function appendFrame(track, data, offset) {
                  };
                  _proto.demux = function demux(data, timeOffset) {
                    if (this.cachedData) {
                      data = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__.appendUint8Array)(this.cachedData, data);
                      this.cachedData = null;
                    }
                    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getID3Data(data, 0);
                    var offset = id3Data ? id3Data.length : 0;
                    var lastDataIndex;
                    var track = this._audioTrack;
                    var id3Track = this._id3Track;
                    var timestamp = id3Data ? _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getTimeStamp(id3Data) : void 0;
                    var length = data.length;
                    if (this.basePTS === null || this.frameIndex === 0 && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(timestamp)) {
                      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
                      this.lastPTS = this.basePTS;
                    }
                    if (this.lastPTS === null) {
                      this.lastPTS = this.basePTS;
                    }
                    if (id3Data && id3Data.length > 0) {
                      id3Track.samples.push({
                        pts: this.lastPTS,
                        dts: this.lastPTS,
                        data: id3Data,
                        type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__.MetadataSchema.audioId3,
                        duration: Number.POSITIVE_INFINITY
                      });
                    }
                    while (offset < length) {
                      if (this.canParse(data, offset)) {
                        var frame = this.appendFrame(track, data, offset);
                        if (frame) {
                          this.frameIndex++;
                          this.lastPTS = frame.sample.pts;
                          offset += frame.length;
                          lastDataIndex = offset;
                        } else {
                          offset = length;
                        }
                      } else if (_demux_id3__WEBPACK_IMPORTED_MODULE_1__.canParse(data, offset)) {
                        id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getID3Data(data, offset);
                        id3Track.samples.push({
                          pts: this.lastPTS,
                          dts: this.lastPTS,
                          data: id3Data,
                          type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__.MetadataSchema.audioId3,
                          duration: Number.POSITIVE_INFINITY
                        });
                        offset += id3Data.length;
                        lastDataIndex = offset;
                      } else {
                        offset++;
                      }
                      if (offset === length && lastDataIndex !== length) {
                        var partialData = (0, _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__.sliceUint8)(data, lastDataIndex);
                        if (this.cachedData) {
                          this.cachedData = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__.appendUint8Array)(this.cachedData, partialData);
                        } else {
                          this.cachedData = partialData;
                        }
                      }
                    }
                    return {
                      audioTrack: track,
                      videoTrack: (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)(),
                      id3Track,
                      textTrack: (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)()
                    };
                  };
                  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
                    return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"));
                  };
                  _proto.flush = function flush(timeOffset) {
                    var cachedData = this.cachedData;
                    if (cachedData) {
                      this.cachedData = null;
                      this.demux(cachedData, 0);
                    }
                    return {
                      audioTrack: this._audioTrack,
                      videoTrack: (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)(),
                      id3Track: this._id3Track,
                      textTrack: (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)()
                    };
                  };
                  _proto.destroy = function destroy() {
                  };
                  return BaseAudioDemuxer2;
                }();
                var initPTSFn = function initPTSFn2(timestamp, timeOffset, initPTS) {
                  if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(timestamp)) {
                    return timestamp * 90;
                  }
                  return timeOffset * 9e4 + (initPTS || 0);
                };
                const __WEBPACK_DEFAULT_EXPORT__ = BaseAudioDemuxer;
              }
            ),
            /***/
            "./src/demux/chunk-cache.ts": (
              /*!**********************************!*\
                !*** ./src/demux/chunk-cache.ts ***!
                \**********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    ChunkCache
                  )
                  /* harmony export */
                });
                var ChunkCache = function() {
                  function ChunkCache2() {
                    this.chunks = [];
                    this.dataLength = 0;
                  }
                  var _proto = ChunkCache2.prototype;
                  _proto.push = function push(chunk) {
                    this.chunks.push(chunk);
                    this.dataLength += chunk.length;
                  };
                  _proto.flush = function flush() {
                    var chunks = this.chunks, dataLength = this.dataLength;
                    var result;
                    if (!chunks.length) {
                      return new Uint8Array(0);
                    } else if (chunks.length === 1) {
                      result = chunks[0];
                    } else {
                      result = concatUint8Arrays(chunks, dataLength);
                    }
                    this.reset();
                    return result;
                  };
                  _proto.reset = function reset() {
                    this.chunks.length = 0;
                    this.dataLength = 0;
                  };
                  return ChunkCache2;
                }();
                function concatUint8Arrays(chunks, dataLength) {
                  var result = new Uint8Array(dataLength);
                  var offset = 0;
                  for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    result.set(chunk, offset);
                    offset += chunk.length;
                  }
                  return result;
                }
              }
            ),
            /***/
            "./src/demux/dummy-demuxed-track.ts": (
              /*!******************************************!*\
                !*** ./src/demux/dummy-demuxed-track.ts ***!
                \******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "dummyTrack": () => (
                    /* binding */
                    dummyTrack
                  )
                  /* harmony export */
                });
                function dummyTrack(type, inputTimeScale) {
                  if (type === void 0) {
                    type = "";
                  }
                  if (inputTimeScale === void 0) {
                    inputTimeScale = 9e4;
                  }
                  return {
                    type,
                    id: -1,
                    pid: -1,
                    inputTimeScale,
                    sequenceNumber: -1,
                    samples: [],
                    dropped: 0
                  };
                }
              }
            ),
            /***/
            "./src/demux/exp-golomb.ts": (
              /*!*********************************!*\
                !*** ./src/demux/exp-golomb.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var ExpGolomb = function() {
                  function ExpGolomb2(data) {
                    this.data = void 0;
                    this.bytesAvailable = void 0;
                    this.word = void 0;
                    this.bitsAvailable = void 0;
                    this.data = data;
                    this.bytesAvailable = data.byteLength;
                    this.word = 0;
                    this.bitsAvailable = 0;
                  }
                  var _proto = ExpGolomb2.prototype;
                  _proto.loadWord = function loadWord() {
                    var data = this.data;
                    var bytesAvailable = this.bytesAvailable;
                    var position = data.byteLength - bytesAvailable;
                    var workingBytes = new Uint8Array(4);
                    var availableBytes = Math.min(4, bytesAvailable);
                    if (availableBytes === 0) {
                      throw new Error("no bytes available");
                    }
                    workingBytes.set(data.subarray(position, position + availableBytes));
                    this.word = new DataView(workingBytes.buffer).getUint32(0);
                    this.bitsAvailable = availableBytes * 8;
                    this.bytesAvailable -= availableBytes;
                  };
                  _proto.skipBits = function skipBits(count) {
                    var skipBytes;
                    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
                    if (this.bitsAvailable > count) {
                      this.word <<= count;
                      this.bitsAvailable -= count;
                    } else {
                      count -= this.bitsAvailable;
                      skipBytes = count >> 3;
                      count -= skipBytes << 3;
                      this.bytesAvailable -= skipBytes;
                      this.loadWord();
                      this.word <<= count;
                      this.bitsAvailable -= count;
                    }
                  };
                  _proto.readBits = function readBits(size) {
                    var bits = Math.min(this.bitsAvailable, size);
                    var valu = this.word >>> 32 - bits;
                    if (size > 32) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.error("Cannot read more than 32 bits at a time");
                    }
                    this.bitsAvailable -= bits;
                    if (this.bitsAvailable > 0) {
                      this.word <<= bits;
                    } else if (this.bytesAvailable > 0) {
                      this.loadWord();
                    } else {
                      throw new Error("no bits available");
                    }
                    bits = size - bits;
                    if (bits > 0 && this.bitsAvailable) {
                      return valu << bits | this.readBits(bits);
                    } else {
                      return valu;
                    }
                  };
                  _proto.skipLZ = function skipLZ() {
                    var leadingZeroCount;
                    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
                      if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
                        this.word <<= leadingZeroCount;
                        this.bitsAvailable -= leadingZeroCount;
                        return leadingZeroCount;
                      }
                    }
                    this.loadWord();
                    return leadingZeroCount + this.skipLZ();
                  };
                  _proto.skipUEG = function skipUEG() {
                    this.skipBits(1 + this.skipLZ());
                  };
                  _proto.skipEG = function skipEG() {
                    this.skipBits(1 + this.skipLZ());
                  };
                  _proto.readUEG = function readUEG() {
                    var clz = this.skipLZ();
                    return this.readBits(clz + 1) - 1;
                  };
                  _proto.readEG = function readEG() {
                    var valu = this.readUEG();
                    if (1 & valu) {
                      return 1 + valu >>> 1;
                    } else {
                      return -1 * (valu >>> 1);
                    }
                  };
                  _proto.readBoolean = function readBoolean() {
                    return this.readBits(1) === 1;
                  };
                  _proto.readUByte = function readUByte() {
                    return this.readBits(8);
                  };
                  _proto.readUShort = function readUShort() {
                    return this.readBits(16);
                  };
                  _proto.readUInt = function readUInt() {
                    return this.readBits(32);
                  };
                  _proto.skipScalingList = function skipScalingList(count) {
                    var lastScale = 8;
                    var nextScale = 8;
                    var deltaScale;
                    for (var j = 0; j < count; j++) {
                      if (nextScale !== 0) {
                        deltaScale = this.readEG();
                        nextScale = (lastScale + deltaScale + 256) % 256;
                      }
                      lastScale = nextScale === 0 ? lastScale : nextScale;
                    }
                  };
                  _proto.readSPS = function readSPS() {
                    var frameCropLeftOffset = 0;
                    var frameCropRightOffset = 0;
                    var frameCropTopOffset = 0;
                    var frameCropBottomOffset = 0;
                    var numRefFramesInPicOrderCntCycle;
                    var scalingListCount;
                    var i;
                    var readUByte = this.readUByte.bind(this);
                    var readBits = this.readBits.bind(this);
                    var readUEG = this.readUEG.bind(this);
                    var readBoolean = this.readBoolean.bind(this);
                    var skipBits = this.skipBits.bind(this);
                    var skipEG = this.skipEG.bind(this);
                    var skipUEG = this.skipUEG.bind(this);
                    var skipScalingList = this.skipScalingList.bind(this);
                    readUByte();
                    var profileIdc = readUByte();
                    readBits(5);
                    skipBits(3);
                    readUByte();
                    skipUEG();
                    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
                      var chromaFormatIdc = readUEG();
                      if (chromaFormatIdc === 3) {
                        skipBits(1);
                      }
                      skipUEG();
                      skipUEG();
                      skipBits(1);
                      if (readBoolean()) {
                        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
                        for (i = 0; i < scalingListCount; i++) {
                          if (readBoolean()) {
                            if (i < 6) {
                              skipScalingList(16);
                            } else {
                              skipScalingList(64);
                            }
                          }
                        }
                      }
                    }
                    skipUEG();
                    var picOrderCntType = readUEG();
                    if (picOrderCntType === 0) {
                      readUEG();
                    } else if (picOrderCntType === 1) {
                      skipBits(1);
                      skipEG();
                      skipEG();
                      numRefFramesInPicOrderCntCycle = readUEG();
                      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
                        skipEG();
                      }
                    }
                    skipUEG();
                    skipBits(1);
                    var picWidthInMbsMinus1 = readUEG();
                    var picHeightInMapUnitsMinus1 = readUEG();
                    var frameMbsOnlyFlag = readBits(1);
                    if (frameMbsOnlyFlag === 0) {
                      skipBits(1);
                    }
                    skipBits(1);
                    if (readBoolean()) {
                      frameCropLeftOffset = readUEG();
                      frameCropRightOffset = readUEG();
                      frameCropTopOffset = readUEG();
                      frameCropBottomOffset = readUEG();
                    }
                    var pixelRatio = [1, 1];
                    if (readBoolean()) {
                      if (readBoolean()) {
                        var aspectRatioIdc = readUByte();
                        switch (aspectRatioIdc) {
                          case 1:
                            pixelRatio = [1, 1];
                            break;
                          case 2:
                            pixelRatio = [12, 11];
                            break;
                          case 3:
                            pixelRatio = [10, 11];
                            break;
                          case 4:
                            pixelRatio = [16, 11];
                            break;
                          case 5:
                            pixelRatio = [40, 33];
                            break;
                          case 6:
                            pixelRatio = [24, 11];
                            break;
                          case 7:
                            pixelRatio = [20, 11];
                            break;
                          case 8:
                            pixelRatio = [32, 11];
                            break;
                          case 9:
                            pixelRatio = [80, 33];
                            break;
                          case 10:
                            pixelRatio = [18, 11];
                            break;
                          case 11:
                            pixelRatio = [15, 11];
                            break;
                          case 12:
                            pixelRatio = [64, 33];
                            break;
                          case 13:
                            pixelRatio = [160, 99];
                            break;
                          case 14:
                            pixelRatio = [4, 3];
                            break;
                          case 15:
                            pixelRatio = [3, 2];
                            break;
                          case 16:
                            pixelRatio = [2, 1];
                            break;
                          case 255: {
                            pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                            break;
                          }
                        }
                      }
                    }
                    return {
                      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
                      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
                      pixelRatio
                    };
                  };
                  _proto.readSliceType = function readSliceType() {
                    this.readUByte();
                    this.readUEG();
                    return this.readUEG();
                  };
                  return ExpGolomb2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = ExpGolomb;
              }
            ),
            /***/
            "./src/demux/id3.ts": (
              /*!**************************!*\
                !*** ./src/demux/id3.ts ***!
                \**************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "canParse": () => (
                    /* binding */
                    canParse
                  ),
                  /* harmony export */
                  "decodeFrame": () => (
                    /* binding */
                    decodeFrame
                  ),
                  /* harmony export */
                  "getID3Data": () => (
                    /* binding */
                    getID3Data
                  ),
                  /* harmony export */
                  "getID3Frames": () => (
                    /* binding */
                    getID3Frames
                  ),
                  /* harmony export */
                  "getTimeStamp": () => (
                    /* binding */
                    getTimeStamp
                  ),
                  /* harmony export */
                  "isFooter": () => (
                    /* binding */
                    isFooter
                  ),
                  /* harmony export */
                  "isHeader": () => (
                    /* binding */
                    isHeader
                  ),
                  /* harmony export */
                  "isTimeStampFrame": () => (
                    /* binding */
                    isTimeStampFrame
                  ),
                  /* harmony export */
                  "testables": () => (
                    /* binding */
                    testables
                  ),
                  /* harmony export */
                  "utf8ArrayToStr": () => (
                    /* binding */
                    utf8ArrayToStr
                  )
                  /* harmony export */
                });
                var isHeader = function isHeader2(data, offset) {
                  if (offset + 10 <= data.length) {
                    if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
                      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                          return true;
                        }
                      }
                    }
                  }
                  return false;
                };
                var isFooter = function isFooter2(data, offset) {
                  if (offset + 10 <= data.length) {
                    if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
                      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                          return true;
                        }
                      }
                    }
                  }
                  return false;
                };
                var getID3Data = function getID3Data2(data, offset) {
                  var front = offset;
                  var length = 0;
                  while (isHeader(data, offset)) {
                    length += 10;
                    var size = readSize(data, offset + 6);
                    length += size;
                    if (isFooter(data, offset + 10)) {
                      length += 10;
                    }
                    offset += length;
                  }
                  if (length > 0) {
                    return data.subarray(front, front + length);
                  }
                  return void 0;
                };
                var readSize = function readSize2(data, offset) {
                  var size = 0;
                  size = (data[offset] & 127) << 21;
                  size |= (data[offset + 1] & 127) << 14;
                  size |= (data[offset + 2] & 127) << 7;
                  size |= data[offset + 3] & 127;
                  return size;
                };
                var canParse = function canParse2(data, offset) {
                  return isHeader(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
                };
                var getTimeStamp = function getTimeStamp2(data) {
                  var frames = getID3Frames(data);
                  for (var i = 0; i < frames.length; i++) {
                    var frame = frames[i];
                    if (isTimeStampFrame(frame)) {
                      return readTimeStamp(frame);
                    }
                  }
                  return void 0;
                };
                var isTimeStampFrame = function isTimeStampFrame2(frame) {
                  return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
                };
                var getFrameData = function getFrameData2(data) {
                  var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
                  var size = readSize(data, 4);
                  var offset = 10;
                  return {
                    type,
                    size,
                    data: data.subarray(offset, offset + size)
                  };
                };
                var getID3Frames = function getID3Frames2(id3Data) {
                  var offset = 0;
                  var frames = [];
                  while (isHeader(id3Data, offset)) {
                    var size = readSize(id3Data, offset + 6);
                    offset += 10;
                    var end = offset + size;
                    while (offset + 8 < end) {
                      var frameData = getFrameData(id3Data.subarray(offset));
                      var frame = decodeFrame(frameData);
                      if (frame) {
                        frames.push(frame);
                      }
                      offset += frameData.size + 10;
                    }
                    if (isFooter(id3Data, offset)) {
                      offset += 10;
                    }
                  }
                  return frames;
                };
                var decodeFrame = function decodeFrame2(frame) {
                  if (frame.type === "PRIV") {
                    return decodePrivFrame(frame);
                  } else if (frame.type[0] === "W") {
                    return decodeURLFrame(frame);
                  }
                  return decodeTextFrame(frame);
                };
                var decodePrivFrame = function decodePrivFrame2(frame) {
                  if (frame.size < 2) {
                    return void 0;
                  }
                  var owner = utf8ArrayToStr(frame.data, true);
                  var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
                  return {
                    key: frame.type,
                    info: owner,
                    data: privateData.buffer
                  };
                };
                var decodeTextFrame = function decodeTextFrame2(frame) {
                  if (frame.size < 2) {
                    return void 0;
                  }
                  if (frame.type === "TXXX") {
                    var index = 1;
                    var description = utf8ArrayToStr(frame.data.subarray(index), true);
                    index += description.length + 1;
                    var value = utf8ArrayToStr(frame.data.subarray(index));
                    return {
                      key: frame.type,
                      info: description,
                      data: value
                    };
                  }
                  var text = utf8ArrayToStr(frame.data.subarray(1));
                  return {
                    key: frame.type,
                    data: text
                  };
                };
                var decodeURLFrame = function decodeURLFrame2(frame) {
                  if (frame.type === "WXXX") {
                    if (frame.size < 2) {
                      return void 0;
                    }
                    var index = 1;
                    var description = utf8ArrayToStr(frame.data.subarray(index), true);
                    index += description.length + 1;
                    var value = utf8ArrayToStr(frame.data.subarray(index));
                    return {
                      key: frame.type,
                      info: description,
                      data: value
                    };
                  }
                  var url = utf8ArrayToStr(frame.data);
                  return {
                    key: frame.type,
                    data: url
                  };
                };
                var readTimeStamp = function readTimeStamp2(timeStampFrame) {
                  if (timeStampFrame.data.byteLength === 8) {
                    var data = new Uint8Array(timeStampFrame.data);
                    var pts33Bit = data[3] & 1;
                    var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
                    timestamp /= 45;
                    if (pts33Bit) {
                      timestamp += 4772185884e-2;
                    }
                    return Math.round(timestamp);
                  }
                  return void 0;
                };
                var utf8ArrayToStr = function utf8ArrayToStr2(array, exitOnNull) {
                  if (exitOnNull === void 0) {
                    exitOnNull = false;
                  }
                  var decoder2 = getTextDecoder();
                  if (decoder2) {
                    var decoded = decoder2.decode(array);
                    if (exitOnNull) {
                      var idx = decoded.indexOf("\0");
                      return idx !== -1 ? decoded.substring(0, idx) : decoded;
                    }
                    return decoded.replace(/\0/g, "");
                  }
                  var len = array.length;
                  var c;
                  var char2;
                  var char3;
                  var out = "";
                  var i = 0;
                  while (i < len) {
                    c = array[i++];
                    if (c === 0 && exitOnNull) {
                      return out;
                    } else if (c === 0 || c === 3) {
                      continue;
                    }
                    switch (c >> 4) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                        out += String.fromCharCode(c);
                        break;
                      case 12:
                      case 13:
                        char2 = array[i++];
                        out += String.fromCharCode((c & 31) << 6 | char2 & 63);
                        break;
                      case 14:
                        char2 = array[i++];
                        char3 = array[i++];
                        out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
                        break;
                      default:
                    }
                  }
                  return out;
                };
                var testables = {
                  decodeTextFrame
                };
                var decoder;
                function getTextDecoder() {
                  if (!decoder && typeof self.TextDecoder !== "undefined") {
                    decoder = new self.TextDecoder("utf-8");
                  }
                  return decoder;
                }
              }
            ),
            /***/
            "./src/demux/mp3demuxer.ts": (
              /*!*********************************!*\
                !*** ./src/demux/mp3demuxer.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./base-audio-demuxer */
                  "./src/demux/base-audio-demuxer.ts"
                );
                var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../demux/id3 */
                  "./src/demux/id3.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _mpegaudio__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./mpegaudio */
                  "./src/demux/mpegaudio.ts"
                );
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var MP3Demuxer = function(_BaseAudioDemuxer) {
                  _inheritsLoose(MP3Demuxer2, _BaseAudioDemuxer);
                  function MP3Demuxer2() {
                    return _BaseAudioDemuxer.apply(this, arguments) || this;
                  }
                  var _proto = MP3Demuxer2.prototype;
                  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
                    this._audioTrack = {
                      container: "audio/mpeg",
                      type: "audio",
                      id: 2,
                      pid: -1,
                      sequenceNumber: 0,
                      segmentCodec: "mp3",
                      samples: [],
                      manifestCodec: audioCodec,
                      duration: trackDuration,
                      inputTimeScale: 9e4,
                      dropped: 0
                    };
                  };
                  MP3Demuxer2.probe = function probe(data) {
                    if (!data) {
                      return false;
                    }
                    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__.getID3Data(data, 0) || [];
                    var offset = id3Data.length;
                    for (var length = data.length; offset < length; offset++) {
                      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_3__.probe(data, offset)) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.log("MPEG Audio sync word found !");
                        return true;
                      }
                    }
                    return false;
                  };
                  _proto.canParse = function canParse(data, offset) {
                    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__.canParse(data, offset);
                  };
                  _proto.appendFrame = function appendFrame(track, data, offset) {
                    if (this.basePTS === null) {
                      return;
                    }
                    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__.appendFrame(track, data, offset, this.basePTS, this.frameIndex);
                  };
                  return MP3Demuxer2;
                }(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__["default"]);
                const __WEBPACK_DEFAULT_EXPORT__ = MP3Demuxer;
              }
            ),
            /***/
            "./src/demux/mp4demuxer.ts": (
              /*!*********************************!*\
                !*** ./src/demux/mp4demuxer.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../types/demuxer */
                  "./src/types/demuxer.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./dummy-demuxed-track */
                  "./src/demux/dummy-demuxed-track.ts"
                );
                var emsgSchemePattern = /\/emsg[-/]ID3/i;
                var MP4Demuxer = function() {
                  function MP4Demuxer2(observer, config) {
                    this.remainderData = null;
                    this.timeOffset = 0;
                    this.config = void 0;
                    this.videoTrack = void 0;
                    this.audioTrack = void 0;
                    this.id3Track = void 0;
                    this.txtTrack = void 0;
                    this.config = config;
                  }
                  var _proto = MP4Demuxer2.prototype;
                  _proto.resetTimeStamp = function resetTimeStamp() {
                  };
                  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                    var videoTrack = this.videoTrack = (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)("video", 1);
                    var audioTrack = this.audioTrack = (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)("audio", 1);
                    var captionTrack = this.txtTrack = (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)("text", 1);
                    this.id3Track = (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)("id3", 1);
                    this.timeOffset = 0;
                    if (!initSegment || !initSegment.byteLength) {
                      return;
                    }
                    var initData = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseInitSegment)(initSegment);
                    if (initData.video) {
                      var _initData$video = initData.video, id = _initData$video.id, timescale = _initData$video.timescale, codec = _initData$video.codec;
                      videoTrack.id = id;
                      videoTrack.timescale = captionTrack.timescale = timescale;
                      videoTrack.codec = codec;
                    }
                    if (initData.audio) {
                      var _initData$audio = initData.audio, _id = _initData$audio.id, _timescale = _initData$audio.timescale, _codec = _initData$audio.codec;
                      audioTrack.id = _id;
                      audioTrack.timescale = _timescale;
                      audioTrack.codec = _codec;
                    }
                    captionTrack.id = _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.RemuxerTrackIdConfig.text;
                    videoTrack.sampleDuration = 0;
                    videoTrack.duration = audioTrack.duration = trackDuration;
                  };
                  _proto.resetContiguity = function resetContiguity() {
                  };
                  MP4Demuxer2.probe = function probe(data) {
                    data = data.length > 16384 ? data.subarray(0, 16384) : data;
                    return (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.findBox)(data, ["moof"]).length > 0;
                  };
                  _proto.demux = function demux(data, timeOffset) {
                    this.timeOffset = timeOffset;
                    var videoSamples = data;
                    var videoTrack = this.videoTrack;
                    var textTrack = this.txtTrack;
                    if (this.config.progressive) {
                      if (this.remainderData) {
                        videoSamples = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.appendUint8Array)(this.remainderData, data);
                      }
                      var segmentedData = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.segmentValidRange)(videoSamples);
                      this.remainderData = segmentedData.remainder;
                      videoTrack.samples = segmentedData.valid || new Uint8Array();
                    } else {
                      videoTrack.samples = videoSamples;
                    }
                    var id3Track = this.extractID3Track(videoTrack, timeOffset);
                    textTrack.samples = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseSamples)(timeOffset, videoTrack);
                    return {
                      videoTrack,
                      audioTrack: this.audioTrack,
                      id3Track,
                      textTrack: this.txtTrack
                    };
                  };
                  _proto.flush = function flush() {
                    var timeOffset = this.timeOffset;
                    var videoTrack = this.videoTrack;
                    var textTrack = this.txtTrack;
                    videoTrack.samples = this.remainderData || new Uint8Array();
                    this.remainderData = null;
                    var id3Track = this.extractID3Track(videoTrack, this.timeOffset);
                    textTrack.samples = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseSamples)(timeOffset, videoTrack);
                    return {
                      videoTrack,
                      audioTrack: (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)(),
                      id3Track,
                      textTrack: (0, _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__.dummyTrack)()
                    };
                  };
                  _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {
                    var id3Track = this.id3Track;
                    if (videoTrack.samples.length) {
                      var emsgs = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.findBox)(videoTrack.samples, ["emsg"]);
                      if (emsgs) {
                        emsgs.forEach(function(data) {
                          var emsgInfo = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseEmsg)(data);
                          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
                            var pts = (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
                            var duration = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
                            if (duration <= 1e-3) {
                              duration = Number.POSITIVE_INFINITY;
                            }
                            var payload = emsgInfo.payload;
                            id3Track.samples.push({
                              data: payload,
                              len: payload.byteLength,
                              dts: pts,
                              pts,
                              type: _types_demuxer__WEBPACK_IMPORTED_MODULE_1__.MetadataSchema.emsg,
                              duration
                            });
                          }
                        });
                      }
                    }
                    return id3Track;
                  };
                  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
                    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
                  };
                  _proto.destroy = function destroy() {
                  };
                  return MP4Demuxer2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = MP4Demuxer;
              }
            ),
            /***/
            "./src/demux/mpegaudio.ts": (
              /*!********************************!*\
                !*** ./src/demux/mpegaudio.ts ***!
                \********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "appendFrame": () => (
                    /* binding */
                    appendFrame
                  ),
                  /* harmony export */
                  "canParse": () => (
                    /* binding */
                    canParse
                  ),
                  /* harmony export */
                  "isHeader": () => (
                    /* binding */
                    isHeader
                  ),
                  /* harmony export */
                  "isHeaderPattern": () => (
                    /* binding */
                    isHeaderPattern
                  ),
                  /* harmony export */
                  "parseHeader": () => (
                    /* binding */
                    parseHeader
                  ),
                  /* harmony export */
                  "probe": () => (
                    /* binding */
                    probe
                  )
                  /* harmony export */
                });
                var chromeVersion = null;
                var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
                var SamplingRateMap = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
                var SamplesCoefficients = [
                  // MPEG 2.5
                  [
                    0,
                    // Reserved
                    72,
                    // Layer3
                    144,
                    // Layer2
                    12
                    // Layer1
                  ],
                  // Reserved
                  [
                    0,
                    // Reserved
                    0,
                    // Layer3
                    0,
                    // Layer2
                    0
                    // Layer1
                  ],
                  // MPEG 2
                  [
                    0,
                    // Reserved
                    72,
                    // Layer3
                    144,
                    // Layer2
                    12
                    // Layer1
                  ],
                  // MPEG 1
                  [
                    0,
                    // Reserved
                    144,
                    // Layer3
                    144,
                    // Layer2
                    12
                    // Layer1
                  ]
                ];
                var BytesInSlot = [
                  0,
                  // Reserved
                  1,
                  // Layer3
                  1,
                  // Layer2
                  4
                  // Layer1
                ];
                function appendFrame(track, data, offset, pts, frameIndex) {
                  if (offset + 24 > data.length) {
                    return;
                  }
                  var header = parseHeader(data, offset);
                  if (header && offset + header.frameLength <= data.length) {
                    var frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
                    var stamp = pts + frameIndex * frameDuration;
                    var sample = {
                      unit: data.subarray(offset, offset + header.frameLength),
                      pts: stamp,
                      dts: stamp
                    };
                    track.config = [];
                    track.channelCount = header.channelCount;
                    track.samplerate = header.sampleRate;
                    track.samples.push(sample);
                    return {
                      sample,
                      length: header.frameLength,
                      missing: 0
                    };
                  }
                }
                function parseHeader(data, offset) {
                  var mpegVersion = data[offset + 1] >> 3 & 3;
                  var mpegLayer = data[offset + 1] >> 1 & 3;
                  var bitRateIndex = data[offset + 2] >> 4 & 15;
                  var sampleRateIndex = data[offset + 2] >> 2 & 3;
                  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
                    var paddingBit = data[offset + 2] >> 1 & 1;
                    var channelMode = data[offset + 3] >> 6;
                    var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
                    var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
                    var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
                    var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
                    var channelCount = channelMode === 3 ? 1 : 2;
                    var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
                    var bytesInSlot = BytesInSlot[mpegLayer];
                    var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
                    var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
                    if (chromeVersion === null) {
                      var userAgent = navigator.userAgent || "";
                      var result = userAgent.match(/Chrome\/(\d+)/i);
                      chromeVersion = result ? parseInt(result[1]) : 0;
                    }
                    var needChromeFix = !!chromeVersion && chromeVersion <= 87;
                    if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
                      data[offset + 3] = data[offset + 3] | 128;
                    }
                    return {
                      sampleRate,
                      channelCount,
                      frameLength,
                      samplesPerFrame
                    };
                  }
                }
                function isHeaderPattern(data, offset) {
                  return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
                }
                function isHeader(data, offset) {
                  return offset + 1 < data.length && isHeaderPattern(data, offset);
                }
                function canParse(data, offset) {
                  var headerSize = 4;
                  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
                }
                function probe(data, offset) {
                  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
                    var headerLength = 4;
                    var header = parseHeader(data, offset);
                    var frameLength = headerLength;
                    if (header !== null && header !== void 0 && header.frameLength) {
                      frameLength = header.frameLength;
                    }
                    var newOffset = offset + frameLength;
                    return newOffset === data.length || isHeader(data, newOffset);
                  }
                  return false;
                }
              }
            ),
            /***/
            "./src/demux/sample-aes.ts": (
              /*!*********************************!*\
                !*** ./src/demux/sample-aes.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../crypt/decrypter */
                  "./src/crypt/decrypter.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var SampleAesDecrypter = function() {
                  function SampleAesDecrypter2(observer, config, keyData) {
                    this.keyData = void 0;
                    this.decrypter = void 0;
                    this.keyData = keyData;
                    this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__["default"](config, {
                      removePKCS7Padding: false
                    });
                  }
                  var _proto = SampleAesDecrypter2.prototype;
                  _proto.decryptBuffer = function decryptBuffer(encryptedData) {
                    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);
                  };
                  _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {
                    var _this = this;
                    var curUnit = samples[sampleIndex].unit;
                    if (curUnit.length <= 16) {
                      return;
                    }
                    var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
                    var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
                    this.decryptBuffer(encryptedBuffer).then(function(decryptedBuffer) {
                      var decryptedData = new Uint8Array(decryptedBuffer);
                      curUnit.set(decryptedData, 16);
                      if (!_this.decrypter.isSync()) {
                        _this.decryptAacSamples(samples, sampleIndex + 1, callback);
                      }
                    });
                  };
                  _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
                    for (; ; sampleIndex++) {
                      if (sampleIndex >= samples.length) {
                        callback();
                        return;
                      }
                      if (samples[sampleIndex].unit.length < 32) {
                        continue;
                      }
                      this.decryptAacSample(samples, sampleIndex, callback);
                      if (!this.decrypter.isSync()) {
                        return;
                      }
                    }
                  };
                  _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
                    var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
                    var encryptedData = new Int8Array(encryptedDataLen);
                    var outputPos = 0;
                    for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
                      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
                    }
                    return encryptedData;
                  };
                  _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
                    var uint8DecryptedData = new Uint8Array(decryptedData);
                    var inputPos = 0;
                    for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
                      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
                    }
                    return decodedData;
                  };
                  _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
                    var _this2 = this;
                    var decodedData = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__.discardEPB)(curUnit.data);
                    var encryptedData = this.getAvcEncryptedData(decodedData);
                    this.decryptBuffer(encryptedData.buffer).then(function(decryptedBuffer) {
                      curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);
                      if (!_this2.decrypter.isSync()) {
                        _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
                      }
                    });
                  };
                  _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
                    if (samples instanceof Uint8Array) {
                      throw new Error("Cannot decrypt samples of type Uint8Array");
                    }
                    for (; ; sampleIndex++, unitIndex = 0) {
                      if (sampleIndex >= samples.length) {
                        callback();
                        return;
                      }
                      var curUnits = samples[sampleIndex].units;
                      for (; ; unitIndex++) {
                        if (unitIndex >= curUnits.length) {
                          break;
                        }
                        var curUnit = curUnits[unitIndex];
                        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
                          continue;
                        }
                        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
                        if (!this.decrypter.isSync()) {
                          return;
                        }
                      }
                    }
                  };
                  return SampleAesDecrypter2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = SampleAesDecrypter;
              }
            ),
            /***/
            "./src/demux/transmuxer-interface.ts": (
              /*!*******************************************!*\
                !*** ./src/demux/transmuxer-interface.ts ***!
                \*******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    TransmuxerInterface
                  )
                  /* harmony export */
                });
                var _webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./webworkify-webpack */
                  "./src/demux/webworkify-webpack.js"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../demux/transmuxer */
                  "./src/demux/transmuxer.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/mediasource-helper */
                  "./src/utils/mediasource-helper.ts"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! eventemitter3 */
                  "./node_modules/eventemitter3/index.js"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__2.n(eventemitter3__WEBPACK_IMPORTED_MODULE_6__);
                var MediaSource2 = (0, _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__.getMediaSource)() || {
                  isTypeSupported: function isTypeSupported() {
                    return false;
                  }
                };
                var TransmuxerInterface = function() {
                  function TransmuxerInterface2(hls, id, onTransmuxComplete, onFlush) {
                    var _this = this;
                    this.hls = void 0;
                    this.id = void 0;
                    this.observer = void 0;
                    this.frag = null;
                    this.part = null;
                    this.useWorker = void 0;
                    this.worker = void 0;
                    this.onwmsg = void 0;
                    this.transmuxer = null;
                    this.onTransmuxComplete = void 0;
                    this.onFlush = void 0;
                    var config = hls.config;
                    this.hls = hls;
                    this.id = id;
                    this.useWorker = !!config.enableWorker;
                    this.onTransmuxComplete = onTransmuxComplete;
                    this.onFlush = onFlush;
                    var forwardMessage = function forwardMessage2(ev, data) {
                      data = data || {};
                      data.frag = _this.frag;
                      data.id = _this.id;
                      _this.hls.trigger(ev, data);
                    };
                    this.observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__.EventEmitter();
                    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, forwardMessage);
                    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, forwardMessage);
                    var typeSupported = {
                      mp4: MediaSource2.isTypeSupported("video/mp4"),
                      mpeg: MediaSource2.isTypeSupported("audio/mpeg"),
                      mp3: MediaSource2.isTypeSupported('audio/mp4; codecs="mp3"')
                    };
                    var vendor = navigator.vendor;
                    if (this.useWorker && typeof Worker !== "undefined") {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log("demuxing in webworker");
                      var worker;
                      try {
                        worker = this.worker = (0, _webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__["default"])(
                          /*require.resolve*/
                          /*! ../demux/transmuxer-worker.ts */
                          "./src/demux/transmuxer-worker.ts"
                        );
                        this.onwmsg = this.onWorkerMessage.bind(this);
                        worker.addEventListener("message", this.onwmsg);
                        worker.onerror = function(event) {
                          _this.useWorker = false;
                          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Exception in webworker, fallback to inline");
                          _this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.OTHER_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.INTERNAL_EXCEPTION,
                            fatal: false,
                            event: "demuxerWorker",
                            error: new Error(event.message + "  (" + event.filename + ":" + event.lineno + ")")
                          });
                        };
                        worker.postMessage({
                          cmd: "init",
                          typeSupported,
                          vendor,
                          id,
                          config: JSON.stringify(config)
                        });
                      } catch (err) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("Error in worker:", err);
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error("Error while initializing DemuxerWorker, fallback to inline");
                        if (worker) {
                          self.URL.revokeObjectURL(worker.objectURL);
                        }
                        this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, typeSupported, config, vendor, id);
                        this.worker = null;
                      }
                    } else {
                      this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, typeSupported, config, vendor, id);
                    }
                  }
                  var _proto = TransmuxerInterface2.prototype;
                  _proto.destroy = function destroy() {
                    var w = this.worker;
                    if (w) {
                      w.removeEventListener("message", this.onwmsg);
                      w.terminate();
                      this.worker = null;
                      this.onwmsg = void 0;
                    } else {
                      var transmuxer = this.transmuxer;
                      if (transmuxer) {
                        transmuxer.destroy();
                        this.transmuxer = null;
                      }
                    }
                    var observer = this.observer;
                    if (observer) {
                      observer.removeAllListeners();
                    }
                    this.frag = null;
                    this.observer = null;
                    this.hls = null;
                  };
                  _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
                    var _frag$initSegment, _lastFrag$initSegment, _this2 = this;
                    chunkMeta.transmuxing.start = self.performance.now();
                    var transmuxer = this.transmuxer, worker = this.worker;
                    var timeOffset = part ? part.start : frag.start;
                    var decryptdata = frag.decryptdata;
                    var lastFrag = this.frag;
                    var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
                    var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
                    var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
                    var partDiff = this.part ? chunkMeta.part - this.part.index : -1;
                    var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag === null || lastFrag === void 0 ? void 0 : lastFrag.stats.chunkCount);
                    var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
                    var now = self.performance.now();
                    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
                      frag.stats.parsing.start = now;
                    }
                    if (part && (partDiff || !contiguous)) {
                      part.stats.parsing.start = now;
                    }
                    var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) === null || _lastFrag$initSegment === void 0 ? void 0 : _lastFrag$initSegment.url));
                    var state = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
                    if (!contiguous || discontinuity || initSegmentChange) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log("[transmuxer-interface, " + frag.type + "]: Starting new transmux session for sn: " + chunkMeta.sn + " p: " + chunkMeta.part + " level: " + chunkMeta.level + " id: " + chunkMeta.id + "\n        discontinuity: " + discontinuity + "\n        trackSwitch: " + trackSwitch + "\n        contiguous: " + contiguous + "\n        accurateTimeOffset: " + accurateTimeOffset + "\n        timeOffset: " + timeOffset + "\n        initSegmentChange: " + initSegmentChange);
                      var config = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
                      this.configureTransmuxer(config);
                    }
                    this.frag = frag;
                    this.part = part;
                    if (worker) {
                      worker.postMessage({
                        cmd: "demux",
                        data,
                        decryptdata,
                        chunkMeta,
                        state
                      }, data instanceof ArrayBuffer ? [data] : []);
                    } else if (transmuxer) {
                      var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
                      if ((0, _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.isPromise)(_transmuxResult)) {
                        transmuxer.async = true;
                        _transmuxResult.then(function(data2) {
                          _this2.handleTransmuxComplete(data2);
                        }).catch(function(error) {
                          _this2.transmuxerError(error, chunkMeta, "transmuxer-interface push error");
                        });
                      } else {
                        transmuxer.async = false;
                        this.handleTransmuxComplete(_transmuxResult);
                      }
                    }
                  };
                  _proto.flush = function flush(chunkMeta) {
                    var _this3 = this;
                    chunkMeta.transmuxing.start = self.performance.now();
                    var transmuxer = this.transmuxer, worker = this.worker;
                    if (worker) {
                      1;
                      worker.postMessage({
                        cmd: "flush",
                        chunkMeta
                      });
                    } else if (transmuxer) {
                      var _transmuxResult2 = transmuxer.flush(chunkMeta);
                      var asyncFlush = (0, _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.isPromise)(_transmuxResult2);
                      if (asyncFlush || transmuxer.async) {
                        if (!(0, _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__.isPromise)(_transmuxResult2)) {
                          _transmuxResult2 = Promise.resolve(_transmuxResult2);
                        }
                        _transmuxResult2.then(function(data) {
                          _this3.handleFlushResult(data, chunkMeta);
                        }).catch(function(error) {
                          _this3.transmuxerError(error, chunkMeta, "transmuxer-interface flush error");
                        });
                      } else {
                        this.handleFlushResult(_transmuxResult2, chunkMeta);
                      }
                    }
                  };
                  _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {
                    if (!this.hls) {
                      return;
                    }
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                      type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MEDIA_ERROR,
                      details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.FRAG_PARSING_ERROR,
                      chunkMeta,
                      fatal: false,
                      error,
                      err: error,
                      reason
                    });
                  };
                  _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {
                    var _this4 = this;
                    results.forEach(function(result) {
                      _this4.handleTransmuxComplete(result);
                    });
                    this.onFlush(chunkMeta);
                  };
                  _proto.onWorkerMessage = function onWorkerMessage(ev) {
                    var data = ev.data;
                    var hls = this.hls;
                    switch (data.event) {
                      case "init": {
                        self.URL.revokeObjectURL(this.worker.objectURL);
                        break;
                      }
                      case "transmuxComplete": {
                        this.handleTransmuxComplete(data.data);
                        break;
                      }
                      case "flush": {
                        this.onFlush(data.data);
                        break;
                      }
                      case "workerLog":
                        if (_utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger[data.data.logType]) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger[data.data.logType](data.data.message);
                        }
                        break;
                      default: {
                        data.data = data.data || {};
                        data.data.frag = this.frag;
                        data.data.id = this.id;
                        hls.trigger(data.event, data.data);
                        break;
                      }
                    }
                  };
                  _proto.configureTransmuxer = function configureTransmuxer(config) {
                    var worker = this.worker, transmuxer = this.transmuxer;
                    if (worker) {
                      worker.postMessage({
                        cmd: "configure",
                        config
                      });
                    } else if (transmuxer) {
                      transmuxer.configure(config);
                    }
                  };
                  _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {
                    result.chunkMeta.transmuxing.end = self.performance.now();
                    this.onTransmuxComplete(result);
                  };
                  return TransmuxerInterface2;
                }();
              }
            ),
            /***/
            "./src/demux/transmuxer-worker.ts": (
              /*!****************************************!*\
                !*** ./src/demux/transmuxer-worker.ts ***!
                \****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    TransmuxerWorker
                  )
                  /* harmony export */
                });
                var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../demux/transmuxer */
                  "./src/demux/transmuxer.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! eventemitter3 */
                  "./node_modules/eventemitter3/index.js"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__2.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);
                var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                function TransmuxerWorker(self2) {
                  var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
                  var forwardMessage = function forwardMessage2(ev, data) {
                    self2.postMessage({
                      event: ev,
                      data
                    });
                  };
                  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.FRAG_DECRYPTED, forwardMessage);
                  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, forwardMessage);
                  var forwardWorkerLogs = function forwardWorkerLogs2() {
                    var _loop = function _loop2(logFn2) {
                      var func = function func2(message) {
                        forwardMessage("workerLog", {
                          logType: logFn2,
                          message
                        });
                      };
                      _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger[logFn2] = func;
                    };
                    for (var logFn in _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger) {
                      _loop(logFn);
                    }
                  };
                  self2.addEventListener("message", function(ev) {
                    var data = ev.data;
                    switch (data.cmd) {
                      case "init": {
                        var config = JSON.parse(data.config);
                        self2.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__["default"](observer, data.typeSupported, config, data.vendor, data.id);
                        (0, _utils_logger__WEBPACK_IMPORTED_MODULE_2__.enableLogs)(config.debug, data.id);
                        forwardWorkerLogs();
                        forwardMessage("init", null);
                        break;
                      }
                      case "configure": {
                        self2.transmuxer.configure(data.config);
                        break;
                      }
                      case "demux": {
                        var transmuxResult = self2.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);
                        if ((0, _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__.isPromise)(transmuxResult)) {
                          self2.transmuxer.async = true;
                          transmuxResult.then(function(data2) {
                            emitTransmuxComplete(self2, data2);
                          }).catch(function(error) {
                            forwardMessage(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                              type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MEDIA_ERROR,
                              details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.FRAG_PARSING_ERROR,
                              chunkMeta: data.chunkMeta,
                              fatal: false,
                              error,
                              err: error,
                              reason: "transmuxer-worker push error"
                            });
                          });
                        } else {
                          self2.transmuxer.async = false;
                          emitTransmuxComplete(self2, transmuxResult);
                        }
                        break;
                      }
                      case "flush": {
                        var id = data.chunkMeta;
                        var _transmuxResult = self2.transmuxer.flush(id);
                        var asyncFlush = (0, _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__.isPromise)(_transmuxResult);
                        if (asyncFlush || self2.transmuxer.async) {
                          if (!(0, _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__.isPromise)(_transmuxResult)) {
                            _transmuxResult = Promise.resolve(_transmuxResult);
                          }
                          _transmuxResult.then(function(results) {
                            handleFlushResult(self2, results, id);
                          }).catch(function(error) {
                            forwardMessage(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                              type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MEDIA_ERROR,
                              details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.FRAG_PARSING_ERROR,
                              chunkMeta: data.chunkMeta,
                              fatal: false,
                              error,
                              err: error,
                              reason: "transmuxer-worker flush error"
                            });
                          });
                        } else {
                          handleFlushResult(self2, _transmuxResult, id);
                        }
                        break;
                      }
                      default:
                        break;
                    }
                  });
                }
                function emitTransmuxComplete(self2, transmuxResult) {
                  if (isEmptyResult(transmuxResult.remuxResult)) {
                    return false;
                  }
                  var transferable = [];
                  var _transmuxResult$remux = transmuxResult.remuxResult, audio = _transmuxResult$remux.audio, video = _transmuxResult$remux.video;
                  if (audio) {
                    addToTransferable(transferable, audio);
                  }
                  if (video) {
                    addToTransferable(transferable, video);
                  }
                  self2.postMessage({
                    event: "transmuxComplete",
                    data: transmuxResult
                  }, transferable);
                  return true;
                }
                function addToTransferable(transferable, track) {
                  if (track.data1) {
                    transferable.push(track.data1.buffer);
                  }
                  if (track.data2) {
                    transferable.push(track.data2.buffer);
                  }
                }
                function handleFlushResult(self2, results, chunkMeta) {
                  var parsed = results.reduce(function(parsed2, result) {
                    return emitTransmuxComplete(self2, result) || parsed2;
                  }, false);
                  if (!parsed) {
                    self2.postMessage({
                      event: "transmuxComplete",
                      data: results[0]
                    });
                  }
                  self2.postMessage({
                    event: "flush",
                    data: chunkMeta
                  });
                }
                function isEmptyResult(remuxResult) {
                  return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;
                }
              }
            ),
            /***/
            "./src/demux/transmuxer.ts": (
              /*!*********************************!*\
                !*** ./src/demux/transmuxer.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "TransmuxConfig": () => (
                    /* binding */
                    TransmuxConfig
                  ),
                  /* harmony export */
                  "TransmuxState": () => (
                    /* binding */
                    TransmuxState
                  ),
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    Transmuxer
                  ),
                  /* harmony export */
                  "isPromise": () => (
                    /* binding */
                    isPromise
                  )
                  /* harmony export */
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../crypt/decrypter */
                  "./src/crypt/decrypter.ts"
                );
                var _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../demux/aacdemuxer */
                  "./src/demux/aacdemuxer.ts"
                );
                var _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../demux/mp4demuxer */
                  "./src/demux/mp4demuxer.ts"
                );
                var _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../demux/tsdemuxer */
                  "./src/demux/tsdemuxer.ts"
                );
                var _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../demux/mp3demuxer */
                  "./src/demux/mp3demuxer.ts"
                );
                var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../remux/mp4-remuxer */
                  "./src/remux/mp4-remuxer.ts"
                );
                var _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../remux/passthrough-remuxer */
                  "./src/remux/passthrough-remuxer.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var now;
                try {
                  now = self.performance.now.bind(self.performance);
                } catch (err) {
                  _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.debug("Unable to use Performance API on this environment");
                  now = self.Date.now;
                }
                var muxConfig = [{
                  demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__["default"],
                  remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__["default"]
                }, {
                  demux: _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__["default"],
                  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"]
                }, {
                  demux: _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__["default"],
                  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"]
                }, {
                  demux: _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__["default"],
                  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"]
                }];
                var Transmuxer = function() {
                  function Transmuxer2(observer, typeSupported, config, vendor, id) {
                    this.async = false;
                    this.observer = void 0;
                    this.typeSupported = void 0;
                    this.config = void 0;
                    this.vendor = void 0;
                    this.id = void 0;
                    this.demuxer = void 0;
                    this.remuxer = void 0;
                    this.decrypter = void 0;
                    this.probe = void 0;
                    this.decryptionPromise = null;
                    this.transmuxConfig = void 0;
                    this.currentTransmuxState = void 0;
                    this.observer = observer;
                    this.typeSupported = typeSupported;
                    this.config = config;
                    this.vendor = vendor;
                    this.id = id;
                  }
                  var _proto = Transmuxer2.prototype;
                  _proto.configure = function configure(transmuxConfig) {
                    this.transmuxConfig = transmuxConfig;
                    if (this.decrypter) {
                      this.decrypter.reset();
                    }
                  };
                  _proto.push = function push(data, decryptdata, chunkMeta, state) {
                    var _this = this;
                    var stats = chunkMeta.transmuxing;
                    stats.executeStart = now();
                    var uintData = new Uint8Array(data);
                    var currentTransmuxState = this.currentTransmuxState, transmuxConfig = this.transmuxConfig;
                    if (state) {
                      this.currentTransmuxState = state;
                    }
                    var _ref = state || currentTransmuxState, contiguous = _ref.contiguous, discontinuity = _ref.discontinuity, trackSwitch = _ref.trackSwitch, accurateTimeOffset = _ref.accurateTimeOffset, timeOffset = _ref.timeOffset, initSegmentChange = _ref.initSegmentChange;
                    var audioCodec = transmuxConfig.audioCodec, videoCodec = transmuxConfig.videoCodec, defaultInitPts = transmuxConfig.defaultInitPts, duration = transmuxConfig.duration, initSegmentData = transmuxConfig.initSegmentData;
                    var keyData = getEncryptionType(uintData, decryptdata);
                    if (keyData && keyData.method === "AES-128") {
                      var decrypter = this.getDecrypter();
                      if (decrypter.isSync()) {
                        var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
                        var loadingParts = chunkMeta.part > -1;
                        if (loadingParts) {
                          decryptedData = decrypter.flush();
                        }
                        if (!decryptedData) {
                          stats.executeEnd = now();
                          return emptyResult(chunkMeta);
                        }
                        uintData = new Uint8Array(decryptedData);
                      } else {
                        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function(decryptedData2) {
                          var result2 = _this.push(decryptedData2, null, chunkMeta);
                          _this.decryptionPromise = null;
                          return result2;
                        });
                        return this.decryptionPromise;
                      }
                    }
                    var resetMuxers = this.needsProbing(discontinuity, trackSwitch);
                    if (resetMuxers) {
                      this.configureTransmuxer(uintData);
                    }
                    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
                      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
                    }
                    if (discontinuity || initSegmentChange || resetMuxers) {
                      this.resetInitialTimestamp(defaultInitPts);
                    }
                    if (!contiguous) {
                      this.resetContiguity();
                    }
                    var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
                    var currentState = this.currentTransmuxState;
                    currentState.contiguous = true;
                    currentState.discontinuity = false;
                    currentState.trackSwitch = false;
                    stats.executeEnd = now();
                    return result;
                  };
                  _proto.flush = function flush(chunkMeta) {
                    var _this2 = this;
                    var stats = chunkMeta.transmuxing;
                    stats.executeStart = now();
                    var decrypter = this.decrypter, currentTransmuxState = this.currentTransmuxState, decryptionPromise = this.decryptionPromise;
                    if (decryptionPromise) {
                      return decryptionPromise.then(function() {
                        return _this2.flush(chunkMeta);
                      });
                    }
                    var transmuxResults = [];
                    var timeOffset = currentTransmuxState.timeOffset;
                    if (decrypter) {
                      var decryptedData = decrypter.flush();
                      if (decryptedData) {
                        transmuxResults.push(this.push(decryptedData, null, chunkMeta));
                      }
                    }
                    var demuxer = this.demuxer, remuxer = this.remuxer;
                    if (!demuxer || !remuxer) {
                      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_0__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_PARSING_ERROR,
                        fatal: true,
                        reason: "no demux matching with content found"
                      });
                      stats.executeEnd = now();
                      return [emptyResult(chunkMeta)];
                    }
                    var demuxResultOrPromise = demuxer.flush(timeOffset);
                    if (isPromise(demuxResultOrPromise)) {
                      return demuxResultOrPromise.then(function(demuxResult) {
                        _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);
                        return transmuxResults;
                      });
                    }
                    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
                    return transmuxResults;
                  };
                  _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {
                    var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack, id3Track = demuxResult.id3Track, textTrack = demuxResult.textTrack;
                    var _this$currentTransmux = this.currentTransmuxState, accurateTimeOffset = _this$currentTransmux.accurateTimeOffset, timeOffset = _this$currentTransmux.timeOffset;
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("[transmuxer.ts]: Flushed fragment " + chunkMeta.sn + (chunkMeta.part > -1 ? " p: " + chunkMeta.part : "") + " of level " + chunkMeta.level);
                    var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
                    transmuxResults.push({
                      remuxResult,
                      chunkMeta
                    });
                    chunkMeta.transmuxing.executeEnd = now();
                  };
                  _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {
                    var demuxer = this.demuxer, remuxer = this.remuxer;
                    if (!demuxer || !remuxer) {
                      return;
                    }
                    demuxer.resetTimeStamp(defaultInitPts);
                    remuxer.resetTimeStamp(defaultInitPts);
                  };
                  _proto.resetContiguity = function resetContiguity() {
                    var demuxer = this.demuxer, remuxer = this.remuxer;
                    if (!demuxer || !remuxer) {
                      return;
                    }
                    demuxer.resetContiguity();
                    remuxer.resetNextTimestamp();
                  };
                  _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
                    var demuxer = this.demuxer, remuxer = this.remuxer;
                    if (!demuxer || !remuxer) {
                      return;
                    }
                    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
                    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
                  };
                  _proto.destroy = function destroy() {
                    if (this.demuxer) {
                      this.demuxer.destroy();
                      this.demuxer = void 0;
                    }
                    if (this.remuxer) {
                      this.remuxer.destroy();
                      this.remuxer = void 0;
                    }
                  };
                  _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
                    var result;
                    if (keyData && keyData.method === "SAMPLE-AES") {
                      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
                    } else {
                      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
                    }
                    return result;
                  };
                  _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
                    var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive), audioTrack = _demux.audioTrack, videoTrack = _demux.videoTrack, id3Track = _demux.id3Track, textTrack = _demux.textTrack;
                    var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
                    return {
                      remuxResult,
                      chunkMeta
                    };
                  };
                  _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
                    var _this3 = this;
                    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function(demuxResult) {
                      var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);
                      return {
                        remuxResult,
                        chunkMeta
                      };
                    });
                  };
                  _proto.configureTransmuxer = function configureTransmuxer(data) {
                    var config = this.config, observer = this.observer, typeSupported = this.typeSupported, vendor = this.vendor;
                    var mux;
                    for (var i = 0, len = muxConfig.length; i < len; i++) {
                      if (muxConfig[i].demux.probe(data)) {
                        mux = muxConfig[i];
                        break;
                      }
                    }
                    if (!mux) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough");
                      mux = {
                        demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__["default"],
                        remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__["default"]
                      };
                    }
                    var demuxer = this.demuxer;
                    var remuxer = this.remuxer;
                    var Remuxer = mux.remux;
                    var Demuxer = mux.demux;
                    if (!remuxer || !(remuxer instanceof Remuxer)) {
                      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
                    }
                    if (!demuxer || !(demuxer instanceof Demuxer)) {
                      this.demuxer = new Demuxer(observer, config, typeSupported);
                      this.probe = Demuxer.probe;
                    }
                  };
                  _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {
                    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
                  };
                  _proto.getDecrypter = function getDecrypter() {
                    var decrypter = this.decrypter;
                    if (!decrypter) {
                      decrypter = this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__["default"](this.config);
                    }
                    return decrypter;
                  };
                  return Transmuxer2;
                }();
                function getEncryptionType(data, decryptData) {
                  var encryptionType = null;
                  if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {
                    encryptionType = decryptData;
                  }
                  return encryptionType;
                }
                var emptyResult = function emptyResult2(chunkMeta) {
                  return {
                    remuxResult: {},
                    chunkMeta
                  };
                };
                function isPromise(p) {
                  return "then" in p && p.then instanceof Function;
                }
                var TransmuxConfig = function TransmuxConfig2(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
                  this.audioCodec = void 0;
                  this.videoCodec = void 0;
                  this.initSegmentData = void 0;
                  this.duration = void 0;
                  this.defaultInitPts = void 0;
                  this.audioCodec = audioCodec;
                  this.videoCodec = videoCodec;
                  this.initSegmentData = initSegmentData;
                  this.duration = duration;
                  this.defaultInitPts = defaultInitPts;
                };
                var TransmuxState = function TransmuxState2(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
                  this.discontinuity = void 0;
                  this.contiguous = void 0;
                  this.accurateTimeOffset = void 0;
                  this.trackSwitch = void 0;
                  this.timeOffset = void 0;
                  this.initSegmentChange = void 0;
                  this.discontinuity = discontinuity;
                  this.contiguous = contiguous;
                  this.accurateTimeOffset = accurateTimeOffset;
                  this.trackSwitch = trackSwitch;
                  this.timeOffset = timeOffset;
                  this.initSegmentChange = initSegmentChange;
                };
              }
            ),
            /***/
            "./src/demux/tsdemuxer.ts": (
              /*!********************************!*\
                !*** ./src/demux/tsdemuxer.ts ***!
                \********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _adts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./adts */
                  "./src/demux/adts.ts"
                );
                var _mpegaudio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./mpegaudio */
                  "./src/demux/mpegaudio.ts"
                );
                var _exp_golomb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./exp-golomb */
                  "./src/demux/exp-golomb.ts"
                );
                var _sample_aes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./sample-aes */
                  "./src/demux/sample-aes.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../types/demuxer */
                  "./src/types/demuxer.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                var PACKET_LENGTH = 188;
                var TSDemuxer = function() {
                  function TSDemuxer2(observer, config, typeSupported) {
                    this.observer = void 0;
                    this.config = void 0;
                    this.typeSupported = void 0;
                    this.sampleAes = null;
                    this.pmtParsed = false;
                    this.audioCodec = void 0;
                    this.videoCodec = void 0;
                    this._duration = 0;
                    this._pmtId = -1;
                    this._avcTrack = void 0;
                    this._audioTrack = void 0;
                    this._id3Track = void 0;
                    this._txtTrack = void 0;
                    this.aacOverFlow = null;
                    this.avcSample = null;
                    this.remainderData = null;
                    this.observer = observer;
                    this.config = config;
                    this.typeSupported = typeSupported;
                  }
                  TSDemuxer2.probe = function probe(data) {
                    var syncOffset = TSDemuxer2.syncOffset(data);
                    if (syncOffset > 0) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset);
                    }
                    return syncOffset !== -1;
                  };
                  TSDemuxer2.syncOffset = function syncOffset(data) {
                    var length = data.length;
                    var scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;
                    var i = 0;
                    while (i < scanwindow) {
                      var foundPat = false;
                      for (var j = i; j < length; j += PACKET_LENGTH) {
                        if (data[j] === 71) {
                          if (!foundPat && parsePID(data, j) === 0) {
                            foundPat = true;
                          }
                          if (foundPat && j + PACKET_LENGTH > scanwindow) {
                            return i;
                          }
                        } else {
                          break;
                        }
                      }
                      i++;
                    }
                    return -1;
                  };
                  TSDemuxer2.createTrack = function createTrack(type, duration) {
                    return {
                      container: type === "video" || type === "audio" ? "video/mp2t" : void 0,
                      type,
                      id: _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__.RemuxerTrackIdConfig[type],
                      pid: -1,
                      inputTimeScale: 9e4,
                      sequenceNumber: 0,
                      samples: [],
                      dropped: 0,
                      duration: type === "audio" ? duration : void 0
                    };
                  };
                  var _proto = TSDemuxer2.prototype;
                  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                    this.pmtParsed = false;
                    this._pmtId = -1;
                    this._avcTrack = TSDemuxer2.createTrack("video");
                    this._audioTrack = TSDemuxer2.createTrack("audio", trackDuration);
                    this._id3Track = TSDemuxer2.createTrack("id3");
                    this._txtTrack = TSDemuxer2.createTrack("text");
                    this._audioTrack.segmentCodec = "aac";
                    this.aacOverFlow = null;
                    this.avcSample = null;
                    this.remainderData = null;
                    this.audioCodec = audioCodec;
                    this.videoCodec = videoCodec;
                    this._duration = trackDuration;
                  };
                  _proto.resetTimeStamp = function resetTimeStamp() {
                  };
                  _proto.resetContiguity = function resetContiguity() {
                    var _audioTrack = this._audioTrack, _avcTrack = this._avcTrack, _id3Track = this._id3Track;
                    if (_audioTrack) {
                      _audioTrack.pesData = null;
                    }
                    if (_avcTrack) {
                      _avcTrack.pesData = null;
                    }
                    if (_id3Track) {
                      _id3Track.pesData = null;
                    }
                    this.aacOverFlow = null;
                    this.avcSample = null;
                    this.remainderData = null;
                  };
                  _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {
                    if (isSampleAes === void 0) {
                      isSampleAes = false;
                    }
                    if (flush === void 0) {
                      flush = false;
                    }
                    if (!isSampleAes) {
                      this.sampleAes = null;
                    }
                    var pes;
                    var videoTrack = this._avcTrack;
                    var audioTrack = this._audioTrack;
                    var id3Track = this._id3Track;
                    var textTrack = this._txtTrack;
                    var avcId = videoTrack.pid;
                    var avcData = videoTrack.pesData;
                    var audioId = audioTrack.pid;
                    var id3Id = id3Track.pid;
                    var audioData = audioTrack.pesData;
                    var id3Data = id3Track.pesData;
                    var unknownPID = null;
                    var pmtParsed = this.pmtParsed;
                    var pmtId = this._pmtId;
                    var len = data.length;
                    if (this.remainderData) {
                      data = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__.appendUint8Array)(this.remainderData, data);
                      len = data.length;
                      this.remainderData = null;
                    }
                    if (len < PACKET_LENGTH && !flush) {
                      this.remainderData = data;
                      return {
                        audioTrack,
                        videoTrack,
                        id3Track,
                        textTrack
                      };
                    }
                    var syncOffset = Math.max(0, TSDemuxer2.syncOffset(data));
                    len -= (len - syncOffset) % PACKET_LENGTH;
                    if (len < data.byteLength && !flush) {
                      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
                    }
                    var tsPacketErrors = 0;
                    for (var start = syncOffset; start < len; start += PACKET_LENGTH) {
                      if (data[start] === 71) {
                        var stt = !!(data[start + 1] & 64);
                        var pid = parsePID(data, start);
                        var atf = (data[start + 3] & 48) >> 4;
                        var offset = void 0;
                        if (atf > 1) {
                          offset = start + 5 + data[start + 4];
                          if (offset === start + PACKET_LENGTH) {
                            continue;
                          }
                        } else {
                          offset = start + 4;
                        }
                        switch (pid) {
                          case avcId:
                            if (stt) {
                              if (avcData && (pes = parsePES(avcData))) {
                                this.parseAVCPES(videoTrack, textTrack, pes, false);
                              }
                              avcData = {
                                data: [],
                                size: 0
                              };
                            }
                            if (avcData) {
                              avcData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                              avcData.size += start + PACKET_LENGTH - offset;
                            }
                            break;
                          case audioId:
                            if (stt) {
                              if (audioData && (pes = parsePES(audioData))) {
                                switch (audioTrack.segmentCodec) {
                                  case "aac":
                                    this.parseAACPES(audioTrack, pes);
                                    break;
                                  case "mp3":
                                    this.parseMPEGPES(audioTrack, pes);
                                    break;
                                }
                              }
                              audioData = {
                                data: [],
                                size: 0
                              };
                            }
                            if (audioData) {
                              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                              audioData.size += start + PACKET_LENGTH - offset;
                            }
                            break;
                          case id3Id:
                            if (stt) {
                              if (id3Data && (pes = parsePES(id3Data))) {
                                this.parseID3PES(id3Track, pes);
                              }
                              id3Data = {
                                data: [],
                                size: 0
                              };
                            }
                            if (id3Data) {
                              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));
                              id3Data.size += start + PACKET_LENGTH - offset;
                            }
                            break;
                          case 0:
                            if (stt) {
                              offset += data[offset] + 1;
                            }
                            pmtId = this._pmtId = parsePAT(data, offset);
                            break;
                          case pmtId: {
                            if (stt) {
                              offset += data[offset] + 1;
                            }
                            var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);
                            avcId = parsedPIDs.avc;
                            if (avcId > 0) {
                              videoTrack.pid = avcId;
                            }
                            audioId = parsedPIDs.audio;
                            if (audioId > 0) {
                              audioTrack.pid = audioId;
                              audioTrack.segmentCodec = parsedPIDs.segmentCodec;
                            }
                            id3Id = parsedPIDs.id3;
                            if (id3Id > 0) {
                              id3Track.pid = id3Id;
                            }
                            if (unknownPID !== null && !pmtParsed) {
                              _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn("MPEG-TS PMT found at " + start + " after unknown PID '" + unknownPID + "'. Backtracking to sync byte @" + syncOffset + " to parse all TS packets.");
                              unknownPID = null;
                              start = syncOffset - 188;
                            }
                            pmtParsed = this.pmtParsed = true;
                            break;
                          }
                          case 17:
                          case 8191:
                            break;
                          default:
                            unknownPID = pid;
                            break;
                        }
                      } else {
                        tsPacketErrors++;
                      }
                    }
                    if (tsPacketErrors > 0) {
                      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorDetails.FRAG_PARSING_ERROR,
                        fatal: false,
                        reason: "Found " + tsPacketErrors + " TS packet/s that do not start with 0x47"
                      });
                    }
                    videoTrack.pesData = avcData;
                    audioTrack.pesData = audioData;
                    id3Track.pesData = id3Data;
                    var demuxResult = {
                      audioTrack,
                      videoTrack,
                      id3Track,
                      textTrack
                    };
                    if (flush) {
                      this.extractRemainingSamples(demuxResult);
                    }
                    return demuxResult;
                  };
                  _proto.flush = function flush() {
                    var remainderData = this.remainderData;
                    this.remainderData = null;
                    var result;
                    if (remainderData) {
                      result = this.demux(remainderData, -1, false, true);
                    } else {
                      result = {
                        videoTrack: this._avcTrack,
                        audioTrack: this._audioTrack,
                        id3Track: this._id3Track,
                        textTrack: this._txtTrack
                      };
                    }
                    this.extractRemainingSamples(result);
                    if (this.sampleAes) {
                      return this.decrypt(result, this.sampleAes);
                    }
                    return result;
                  };
                  _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {
                    var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack, id3Track = demuxResult.id3Track, textTrack = demuxResult.textTrack;
                    var avcData = videoTrack.pesData;
                    var audioData = audioTrack.pesData;
                    var id3Data = id3Track.pesData;
                    var pes;
                    if (avcData && (pes = parsePES(avcData))) {
                      this.parseAVCPES(videoTrack, textTrack, pes, true);
                      videoTrack.pesData = null;
                    } else {
                      videoTrack.pesData = avcData;
                    }
                    if (audioData && (pes = parsePES(audioData))) {
                      switch (audioTrack.segmentCodec) {
                        case "aac":
                          this.parseAACPES(audioTrack, pes);
                          break;
                        case "mp3":
                          this.parseMPEGPES(audioTrack, pes);
                          break;
                      }
                      audioTrack.pesData = null;
                    } else {
                      if (audioData !== null && audioData !== void 0 && audioData.size) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log("last AAC PES packet truncated,might overlap between fragments");
                      }
                      audioTrack.pesData = audioData;
                    }
                    if (id3Data && (pes = parsePES(id3Data))) {
                      this.parseID3PES(id3Track, pes);
                      id3Track.pesData = null;
                    } else {
                      id3Track.pesData = id3Data;
                    }
                  };
                  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
                    var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
                    var sampleAes = this.sampleAes = new _sample_aes__WEBPACK_IMPORTED_MODULE_3__["default"](this.observer, this.config, keyData);
                    return this.decrypt(demuxResult, sampleAes);
                  };
                  _proto.decrypt = function decrypt(demuxResult, sampleAes) {
                    return new Promise(function(resolve) {
                      var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack;
                      if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
                        sampleAes.decryptAacSamples(audioTrack.samples, 0, function() {
                          if (videoTrack.samples) {
                            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                              resolve(demuxResult);
                            });
                          } else {
                            resolve(demuxResult);
                          }
                        });
                      } else if (videoTrack.samples) {
                        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                          resolve(demuxResult);
                        });
                      }
                    });
                  };
                  _proto.destroy = function destroy() {
                    this._duration = 0;
                  };
                  _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last) {
                    var _this = this;
                    var units = this.parseAVCNALu(track, pes.data);
                    var debug = false;
                    var avcSample = this.avcSample;
                    var push;
                    var spsfound = false;
                    pes.data = null;
                    if (avcSample && units.length && !track.audFound) {
                      pushAccessUnit(avcSample, track);
                      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, "");
                    }
                    units.forEach(function(unit) {
                      switch (unit.type) {
                        case 1: {
                          push = true;
                          if (!avcSample) {
                            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
                          }
                          if (debug) {
                            avcSample.debug += "NDR ";
                          }
                          avcSample.frame = true;
                          var data = unit.data;
                          if (spsfound && data.length > 4) {
                            var sliceType = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__["default"](data).readSliceType();
                            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                              avcSample.key = true;
                            }
                          }
                          break;
                        }
                        case 5:
                          push = true;
                          if (!avcSample) {
                            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
                          }
                          if (debug) {
                            avcSample.debug += "IDR ";
                          }
                          avcSample.key = true;
                          avcSample.frame = true;
                          break;
                        case 6: {
                          push = true;
                          if (debug && avcSample) {
                            avcSample.debug += "SEI ";
                          }
                          (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__.parseSEIMessageFromNALu)(unit.data, 1, pes.pts, textTrack.samples);
                          break;
                        }
                        case 7:
                          push = true;
                          spsfound = true;
                          if (debug && avcSample) {
                            avcSample.debug += "SPS ";
                          }
                          if (!track.sps) {
                            var expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__["default"](unit.data);
                            var config = expGolombDecoder.readSPS();
                            track.width = config.width;
                            track.height = config.height;
                            track.pixelRatio = config.pixelRatio;
                            track.sps = [unit.data];
                            track.duration = _this._duration;
                            var codecarray = unit.data.subarray(1, 4);
                            var codecstring = "avc1.";
                            for (var i = 0; i < 3; i++) {
                              var h = codecarray[i].toString(16);
                              if (h.length < 2) {
                                h = "0" + h;
                              }
                              codecstring += h;
                            }
                            track.codec = codecstring;
                          }
                          break;
                        case 8:
                          push = true;
                          if (debug && avcSample) {
                            avcSample.debug += "PPS ";
                          }
                          if (!track.pps) {
                            track.pps = [unit.data];
                          }
                          break;
                        case 9:
                          push = false;
                          track.audFound = true;
                          if (avcSample) {
                            pushAccessUnit(avcSample, track);
                          }
                          avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? "AUD " : "");
                          break;
                        case 12:
                          push = true;
                          break;
                        default:
                          push = false;
                          if (avcSample) {
                            avcSample.debug += "unknown NAL " + unit.type + " ";
                          }
                          break;
                      }
                      if (avcSample && push) {
                        var _units = avcSample.units;
                        _units.push(unit);
                      }
                    });
                    if (last && avcSample) {
                      pushAccessUnit(avcSample, track);
                      this.avcSample = null;
                    }
                  };
                  _proto.getLastNalUnit = function getLastNalUnit(samples) {
                    var _avcSample;
                    var avcSample = this.avcSample;
                    var lastUnit;
                    if (!avcSample || avcSample.units.length === 0) {
                      avcSample = samples[samples.length - 1];
                    }
                    if ((_avcSample = avcSample) !== null && _avcSample !== void 0 && _avcSample.units) {
                      var units = avcSample.units;
                      lastUnit = units[units.length - 1];
                    }
                    return lastUnit;
                  };
                  _proto.parseAVCNALu = function parseAVCNALu(track, array) {
                    var len = array.byteLength;
                    var state = track.naluState || 0;
                    var lastState = state;
                    var units = [];
                    var i = 0;
                    var value;
                    var overflow;
                    var unitType;
                    var lastUnitStart = -1;
                    var lastUnitType = 0;
                    if (state === -1) {
                      lastUnitStart = 0;
                      lastUnitType = array[0] & 31;
                      state = 0;
                      i = 1;
                    }
                    while (i < len) {
                      value = array[i++];
                      if (!state) {
                        state = value ? 0 : 1;
                        continue;
                      }
                      if (state === 1) {
                        state = value ? 0 : 2;
                        continue;
                      }
                      if (!value) {
                        state = 3;
                      } else if (value === 1) {
                        if (lastUnitStart >= 0) {
                          var unit = {
                            data: array.subarray(lastUnitStart, i - state - 1),
                            type: lastUnitType
                          };
                          units.push(unit);
                        } else {
                          var lastUnit = this.getLastNalUnit(track.samples);
                          if (lastUnit) {
                            if (lastState && i <= 4 - lastState) {
                              if (lastUnit.state) {
                                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                              }
                            }
                            overflow = i - state - 1;
                            if (overflow > 0) {
                              var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                              tmp.set(lastUnit.data, 0);
                              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                              lastUnit.data = tmp;
                              lastUnit.state = 0;
                            }
                          }
                        }
                        if (i < len) {
                          unitType = array[i] & 31;
                          lastUnitStart = i;
                          lastUnitType = unitType;
                          state = 0;
                        } else {
                          state = -1;
                        }
                      } else {
                        state = 0;
                      }
                    }
                    if (lastUnitStart >= 0 && state >= 0) {
                      var _unit = {
                        data: array.subarray(lastUnitStart, len),
                        type: lastUnitType,
                        state
                      };
                      units.push(_unit);
                    }
                    if (units.length === 0) {
                      var _lastUnit = this.getLastNalUnit(track.samples);
                      if (_lastUnit) {
                        var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
                        _tmp.set(_lastUnit.data, 0);
                        _tmp.set(array, _lastUnit.data.byteLength);
                        _lastUnit.data = _tmp;
                      }
                    }
                    track.naluState = state;
                    return units;
                  };
                  _proto.parseAACPES = function parseAACPES(track, pes) {
                    var startOffset = 0;
                    var aacOverFlow = this.aacOverFlow;
                    var data = pes.data;
                    if (aacOverFlow) {
                      this.aacOverFlow = null;
                      var frameMissingBytes = aacOverFlow.missing;
                      var sampleLength = aacOverFlow.sample.unit.byteLength;
                      if (frameMissingBytes === -1) {
                        var tmp = new Uint8Array(sampleLength + data.byteLength);
                        tmp.set(aacOverFlow.sample.unit, 0);
                        tmp.set(data, sampleLength);
                        data = tmp;
                      } else {
                        var frameOverflowBytes = sampleLength - frameMissingBytes;
                        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
                        track.samples.push(aacOverFlow.sample);
                        startOffset = aacOverFlow.missing;
                      }
                    }
                    var offset;
                    var len;
                    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
                      if (_adts__WEBPACK_IMPORTED_MODULE_0__.isHeader(data, offset)) {
                        break;
                      }
                    }
                    if (offset !== startOffset) {
                      var reason;
                      var fatal;
                      if (offset < len - 1) {
                        reason = "AAC PES did not start with ADTS header,offset:" + offset;
                        fatal = false;
                      } else {
                        reason = "no ADTS header found in AAC PES";
                        fatal = true;
                      }
                      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn("parsing error:" + reason);
                      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_4__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorTypes.MEDIA_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_7__.ErrorDetails.FRAG_PARSING_ERROR,
                        fatal,
                        reason
                      });
                      if (fatal) {
                        return;
                      }
                    }
                    _adts__WEBPACK_IMPORTED_MODULE_0__.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
                    var pts;
                    if (pes.pts !== void 0) {
                      pts = pes.pts;
                    } else if (aacOverFlow) {
                      var frameDuration = _adts__WEBPACK_IMPORTED_MODULE_0__.getFrameDuration(track.samplerate);
                      pts = aacOverFlow.sample.pts + frameDuration;
                    } else {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
                      return;
                    }
                    var frameIndex = 0;
                    var frame;
                    while (offset < len) {
                      frame = _adts__WEBPACK_IMPORTED_MODULE_0__.appendFrame(track, data, offset, pts, frameIndex);
                      offset += frame.length;
                      if (!frame.missing) {
                        frameIndex++;
                        for (; offset < len - 1; offset++) {
                          if (_adts__WEBPACK_IMPORTED_MODULE_0__.isHeader(data, offset)) {
                            break;
                          }
                        }
                      } else {
                        this.aacOverFlow = frame;
                        break;
                      }
                    }
                  };
                  _proto.parseMPEGPES = function parseMPEGPES(track, pes) {
                    var data = pes.data;
                    var length = data.length;
                    var frameIndex = 0;
                    var offset = 0;
                    var pts = pes.pts;
                    if (pts === void 0) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
                      return;
                    }
                    while (offset < length) {
                      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_1__.isHeader(data, offset)) {
                        var frame = _mpegaudio__WEBPACK_IMPORTED_MODULE_1__.appendFrame(track, data, offset, pts, frameIndex);
                        if (frame) {
                          offset += frame.length;
                          frameIndex++;
                        } else {
                          break;
                        }
                      } else {
                        offset++;
                      }
                    }
                  };
                  _proto.parseID3PES = function parseID3PES(id3Track, pes) {
                    if (pes.pts === void 0) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
                      return;
                    }
                    var id3Sample = _extends({}, pes, {
                      type: this._avcTrack ? _types_demuxer__WEBPACK_IMPORTED_MODULE_8__.MetadataSchema.emsg : _types_demuxer__WEBPACK_IMPORTED_MODULE_8__.MetadataSchema.audioId3,
                      duration: Number.POSITIVE_INFINITY
                    });
                    id3Track.samples.push(id3Sample);
                  };
                  return TSDemuxer2;
                }();
                function createAVCSample(key, pts, dts, debug) {
                  return {
                    key,
                    frame: false,
                    pts,
                    dts,
                    units: [],
                    debug,
                    length: 0
                  };
                }
                function parsePID(data, offset) {
                  return ((data[offset + 1] & 31) << 8) + data[offset + 2];
                }
                function parsePAT(data, offset) {
                  return (data[offset + 10] & 31) << 8 | data[offset + 11];
                }
                function parsePMT(data, offset, typeSupported, isSampleAes) {
                  var result = {
                    audio: -1,
                    avc: -1,
                    id3: -1,
                    segmentCodec: "aac"
                  };
                  var sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
                  var tableEnd = offset + 3 + sectionLength - 4;
                  var programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
                  offset += 12 + programInfoLength;
                  while (offset < tableEnd) {
                    var pid = parsePID(data, offset);
                    switch (data[offset]) {
                      case 207:
                        if (!isSampleAes) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                          break;
                        }
                      case 15:
                        if (result.audio === -1) {
                          result.audio = pid;
                        }
                        break;
                      case 21:
                        if (result.id3 === -1) {
                          result.id3 = pid;
                        }
                        break;
                      case 219:
                        if (!isSampleAes) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                          break;
                        }
                      case 27:
                        if (result.avc === -1) {
                          result.avc = pid;
                        }
                        break;
                      case 3:
                      case 4:
                        if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log("MPEG audio found, not supported in this browser");
                        } else if (result.audio === -1) {
                          result.audio = pid;
                          result.segmentCodec = "mp3";
                        }
                        break;
                      case 36:
                        _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn("Unsupported HEVC stream type found");
                        break;
                      default:
                        break;
                    }
                    offset += ((data[offset + 3] & 15) << 8 | data[offset + 4]) + 5;
                  }
                  return result;
                }
                function parsePES(stream) {
                  var i = 0;
                  var frag;
                  var pesLen;
                  var pesHdrLen;
                  var pesPts;
                  var pesDts;
                  var data = stream.data;
                  if (!stream || stream.size === 0) {
                    return null;
                  }
                  while (data[0].length < 19 && data.length > 1) {
                    var newData = new Uint8Array(data[0].length + data[1].length);
                    newData.set(data[0]);
                    newData.set(data[1], data[0].length);
                    data[0] = newData;
                    data.splice(1, 1);
                  }
                  frag = data[0];
                  var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
                  if (pesPrefix === 1) {
                    pesLen = (frag[4] << 8) + frag[5];
                    if (pesLen && pesLen > stream.size - 6) {
                      return null;
                    }
                    var pesFlags = frag[7];
                    if (pesFlags & 192) {
                      pesPts = (frag[9] & 14) * 536870912 + // 1 << 29
                      (frag[10] & 255) * 4194304 + // 1 << 22
                      (frag[11] & 254) * 16384 + // 1 << 14
                      (frag[12] & 255) * 128 + // 1 << 7
                      (frag[13] & 254) / 2;
                      if (pesFlags & 64) {
                        pesDts = (frag[14] & 14) * 536870912 + // 1 << 29
                        (frag[15] & 255) * 4194304 + // 1 << 22
                        (frag[16] & 254) * 16384 + // 1 << 14
                        (frag[17] & 255) * 128 + // 1 << 7
                        (frag[18] & 254) / 2;
                        if (pesPts - pesDts > 60 * 9e4) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.warn(Math.round((pesPts - pesDts) / 9e4) + "s delta between PTS and DTS, align them");
                          pesPts = pesDts;
                        }
                      } else {
                        pesDts = pesPts;
                      }
                    }
                    pesHdrLen = frag[8];
                    var payloadStartOffset = pesHdrLen + 9;
                    if (stream.size <= payloadStartOffset) {
                      return null;
                    }
                    stream.size -= payloadStartOffset;
                    var pesData = new Uint8Array(stream.size);
                    for (var j = 0, dataLen = data.length; j < dataLen; j++) {
                      frag = data[j];
                      var len = frag.byteLength;
                      if (payloadStartOffset) {
                        if (payloadStartOffset > len) {
                          payloadStartOffset -= len;
                          continue;
                        } else {
                          frag = frag.subarray(payloadStartOffset);
                          len -= payloadStartOffset;
                          payloadStartOffset = 0;
                        }
                      }
                      pesData.set(frag, i);
                      i += len;
                    }
                    if (pesLen) {
                      pesLen -= pesHdrLen + 3;
                    }
                    return {
                      data: pesData,
                      pts: pesPts,
                      dts: pesDts,
                      len: pesLen
                    };
                  }
                  return null;
                }
                function pushAccessUnit(avcSample, avcTrack) {
                  if (avcSample.units.length && avcSample.frame) {
                    if (avcSample.pts === void 0) {
                      var samples = avcTrack.samples;
                      var nbSamples = samples.length;
                      if (nbSamples) {
                        var lastSample = samples[nbSamples - 1];
                        avcSample.pts = lastSample.pts;
                        avcSample.dts = lastSample.dts;
                      } else {
                        avcTrack.dropped++;
                        return;
                      }
                    }
                    avcTrack.samples.push(avcSample);
                  }
                  if (avcSample.debug.length) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_6__.logger.log(avcSample.pts + "/" + avcSample.dts + ":" + avcSample.debug);
                  }
                }
                const __WEBPACK_DEFAULT_EXPORT__ = TSDemuxer;
              }
            ),
            /***/
            "./src/demux/webworkify-webpack.js": (
              /*!*****************************************!*\
                !*** ./src/demux/webworkify-webpack.js ***!
                \*****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* export default binding */
                    __WEBPACK_DEFAULT_EXPORT__
                  )
                  /* harmony export */
                });
                var webpackBootstrapFunc = function webpackBootstrapFunc2() {
                  var __webpack_modules__2 = ENTRY_MODULE;
                  var __webpack_module_cache__2 = {};
                  var __nested_webpack_require_497__ = function __webpack_require__3(moduleId) {
                    var cachedModule = __webpack_module_cache__2[moduleId];
                    if (cachedModule !== void 0) {
                      return cachedModule.exports;
                    }
                    var module2 = __webpack_module_cache__2[moduleId] = {
                      /******/
                      // no module.id needed
                      /******/
                      // no module.loaded needed
                      /******/
                      exports: {}
                      /******/
                    };
                    __webpack_modules__2[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__3);
                    return module2.exports;
                  };
                  __nested_webpack_require_497__.m = __webpack_modules__2;
                  (function() {
                    __nested_webpack_require_497__.n = function(module2) {
                      var getter = module2 && module2.__esModule ? (
                        /******/
                        function() {
                          return module2["default"];
                        }
                      ) : (
                        /******/
                        function() {
                          return module2;
                        }
                      );
                      __nested_webpack_require_497__.d(getter, {
                        a: getter
                      });
                      return getter;
                    };
                  })();
                  (function() {
                    __nested_webpack_require_497__.d = function(exports2, definition) {
                      for (var key in definition) {
                        if (__nested_webpack_require_497__.o(definition, key) && !__nested_webpack_require_497__.o(exports2, key)) {
                          Object.defineProperty(exports2, key, {
                            enumerable: true,
                            get: definition[key]
                          });
                        }
                      }
                    };
                  })();
                  (function() {
                    __nested_webpack_require_497__.o = function(obj, prop) {
                      return Object.prototype.hasOwnProperty.call(obj, prop);
                    };
                  })();
                  (function() {
                    __nested_webpack_require_497__.r = function(exports2) {
                      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                        Object.defineProperty(exports2, Symbol.toStringTag, {
                          value: "Module"
                        });
                      }
                      Object.defineProperty(exports2, "__esModule", {
                        value: true
                      });
                    };
                  })();
                  var result = __nested_webpack_require_497__(ENTRY_MODULE);
                  return result.default || result;
                };
                var webpackBootstrapFuncArr = webpackBootstrapFunc.toString().split("ENTRY_MODULE");
                var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
                var dependencyRegExp = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + moduleNameReqExp + ").*?\\)";
                function quoteRegExp(str) {
                  return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
                }
                function isNumeric(n) {
                  return !isNaN(1 * n);
                }
                function getModuleDependencies(sources, module2, queueName) {
                  var retval = {};
                  retval[queueName] = [];
                  var fnString = module2.toString().replace(/^"[^"]+"/, "function");
                  ;
                  var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/) || fnString.match(/^\(\w+,\s*\w+,\s*(\w+)\)\s?\=\s?\>/);
                  if (!wrapperSignature)
                    return retval;
                  var webpackRequireName = wrapperSignature[1];
                  var re = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
                  var match;
                  while (match = re.exec(fnString)) {
                    if (match[3] === "dll-reference")
                      continue;
                    retval[queueName].push(match[3]);
                  }
                  re = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
                  while (match = re.exec(fnString)) {
                    if (!sources[match[2]]) {
                      retval[queueName].push(match[1]);
                      sources[match[2]] = __webpack_require__2(match[1]).m;
                    }
                    retval[match[2]] = retval[match[2]] || [];
                    retval[match[2]].push(match[4]);
                  }
                  var keys = Object.keys(retval);
                  for (var i = 0; i < keys.length; i++) {
                    for (var j = 0; j < retval[keys[i]].length; j++) {
                      if (isNumeric(retval[keys[i]][j])) {
                        retval[keys[i]][j] = 1 * retval[keys[i]][j];
                      }
                    }
                  }
                  return retval;
                }
                function hasValuesInQueues(queues) {
                  var keys = Object.keys(queues);
                  return keys.reduce(function(hasValues, key) {
                    return hasValues || queues[key].length > 0;
                  }, false);
                }
                function getRequiredModules(sources, moduleId) {
                  var modulesQueue = {
                    main: [moduleId]
                  };
                  var requiredModules = {
                    main: []
                  };
                  var seenModules = {
                    main: {}
                  };
                  while (hasValuesInQueues(modulesQueue)) {
                    var queues = Object.keys(modulesQueue);
                    for (var i = 0; i < queues.length; i++) {
                      var queueName = queues[i];
                      var queue = modulesQueue[queueName];
                      var moduleToCheck = queue.pop();
                      seenModules[queueName] = seenModules[queueName] || {};
                      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck])
                        continue;
                      seenModules[queueName][moduleToCheck] = true;
                      requiredModules[queueName] = requiredModules[queueName] || [];
                      requiredModules[queueName].push(moduleToCheck);
                      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                      var newModulesKeys = Object.keys(newModules);
                      for (var j = 0; j < newModulesKeys.length; j++) {
                        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
                      }
                    }
                  }
                  return requiredModules;
                }
                function getWebpackString(requiredModules, sources, entryModule, key) {
                  var moduleString = requiredModules[key].map(function(id) {
                    return '"' + id + '": ' + sources[key][id].toString().replace(/^"[^"]+"/, "function");
                  }).join(",");
                  return webpackBootstrapFuncArr[0] + "{" + moduleString + "}" + webpackBootstrapFuncArr[1] + '"' + entryModule + '"' + webpackBootstrapFuncArr[2];
                }
                function __WEBPACK_DEFAULT_EXPORT__(moduleId, options) {
                  options = options || {};
                  var sources = {
                    main: __webpack_require__2.m
                  };
                  var requiredModules = options.all ? {
                    main: Object.keys(sources.main)
                  } : getRequiredModules(sources, moduleId);
                  var src = "";
                  Object.keys(requiredModules).filter(function(m) {
                    return m !== "main";
                  }).forEach(function(module2) {
                    var entryModule = 0;
                    while (requiredModules[module2][entryModule]) {
                      entryModule++;
                    }
                    requiredModules[module2].push(entryModule);
                    sources[module2][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                    src = src + ("var " + module2 + " = (" + getWebpackString(requiredModules, sources, entryModule, modules) + ")();\n");
                  });
                  src = src + ("new ((" + getWebpackString(requiredModules, sources, moduleId, "main") + ")())(self);");
                  var blob = new window.Blob([src], {
                    type: "text/javascript"
                  });
                  var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
                  var workerUrl = URL2.createObjectURL(blob);
                  var worker = new window.Worker(workerUrl);
                  worker.objectURL = workerUrl;
                  return worker;
                }
              }
            ),
            /***/
            "./src/errors.ts": (
              /*!***********************!*\
                !*** ./src/errors.ts ***!
                \***********************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "ErrorDetails": () => (
                    /* binding */
                    ErrorDetails
                  ),
                  /* harmony export */
                  "ErrorTypes": () => (
                    /* binding */
                    ErrorTypes
                  )
                  /* harmony export */
                });
                var ErrorTypes;
                (function(ErrorTypes2) {
                  ErrorTypes2["NETWORK_ERROR"] = "networkError";
                  ErrorTypes2["MEDIA_ERROR"] = "mediaError";
                  ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
                  ErrorTypes2["MUX_ERROR"] = "muxError";
                  ErrorTypes2["OTHER_ERROR"] = "otherError";
                })(ErrorTypes || (ErrorTypes = {}));
                var ErrorDetails;
                (function(ErrorDetails2) {
                  ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
                  ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
                  ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
                  ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
                  ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
                  ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
                  ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
                  ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
                  ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
                  ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
                  ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
                  ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
                  ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
                  ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
                  ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
                  ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
                  ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
                  ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
                  ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
                  ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
                  ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
                  ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
                  ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
                  ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
                  ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
                  ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
                  ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
                  ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
                  ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
                  ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
                  ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
                  ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
                  ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
                  ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
                  ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
                  ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
                  ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
                  ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
                  ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
                  ErrorDetails2["UNKNOWN"] = "unknown";
                })(ErrorDetails || (ErrorDetails = {}));
              }
            ),
            /***/
            "./src/events.ts": (
              /*!***********************!*\
                !*** ./src/events.ts ***!
                \***********************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "Events": () => (
                    /* binding */
                    Events
                  )
                  /* harmony export */
                });
                var Events;
                (function(Events2) {
                  Events2["MEDIA_ATTACHING"] = "hlsMediaAttaching";
                  Events2["MEDIA_ATTACHED"] = "hlsMediaAttached";
                  Events2["MEDIA_DETACHING"] = "hlsMediaDetaching";
                  Events2["MEDIA_DETACHED"] = "hlsMediaDetached";
                  Events2["BUFFER_RESET"] = "hlsBufferReset";
                  Events2["BUFFER_CODECS"] = "hlsBufferCodecs";
                  Events2["BUFFER_CREATED"] = "hlsBufferCreated";
                  Events2["BUFFER_APPENDING"] = "hlsBufferAppending";
                  Events2["BUFFER_APPENDED"] = "hlsBufferAppended";
                  Events2["BUFFER_EOS"] = "hlsBufferEos";
                  Events2["BUFFER_FLUSHING"] = "hlsBufferFlushing";
                  Events2["BUFFER_FLUSHED"] = "hlsBufferFlushed";
                  Events2["MANIFEST_LOADING"] = "hlsManifestLoading";
                  Events2["MANIFEST_LOADED"] = "hlsManifestLoaded";
                  Events2["MANIFEST_PARSED"] = "hlsManifestParsed";
                  Events2["LEVEL_SWITCHING"] = "hlsLevelSwitching";
                  Events2["LEVEL_SWITCHED"] = "hlsLevelSwitched";
                  Events2["LEVEL_LOADING"] = "hlsLevelLoading";
                  Events2["LEVEL_LOADED"] = "hlsLevelLoaded";
                  Events2["LEVEL_UPDATED"] = "hlsLevelUpdated";
                  Events2["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
                  Events2["LEVELS_UPDATED"] = "hlsLevelsUpdated";
                  Events2["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
                  Events2["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
                  Events2["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
                  Events2["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
                  Events2["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
                  Events2["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
                  Events2["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
                  Events2["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
                  Events2["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
                  Events2["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
                  Events2["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
                  Events2["CUES_PARSED"] = "hlsCuesParsed";
                  Events2["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
                  Events2["INIT_PTS_FOUND"] = "hlsInitPtsFound";
                  Events2["FRAG_LOADING"] = "hlsFragLoading";
                  Events2["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
                  Events2["FRAG_LOADED"] = "hlsFragLoaded";
                  Events2["FRAG_DECRYPTED"] = "hlsFragDecrypted";
                  Events2["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
                  Events2["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
                  Events2["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
                  Events2["FRAG_PARSED"] = "hlsFragParsed";
                  Events2["FRAG_BUFFERED"] = "hlsFragBuffered";
                  Events2["FRAG_CHANGED"] = "hlsFragChanged";
                  Events2["FPS_DROP"] = "hlsFpsDrop";
                  Events2["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
                  Events2["ERROR"] = "hlsError";
                  Events2["DESTROYING"] = "hlsDestroying";
                  Events2["KEY_LOADING"] = "hlsKeyLoading";
                  Events2["KEY_LOADED"] = "hlsKeyLoaded";
                  Events2["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
                  Events2["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
                })(Events || (Events = {}));
              }
            ),
            /***/
            "./src/hls.ts": (
              /*!********************!*\
                !*** ./src/hls.ts ***!
                \********************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    Hls
                  )
                  /* harmony export */
                });
                var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! url-toolkit */
                  "./node_modules/url-toolkit/src/url-toolkit.js"
                );
                var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);
                var _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./loader/playlist-loader */
                  "./src/loader/playlist-loader.ts"
                );
                var _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./controller/id3-track-controller */
                  "./src/controller/id3-track-controller.ts"
                );
                var _controller_latency_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./controller/latency-controller */
                  "./src/controller/latency-controller.ts"
                );
                var _controller_level_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./controller/level-controller */
                  "./src/controller/level-controller.ts"
                );
                var _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./controller/fragment-tracker */
                  "./src/controller/fragment-tracker.ts"
                );
                var _loader_key_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ./loader/key-loader */
                  "./src/loader/key-loader.ts"
                );
                var _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ./controller/stream-controller */
                  "./src/controller/stream-controller.ts"
                );
                var _is_supported__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ./is-supported */
                  "./src/is-supported.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ./utils/logger */
                  "./src/utils/logger.ts"
                );
                var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                  /*! ./config */
                  "./src/config.ts"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                  /*! eventemitter3 */
                  "./node_modules/eventemitter3/index.js"
                );
                var eventemitter3__WEBPACK_IMPORTED_MODULE_11___default = __webpack_require__2.n(eventemitter3__WEBPACK_IMPORTED_MODULE_11__);
                var _events__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                  /*! ./events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                  /*! ./errors */
                  "./src/errors.ts"
                );
                var _types_level__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                  /*! ./types/level */
                  "./src/types/level.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var Hls = function() {
                  Hls2.isSupported = function isSupported() {
                    return (0, _is_supported__WEBPACK_IMPORTED_MODULE_8__.isSupported)();
                  };
                  function Hls2(userConfig) {
                    if (userConfig === void 0) {
                      userConfig = {};
                    }
                    this.config = void 0;
                    this.userConfig = void 0;
                    this.coreComponents = void 0;
                    this.networkControllers = void 0;
                    this._emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_11__.EventEmitter();
                    this._autoLevelCapping = void 0;
                    this._maxHdcpLevel = null;
                    this.abrController = void 0;
                    this.bufferController = void 0;
                    this.capLevelController = void 0;
                    this.latencyController = void 0;
                    this.levelController = void 0;
                    this.streamController = void 0;
                    this.audioTrackController = void 0;
                    this.subtitleTrackController = void 0;
                    this.emeController = void 0;
                    this.cmcdController = void 0;
                    this._media = null;
                    this.url = null;
                    var config = this.config = (0, _config__WEBPACK_IMPORTED_MODULE_10__.mergeConfig)(Hls2.DefaultConfig, userConfig);
                    this.userConfig = userConfig;
                    (0, _utils_logger__WEBPACK_IMPORTED_MODULE_9__.enableLogs)(config.debug, "Hls instance");
                    this._autoLevelCapping = -1;
                    if (config.progressive) {
                      (0, _config__WEBPACK_IMPORTED_MODULE_10__.enableStreamingMode)(config);
                    }
                    var ConfigAbrController = config.abrController, ConfigBufferController = config.bufferController, ConfigCapLevelController = config.capLevelController, ConfigFpsController = config.fpsController;
                    var abrController = this.abrController = new ConfigAbrController(this);
                    var bufferController = this.bufferController = new ConfigBufferController(this);
                    var capLevelController = this.capLevelController = new ConfigCapLevelController(this);
                    var fpsController = new ConfigFpsController(this);
                    var playListLoader = new _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__["default"](this);
                    var id3TrackController = new _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_2__["default"](this);
                    var levelController = this.levelController = new _controller_level_controller__WEBPACK_IMPORTED_MODULE_4__["default"](this);
                    var fragmentTracker = new _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_5__.FragmentTracker(this);
                    var keyLoader = new _loader_key_loader__WEBPACK_IMPORTED_MODULE_6__["default"](this.config);
                    var streamController = this.streamController = new _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__["default"](this, fragmentTracker, keyLoader);
                    capLevelController.setStreamController(streamController);
                    fpsController.setStreamController(streamController);
                    var networkControllers = [playListLoader, levelController, streamController];
                    this.networkControllers = networkControllers;
                    var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
                    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
                    var AudioStreamControllerClass = config.audioStreamController;
                    if (AudioStreamControllerClass) {
                      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
                    }
                    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
                    var SubtitleStreamControllerClass = config.subtitleStreamController;
                    if (SubtitleStreamControllerClass) {
                      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
                    }
                    this.createController(config.timelineController, coreComponents);
                    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
                    this.cmcdController = this.createController(config.cmcdController, coreComponents);
                    this.latencyController = this.createController(_controller_latency_controller__WEBPACK_IMPORTED_MODULE_3__["default"], coreComponents);
                    this.coreComponents = coreComponents;
                  }
                  var _proto = Hls2.prototype;
                  _proto.createController = function createController(ControllerClass, components) {
                    if (ControllerClass) {
                      var controllerInstance = new ControllerClass(this);
                      if (components) {
                        components.push(controllerInstance);
                      }
                      return controllerInstance;
                    }
                    return null;
                  };
                  _proto.on = function on(event, listener, context) {
                    if (context === void 0) {
                      context = this;
                    }
                    this._emitter.on(event, listener, context);
                  };
                  _proto.once = function once(event, listener, context) {
                    if (context === void 0) {
                      context = this;
                    }
                    this._emitter.once(event, listener, context);
                  };
                  _proto.removeAllListeners = function removeAllListeners(event) {
                    this._emitter.removeAllListeners(event);
                  };
                  _proto.off = function off(event, listener, context, once) {
                    if (context === void 0) {
                      context = this;
                    }
                    this._emitter.off(event, listener, context, once);
                  };
                  _proto.listeners = function listeners(event) {
                    return this._emitter.listeners(event);
                  };
                  _proto.emit = function emit(event, name, eventObject) {
                    return this._emitter.emit(event, name, eventObject);
                  };
                  _proto.trigger = function trigger(event, eventObject) {
                    if (this.config.debug) {
                      return this.emit(event, event, eventObject);
                    } else {
                      try {
                        return this.emit(event, event, eventObject);
                      } catch (e) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.error("An internal error happened while handling event " + event + '. Error message: "' + e.message + '". Here is a stacktrace:', e);
                        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.ERROR, {
                          type: _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorTypes.OTHER_ERROR,
                          details: _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails.INTERNAL_EXCEPTION,
                          fatal: false,
                          event,
                          error: e
                        });
                      }
                    }
                    return false;
                  };
                  _proto.listenerCount = function listenerCount(event) {
                    return this._emitter.listenerCount(event);
                  };
                  _proto.destroy = function destroy() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("destroy");
                    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.DESTROYING, void 0);
                    this.detachMedia();
                    this.removeAllListeners();
                    this._autoLevelCapping = -1;
                    this.url = null;
                    this.networkControllers.forEach(function(component) {
                      return component.destroy();
                    });
                    this.networkControllers.length = 0;
                    this.coreComponents.forEach(function(component) {
                      return component.destroy();
                    });
                    this.coreComponents.length = 0;
                  };
                  _proto.attachMedia = function attachMedia(media) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("attachMedia");
                    this._media = media;
                    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.MEDIA_ATTACHING, {
                      media
                    });
                  };
                  _proto.detachMedia = function detachMedia() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("detachMedia");
                    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.MEDIA_DETACHING, void 0);
                    this._media = null;
                  };
                  _proto.loadSource = function loadSource(url) {
                    this.stopLoad();
                    var media = this.media;
                    var loadedSource = this.url;
                    var loadingSource = this.url = url_toolkit__WEBPACK_IMPORTED_MODULE_0__.buildAbsoluteURL(self.location.href, url, {
                      alwaysNormalize: true
                    });
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("loadSource:" + loadingSource);
                    if (media && loadedSource && loadedSource !== loadingSource && this.bufferController.hasSourceTypes()) {
                      this.detachMedia();
                      this.attachMedia(media);
                    }
                    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__.Events.MANIFEST_LOADING, {
                      url
                    });
                  };
                  _proto.startLoad = function startLoad(startPosition) {
                    if (startPosition === void 0) {
                      startPosition = -1;
                    }
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("startLoad(" + startPosition + ")");
                    this.networkControllers.forEach(function(controller) {
                      controller.startLoad(startPosition);
                    });
                  };
                  _proto.stopLoad = function stopLoad() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("stopLoad");
                    this.networkControllers.forEach(function(controller) {
                      controller.stopLoad();
                    });
                  };
                  _proto.swapAudioCodec = function swapAudioCodec() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("swapAudioCodec");
                    this.streamController.swapAudioCodec();
                  };
                  _proto.recoverMediaError = function recoverMediaError() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("recoverMediaError");
                    var media = this._media;
                    this.detachMedia();
                    if (media) {
                      this.attachMedia(media);
                    }
                  };
                  _proto.removeLevel = function removeLevel(levelIndex, urlId) {
                    if (urlId === void 0) {
                      urlId = 0;
                    }
                    this.levelController.removeLevel(levelIndex, urlId);
                  };
                  _createClass(Hls2, [{
                    key: "levels",
                    get: function get() {
                      var levels = this.levelController.levels;
                      return levels ? levels : [];
                    }
                    /**
                     * Index of quality level currently played
                     * @type {number}
                     */
                  }, {
                    key: "currentLevel",
                    get: function get() {
                      return this.streamController.currentLevel;
                    },
                    set: function set(newLevel) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("set currentLevel:" + newLevel);
                      this.loadLevel = newLevel;
                      this.abrController.clearTimer();
                      this.streamController.immediateLevelSwitch();
                    }
                    /**
                     * Index of next quality level loaded as scheduled by stream controller.
                     * @type {number}
                     */
                  }, {
                    key: "nextLevel",
                    get: function get() {
                      return this.streamController.nextLevel;
                    },
                    set: function set(newLevel) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("set nextLevel:" + newLevel);
                      this.levelController.manualLevel = newLevel;
                      this.streamController.nextLevelSwitch();
                    }
                    /**
                     * Return the quality level of the currently or last (of none is loaded currently) segment
                     * @type {number}
                     */
                  }, {
                    key: "loadLevel",
                    get: function get() {
                      return this.levelController.level;
                    },
                    set: function set(newLevel) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("set loadLevel:" + newLevel);
                      this.levelController.manualLevel = newLevel;
                    }
                    /**
                     * get next quality level loaded
                     * @type {number}
                     */
                  }, {
                    key: "nextLoadLevel",
                    get: function get() {
                      return this.levelController.nextLoadLevel;
                    },
                    set: function set(level) {
                      this.levelController.nextLoadLevel = level;
                    }
                    /**
                     * Return "first level": like a default level, if not set,
                     * falls back to index of first level referenced in manifest
                     * @type {number}
                     */
                  }, {
                    key: "firstLevel",
                    get: function get() {
                      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
                    },
                    set: function set(newLevel) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("set firstLevel:" + newLevel);
                      this.levelController.firstLevel = newLevel;
                    }
                    /**
                     * Return start level (level of first fragment that will be played back)
                     * if not overrided by user, first level appearing in manifest will be used as start level
                     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
                     * (determined from download of first segment)
                     * @type {number}
                     */
                  }, {
                    key: "startLevel",
                    get: function get() {
                      return this.levelController.startLevel;
                    },
                    set: function set(newLevel) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("set startLevel:" + newLevel);
                      if (newLevel !== -1) {
                        newLevel = Math.max(newLevel, this.minAutoLevel);
                      }
                      this.levelController.startLevel = newLevel;
                    }
                    /**
                     * Get the current setting for capLevelToPlayerSize
                     *
                     * @type {boolean}
                     */
                  }, {
                    key: "capLevelToPlayerSize",
                    get: function get() {
                      return this.config.capLevelToPlayerSize;
                    },
                    set: function set(shouldStartCapping) {
                      var newCapLevelToPlayerSize = !!shouldStartCapping;
                      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
                        if (newCapLevelToPlayerSize) {
                          this.capLevelController.startCapping();
                        } else {
                          this.capLevelController.stopCapping();
                          this.autoLevelCapping = -1;
                          this.streamController.nextLevelSwitch();
                        }
                        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
                      }
                    }
                    /**
                     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
                     * @type {number}
                     */
                  }, {
                    key: "autoLevelCapping",
                    get: function get() {
                      return this._autoLevelCapping;
                    },
                    set: (
                      /**
                       * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
                       * @type {number}
                       */
                      function set(newLevel) {
                        if (this._autoLevelCapping !== newLevel) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_9__.logger.log("set autoLevelCapping:" + newLevel);
                          this._autoLevelCapping = newLevel;
                        }
                      }
                    )
                  }, {
                    key: "bandwidthEstimate",
                    get: function get() {
                      var bwEstimator = this.abrController.bwEstimator;
                      if (!bwEstimator) {
                        return NaN;
                      }
                      return bwEstimator.getEstimate();
                    }
                  }, {
                    key: "maxHdcpLevel",
                    get: function get() {
                      return this._maxHdcpLevel;
                    },
                    set: function set(value) {
                      if (_types_level__WEBPACK_IMPORTED_MODULE_14__.HdcpLevels.indexOf(value) > -1) {
                        this._maxHdcpLevel = value;
                      }
                    }
                    /**
                     * True when automatic level selection enabled
                     * @type {boolean}
                     */
                  }, {
                    key: "autoLevelEnabled",
                    get: function get() {
                      return this.levelController.manualLevel === -1;
                    }
                    /**
                     * Level set manually (if any)
                     * @type {number}
                     */
                  }, {
                    key: "manualLevel",
                    get: function get() {
                      return this.levelController.manualLevel;
                    }
                    /**
                     * min level selectable in auto mode according to config.minAutoBitrate
                     * @type {number}
                     */
                  }, {
                    key: "minAutoLevel",
                    get: function get() {
                      var levels = this.levels, minAutoBitrate = this.config.minAutoBitrate;
                      if (!levels)
                        return 0;
                      var len = levels.length;
                      for (var i = 0; i < len; i++) {
                        if (levels[i].maxBitrate >= minAutoBitrate) {
                          return i;
                        }
                      }
                      return 0;
                    }
                    /**
                     * max level selectable in auto mode according to autoLevelCapping
                     * @type {number}
                     */
                  }, {
                    key: "maxAutoLevel",
                    get: function get() {
                      var levels = this.levels, autoLevelCapping = this.autoLevelCapping, maxHdcpLevel = this.maxHdcpLevel;
                      var maxAutoLevel;
                      if (autoLevelCapping === -1 && levels && levels.length) {
                        maxAutoLevel = levels.length - 1;
                      } else {
                        maxAutoLevel = autoLevelCapping;
                      }
                      if (maxHdcpLevel) {
                        for (var i = maxAutoLevel; i--; ) {
                          var hdcpLevel = levels[i].attrs["HDCP-LEVEL"];
                          if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
                            return i;
                          }
                        }
                      }
                      return maxAutoLevel;
                    }
                    /**
                     * next automatically selected quality level
                     * @type {number}
                     */
                  }, {
                    key: "nextAutoLevel",
                    get: function get() {
                      return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
                    },
                    set: function set(nextLevel) {
                      this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);
                    }
                    /**
                     * get the datetime value relative to media.currentTime for the active level Program Date Time if present
                     * @type {Date}
                     */
                  }, {
                    key: "playingDate",
                    get: function get() {
                      return this.streamController.currentProgramDateTime;
                    }
                  }, {
                    key: "mainForwardBufferInfo",
                    get: function get() {
                      return this.streamController.getMainFwdBufferInfo();
                    }
                    /**
                     * @type {AudioTrack[]}
                     */
                  }, {
                    key: "audioTracks",
                    get: function get() {
                      var audioTrackController = this.audioTrackController;
                      return audioTrackController ? audioTrackController.audioTracks : [];
                    }
                    /**
                     * index of the selected audio track (index in audio track lists)
                     * @type {number}
                     */
                  }, {
                    key: "audioTrack",
                    get: function get() {
                      var audioTrackController = this.audioTrackController;
                      return audioTrackController ? audioTrackController.audioTrack : -1;
                    },
                    set: function set(audioTrackId) {
                      var audioTrackController = this.audioTrackController;
                      if (audioTrackController) {
                        audioTrackController.audioTrack = audioTrackId;
                      }
                    }
                    /**
                     * get alternate subtitle tracks list from playlist
                     * @type {MediaPlaylist[]}
                     */
                  }, {
                    key: "subtitleTracks",
                    get: function get() {
                      var subtitleTrackController = this.subtitleTrackController;
                      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
                    }
                    /**
                     * index of the selected subtitle track (index in subtitle track lists)
                     * @type {number}
                     */
                  }, {
                    key: "subtitleTrack",
                    get: function get() {
                      var subtitleTrackController = this.subtitleTrackController;
                      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
                    },
                    set: (
                      /**
                       * select an subtitle track, based on its index in subtitle track lists
                       * @type {number}
                       */
                      function set(subtitleTrackId) {
                        var subtitleTrackController = this.subtitleTrackController;
                        if (subtitleTrackController) {
                          subtitleTrackController.subtitleTrack = subtitleTrackId;
                        }
                      }
                    )
                    /**
                     * @type {boolean}
                     */
                  }, {
                    key: "media",
                    get: function get() {
                      return this._media;
                    }
                  }, {
                    key: "subtitleDisplay",
                    get: function get() {
                      var subtitleTrackController = this.subtitleTrackController;
                      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
                    },
                    set: function set(value) {
                      var subtitleTrackController = this.subtitleTrackController;
                      if (subtitleTrackController) {
                        subtitleTrackController.subtitleDisplay = value;
                      }
                    }
                    /**
                     * get mode for Low-Latency HLS loading
                     * @type {boolean}
                     */
                  }, {
                    key: "lowLatencyMode",
                    get: function get() {
                      return this.config.lowLatencyMode;
                    },
                    set: function set(mode) {
                      this.config.lowLatencyMode = mode;
                    }
                    /**
                     * position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
                     * @type {number}
                     */
                  }, {
                    key: "liveSyncPosition",
                    get: function get() {
                      return this.latencyController.liveSyncPosition;
                    }
                    /**
                     * estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
                     * returns 0 before first playlist is loaded
                     * @type {number}
                     */
                  }, {
                    key: "latency",
                    get: function get() {
                      return this.latencyController.latency;
                    }
                    /**
                     * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
                     * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
                     * returns 0 before first playlist is loaded
                     * @type {number}
                     */
                  }, {
                    key: "maxLatency",
                    get: function get() {
                      return this.latencyController.maxLatency;
                    }
                    /**
                     * target distance from the edge as calculated by the latency controller
                     * @type {number}
                     */
                  }, {
                    key: "targetLatency",
                    get: function get() {
                      return this.latencyController.targetLatency;
                    }
                    /**
                     * the rate at which the edge of the current live playlist is advancing or 1 if there is none
                     * @type {number}
                     */
                  }, {
                    key: "drift",
                    get: function get() {
                      return this.latencyController.drift;
                    }
                    /**
                     * set to true when startLoad is called before MANIFEST_PARSED event
                     * @type {boolean}
                     */
                  }, {
                    key: "forceStartLoad",
                    get: function get() {
                      return this.streamController.forceStartLoad;
                    }
                  }], [{
                    key: "version",
                    get: function get() {
                      return "1.3.5";
                    }
                  }, {
                    key: "Events",
                    get: function get() {
                      return _events__WEBPACK_IMPORTED_MODULE_12__.Events;
                    }
                  }, {
                    key: "ErrorTypes",
                    get: function get() {
                      return _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorTypes;
                    }
                  }, {
                    key: "ErrorDetails",
                    get: function get() {
                      return _errors__WEBPACK_IMPORTED_MODULE_13__.ErrorDetails;
                    }
                  }, {
                    key: "DefaultConfig",
                    get: function get() {
                      if (!Hls2.defaultConfig) {
                        return _config__WEBPACK_IMPORTED_MODULE_10__.hlsDefaultConfig;
                      }
                      return Hls2.defaultConfig;
                    },
                    set: function set(defaultConfig) {
                      Hls2.defaultConfig = defaultConfig;
                    }
                  }]);
                  return Hls2;
                }();
                Hls.defaultConfig = void 0;
              }
            ),
            /***/
            "./src/is-supported.ts": (
              /*!*****************************!*\
                !*** ./src/is-supported.ts ***!
                \*****************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "changeTypeSupported": () => (
                    /* binding */
                    changeTypeSupported
                  ),
                  /* harmony export */
                  "isSupported": () => (
                    /* binding */
                    isSupported
                  )
                  /* harmony export */
                });
                var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./utils/mediasource-helper */
                  "./src/utils/mediasource-helper.ts"
                );
                function getSourceBuffer() {
                  return self.SourceBuffer || self.WebKitSourceBuffer;
                }
                function isSupported() {
                  var mediaSource = (0, _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__.getMediaSource)();
                  if (!mediaSource) {
                    return false;
                  }
                  var sourceBuffer = getSourceBuffer();
                  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === "function" && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
                  return !!isTypeSupported && !!sourceBufferValidAPI;
                }
                function changeTypeSupported() {
                  var _sourceBuffer$prototy;
                  var sourceBuffer = getSourceBuffer();
                  return typeof (sourceBuffer === null || sourceBuffer === void 0 ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) === null || _sourceBuffer$prototy === void 0 ? void 0 : _sourceBuffer$prototy.changeType) === "function";
                }
              }
            ),
            /***/
            "./src/loader/date-range.ts": (
              /*!**********************************!*\
                !*** ./src/loader/date-range.ts ***!
                \**********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "DateRange": () => (
                    /* binding */
                    DateRange
                  ),
                  /* harmony export */
                  "DateRangeAttribute": () => (
                    /* binding */
                    DateRangeAttribute
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/attr-list */
                  "./src/utils/attr-list.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var DateRangeAttribute;
                (function(DateRangeAttribute2) {
                  DateRangeAttribute2["ID"] = "ID";
                  DateRangeAttribute2["CLASS"] = "CLASS";
                  DateRangeAttribute2["START_DATE"] = "START-DATE";
                  DateRangeAttribute2["DURATION"] = "DURATION";
                  DateRangeAttribute2["END_DATE"] = "END-DATE";
                  DateRangeAttribute2["END_ON_NEXT"] = "END-ON-NEXT";
                  DateRangeAttribute2["PLANNED_DURATION"] = "PLANNED-DURATION";
                  DateRangeAttribute2["SCTE35_OUT"] = "SCTE35-OUT";
                  DateRangeAttribute2["SCTE35_IN"] = "SCTE35-IN";
                })(DateRangeAttribute || (DateRangeAttribute = {}));
                var DateRange = function() {
                  function DateRange2(dateRangeAttr, dateRangeWithSameId) {
                    this.attr = void 0;
                    this._startDate = void 0;
                    this._endDate = void 0;
                    this._badValueForSameId = void 0;
                    if (dateRangeWithSameId) {
                      var previousAttr = dateRangeWithSameId.attr;
                      for (var key in previousAttr) {
                        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_2__.logger.warn('DATERANGE tag attribute: "' + key + '" does not match for tags with ID: "' + dateRangeAttr.ID + '"');
                          this._badValueForSameId = key;
                          break;
                        }
                      }
                      dateRangeAttr = _extends(new _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__.AttrList({}), previousAttr, dateRangeAttr);
                    }
                    this.attr = dateRangeAttr;
                    this._startDate = new Date(dateRangeAttr[DateRangeAttribute.START_DATE]);
                    if (DateRangeAttribute.END_DATE in this.attr) {
                      var endDate = new Date(this.attr[DateRangeAttribute.END_DATE]);
                      if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(endDate.getTime())) {
                        this._endDate = endDate;
                      }
                    }
                  }
                  _createClass(DateRange2, [{
                    key: "id",
                    get: function get() {
                      return this.attr.ID;
                    }
                  }, {
                    key: "class",
                    get: function get() {
                      return this.attr.CLASS;
                    }
                  }, {
                    key: "startDate",
                    get: function get() {
                      return this._startDate;
                    }
                  }, {
                    key: "endDate",
                    get: function get() {
                      if (this._endDate) {
                        return this._endDate;
                      }
                      var duration = this.duration;
                      if (duration !== null) {
                        return new Date(this._startDate.getTime() + duration * 1e3);
                      }
                      return null;
                    }
                  }, {
                    key: "duration",
                    get: function get() {
                      if (DateRangeAttribute.DURATION in this.attr) {
                        var duration = this.attr.decimalFloatingPoint(DateRangeAttribute.DURATION);
                        if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(duration)) {
                          return duration;
                        }
                      } else if (this._endDate) {
                        return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                      }
                      return null;
                    }
                  }, {
                    key: "plannedDuration",
                    get: function get() {
                      if (DateRangeAttribute.PLANNED_DURATION in this.attr) {
                        return this.attr.decimalFloatingPoint(DateRangeAttribute.PLANNED_DURATION);
                      }
                      return null;
                    }
                  }, {
                    key: "endOnNext",
                    get: function get() {
                      return this.attr.bool(DateRangeAttribute.END_ON_NEXT);
                    }
                  }, {
                    key: "isValid",
                    get: function get() {
                      return !!this.id && !this._badValueForSameId && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
                    }
                  }]);
                  return DateRange2;
                }();
              }
            ),
            /***/
            "./src/loader/fragment-loader.ts": (
              /*!***************************************!*\
                !*** ./src/loader/fragment-loader.ts ***!
                \***************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "LoadError": () => (
                    /* binding */
                    LoadError
                  ),
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    FragmentLoader
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
                  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                    if (Class2 === null || !_isNativeFunction(Class2))
                      return Class2;
                    if (typeof Class2 !== "function") {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    if (typeof _cache !== "undefined") {
                      if (_cache.has(Class2))
                        return _cache.get(Class2);
                      _cache.set(Class2, Wrapper);
                    }
                    function Wrapper() {
                      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                    return _setPrototypeOf(Wrapper, Class2);
                  };
                  return _wrapNativeSuper(Class);
                }
                function _construct(Parent, args, Class) {
                  if (_isNativeReflectConstruct()) {
                    _construct = Reflect.construct.bind();
                  } else {
                    _construct = function _construct2(Parent2, args2, Class2) {
                      var a = [null];
                      a.push.apply(a, args2);
                      var Constructor = Function.bind.apply(Parent2, a);
                      var instance = new Constructor();
                      if (Class2)
                        _setPrototypeOf(instance, Class2.prototype);
                      return instance;
                    };
                  }
                  return _construct.apply(null, arguments);
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                function _isNativeFunction(fn) {
                  return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                var MIN_CHUNK_SIZE = Math.pow(2, 17);
                var FragmentLoader = function() {
                  function FragmentLoader2(config) {
                    this.config = void 0;
                    this.loader = null;
                    this.partLoadTimeout = -1;
                    this.config = config;
                  }
                  var _proto = FragmentLoader2.prototype;
                  _proto.destroy = function destroy() {
                    if (this.loader) {
                      this.loader.destroy();
                      this.loader = null;
                    }
                  };
                  _proto.abort = function abort() {
                    if (this.loader) {
                      this.loader.abort();
                    }
                  };
                  _proto.load = function load(frag, _onProgress) {
                    var _this = this;
                    var url = frag.url;
                    if (!url) {
                      return Promise.reject(new LoadError({
                        type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_ERROR,
                        fatal: false,
                        frag,
                        networkDetails: null
                      }, "Fragment does not have a " + (url ? "part list" : "url")));
                    }
                    this.abort();
                    var config = this.config;
                    var FragmentILoader = config.fLoader;
                    var DefaultILoader = config.loader;
                    return new Promise(function(resolve, reject) {
                      if (_this.loader) {
                        _this.loader.destroy();
                      }
                      var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
                      var loaderContext = createLoaderContext(frag);
                      var loaderConfig = {
                        timeout: config.fragLoadingTimeOut,
                        maxRetry: 0,
                        retryDelay: 0,
                        maxRetryDelay: config.fragLoadingMaxRetryTimeout,
                        highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
                      };
                      frag.stats = loader.stats;
                      loader.load(loaderContext, loaderConfig, {
                        onSuccess: function onSuccess(response, stats, context, networkDetails) {
                          _this.resetLoader(frag, loader);
                          var payload = response.data;
                          if (context.resetIV && frag.decryptdata) {
                            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
                            payload = payload.slice(16);
                          }
                          resolve({
                            frag,
                            part: null,
                            payload,
                            networkDetails
                          });
                        },
                        onError: function onError(response, context, networkDetails) {
                          _this.resetLoader(frag, loader);
                          reject(new LoadError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_ERROR,
                            fatal: false,
                            frag,
                            response,
                            networkDetails
                          }));
                        },
                        onAbort: function onAbort(stats, context, networkDetails) {
                          _this.resetLoader(frag, loader);
                          reject(new LoadError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.INTERNAL_ABORTED,
                            fatal: false,
                            frag,
                            networkDetails
                          }));
                        },
                        onTimeout: function onTimeout(response, context, networkDetails) {
                          _this.resetLoader(frag, loader);
                          reject(new LoadError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_TIMEOUT,
                            fatal: false,
                            frag,
                            networkDetails
                          }));
                        },
                        onProgress: function onProgress(stats, context, data, networkDetails) {
                          if (_onProgress) {
                            _onProgress({
                              frag,
                              part: null,
                              payload: data,
                              networkDetails
                            });
                          }
                        }
                      });
                    });
                  };
                  _proto.loadPart = function loadPart(frag, part, onProgress) {
                    var _this2 = this;
                    this.abort();
                    var config = this.config;
                    var FragmentILoader = config.fLoader;
                    var DefaultILoader = config.loader;
                    return new Promise(function(resolve, reject) {
                      if (_this2.loader) {
                        _this2.loader.destroy();
                      }
                      var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
                      var loaderContext = createLoaderContext(frag, part);
                      var loaderConfig = {
                        timeout: config.fragLoadingTimeOut,
                        maxRetry: 0,
                        retryDelay: 0,
                        maxRetryDelay: config.fragLoadingMaxRetryTimeout,
                        highWaterMark: MIN_CHUNK_SIZE
                      };
                      part.stats = loader.stats;
                      loader.load(loaderContext, loaderConfig, {
                        onSuccess: function onSuccess(response, stats, context, networkDetails) {
                          _this2.resetLoader(frag, loader);
                          _this2.updateStatsFromPart(frag, part);
                          var partLoadedData = {
                            frag,
                            part,
                            payload: response.data,
                            networkDetails
                          };
                          onProgress(partLoadedData);
                          resolve(partLoadedData);
                        },
                        onError: function onError(response, context, networkDetails) {
                          _this2.resetLoader(frag, loader);
                          reject(new LoadError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_ERROR,
                            fatal: false,
                            frag,
                            part,
                            response,
                            networkDetails
                          }));
                        },
                        onAbort: function onAbort(stats, context, networkDetails) {
                          frag.stats.aborted = part.stats.aborted;
                          _this2.resetLoader(frag, loader);
                          reject(new LoadError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.INTERNAL_ABORTED,
                            fatal: false,
                            frag,
                            part,
                            networkDetails
                          }));
                        },
                        onTimeout: function onTimeout(response, context, networkDetails) {
                          _this2.resetLoader(frag, loader);
                          reject(new LoadError({
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorTypes.NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__.ErrorDetails.FRAG_LOAD_TIMEOUT,
                            fatal: false,
                            frag,
                            part,
                            networkDetails
                          }));
                        }
                      });
                    });
                  };
                  _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {
                    var fragStats = frag.stats;
                    var partStats = part.stats;
                    var partTotal = partStats.total;
                    fragStats.loaded += partStats.loaded;
                    if (partTotal) {
                      var estTotalParts = Math.round(frag.duration / part.duration);
                      var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
                      var estRemainingParts = estTotalParts - estLoadedParts;
                      var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
                      fragStats.total = fragStats.loaded + estRemainingBytes;
                    } else {
                      fragStats.total = Math.max(fragStats.loaded, fragStats.total);
                    }
                    var fragLoading = fragStats.loading;
                    var partLoading = partStats.loading;
                    if (fragLoading.start) {
                      fragLoading.first += partLoading.first - partLoading.start;
                    } else {
                      fragLoading.start = partLoading.start;
                      fragLoading.first = partLoading.first;
                    }
                    fragLoading.end = partLoading.end;
                  };
                  _proto.resetLoader = function resetLoader(frag, loader) {
                    frag.loader = null;
                    if (this.loader === loader) {
                      self.clearTimeout(this.partLoadTimeout);
                      this.loader = null;
                    }
                    loader.destroy();
                  };
                  return FragmentLoader2;
                }();
                function createLoaderContext(frag, part) {
                  if (part === void 0) {
                    part = null;
                  }
                  var segment = part || frag;
                  var loaderContext = {
                    frag,
                    part,
                    responseType: "arraybuffer",
                    url: segment.url,
                    headers: {},
                    rangeStart: 0,
                    rangeEnd: 0
                  };
                  var start = segment.byteRangeStartOffset;
                  var end = segment.byteRangeEndOffset;
                  if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(start) && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(end)) {
                    var _frag$decryptdata;
                    var byteRangeStart = start;
                    var byteRangeEnd = end;
                    if (frag.sn === "initSegment" && ((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.method) === "AES-128") {
                      var fragmentLen = end - start;
                      if (fragmentLen % 16) {
                        byteRangeEnd = end + (16 - fragmentLen % 16);
                      }
                      if (start !== 0) {
                        loaderContext.resetIV = true;
                        byteRangeStart = start - 16;
                      }
                    }
                    loaderContext.rangeStart = byteRangeStart;
                    loaderContext.rangeEnd = byteRangeEnd;
                  }
                  return loaderContext;
                }
                var LoadError = function(_Error) {
                  _inheritsLoose(LoadError2, _Error);
                  function LoadError2(data) {
                    var _this3;
                    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      params[_key - 1] = arguments[_key];
                    }
                    _this3 = _Error.call.apply(_Error, [this].concat(params)) || this;
                    _this3.data = void 0;
                    _this3.data = data;
                    return _this3;
                  }
                  return LoadError2;
                }(_wrapNativeSuper(Error));
              }
            ),
            /***/
            "./src/loader/fragment.ts": (
              /*!********************************!*\
                !*** ./src/loader/fragment.ts ***!
                \********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "BaseSegment": () => (
                    /* binding */
                    BaseSegment
                  ),
                  /* harmony export */
                  "ElementaryStreamTypes": () => (
                    /* binding */
                    ElementaryStreamTypes
                  ),
                  /* harmony export */
                  "Fragment": () => (
                    /* binding */
                    Fragment
                  ),
                  /* harmony export */
                  "Part": () => (
                    /* binding */
                    Part
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! url-toolkit */
                  "./node_modules/url-toolkit/src/url-toolkit.js"
                );
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);
                var _load_stats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./load-stats */
                  "./src/loader/load-stats.ts"
                );
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var ElementaryStreamTypes;
                (function(ElementaryStreamTypes2) {
                  ElementaryStreamTypes2["AUDIO"] = "audio";
                  ElementaryStreamTypes2["VIDEO"] = "video";
                  ElementaryStreamTypes2["AUDIOVIDEO"] = "audiovideo";
                })(ElementaryStreamTypes || (ElementaryStreamTypes = {}));
                var BaseSegment = function() {
                  function BaseSegment2(baseurl) {
                    var _this$elementaryStrea;
                    this._byteRange = null;
                    this._url = null;
                    this.baseurl = void 0;
                    this.relurl = void 0;
                    this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);
                    this.baseurl = baseurl;
                  }
                  var _proto = BaseSegment2.prototype;
                  _proto.setByteRange = function setByteRange(value, previous) {
                    var params = value.split("@", 2);
                    var byteRange = [];
                    if (params.length === 1) {
                      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;
                    } else {
                      byteRange[0] = parseInt(params[1]);
                    }
                    byteRange[1] = parseInt(params[0]) + byteRange[0];
                    this._byteRange = byteRange;
                  };
                  _createClass(BaseSegment2, [{
                    key: "byteRange",
                    get: function get() {
                      if (!this._byteRange) {
                        return [];
                      }
                      return this._byteRange;
                    }
                  }, {
                    key: "byteRangeStartOffset",
                    get: function get() {
                      return this.byteRange[0];
                    }
                  }, {
                    key: "byteRangeEndOffset",
                    get: function get() {
                      return this.byteRange[1];
                    }
                  }, {
                    key: "url",
                    get: function get() {
                      if (!this._url && this.baseurl && this.relurl) {
                        this._url = (0, url_toolkit__WEBPACK_IMPORTED_MODULE_1__.buildAbsoluteURL)(this.baseurl, this.relurl, {
                          alwaysNormalize: true
                        });
                      }
                      return this._url || "";
                    },
                    set: function set(value) {
                      this._url = value;
                    }
                  }]);
                  return BaseSegment2;
                }();
                var Fragment = function(_BaseSegment) {
                  _inheritsLoose(Fragment2, _BaseSegment);
                  function Fragment2(type, baseurl) {
                    var _this;
                    _this = _BaseSegment.call(this, baseurl) || this;
                    _this._decryptdata = null;
                    _this.rawProgramDateTime = null;
                    _this.programDateTime = null;
                    _this.tagList = [];
                    _this.duration = 0;
                    _this.sn = 0;
                    _this.levelkeys = void 0;
                    _this.type = void 0;
                    _this.loader = null;
                    _this.keyLoader = null;
                    _this.level = -1;
                    _this.cc = 0;
                    _this.startPTS = void 0;
                    _this.endPTS = void 0;
                    _this.appendedPTS = void 0;
                    _this.startDTS = void 0;
                    _this.endDTS = void 0;
                    _this.start = 0;
                    _this.deltaPTS = void 0;
                    _this.maxStartPTS = void 0;
                    _this.minEndPTS = void 0;
                    _this.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_2__.LoadStats();
                    _this.urlId = 0;
                    _this.data = void 0;
                    _this.bitrateTest = false;
                    _this.title = null;
                    _this.initSegment = null;
                    _this.endList = void 0;
                    _this.type = type;
                    return _this;
                  }
                  var _proto2 = Fragment2.prototype;
                  _proto2.setKeyFormat = function setKeyFormat(keyFormat) {
                    if (this.levelkeys) {
                      var _key = this.levelkeys[keyFormat];
                      if (_key && !this._decryptdata) {
                        this._decryptdata = _key.getDecryptData(this.sn);
                      }
                    }
                  };
                  _proto2.abortRequests = function abortRequests() {
                    var _this$loader, _this$keyLoader;
                    (_this$loader = this.loader) === null || _this$loader === void 0 ? void 0 : _this$loader.abort();
                    (_this$keyLoader = this.keyLoader) === null || _this$keyLoader === void 0 ? void 0 : _this$keyLoader.abort();
                  };
                  _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
                    if (partial === void 0) {
                      partial = false;
                    }
                    var elementaryStreams = this.elementaryStreams;
                    var info = elementaryStreams[type];
                    if (!info) {
                      elementaryStreams[type] = {
                        startPTS,
                        endPTS,
                        startDTS,
                        endDTS,
                        partial
                      };
                      return;
                    }
                    info.startPTS = Math.min(info.startPTS, startPTS);
                    info.endPTS = Math.max(info.endPTS, endPTS);
                    info.startDTS = Math.min(info.startDTS, startDTS);
                    info.endDTS = Math.max(info.endDTS, endDTS);
                  };
                  _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
                    var elementaryStreams = this.elementaryStreams;
                    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
                    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
                    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
                  };
                  _createClass(Fragment2, [{
                    key: "decryptdata",
                    get: function get() {
                      var levelkeys = this.levelkeys;
                      if (!levelkeys && !this._decryptdata) {
                        return null;
                      }
                      if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
                        var _key2 = this.levelkeys.identity;
                        if (_key2) {
                          this._decryptdata = _key2.getDecryptData(this.sn);
                        } else {
                          var keyFormats = Object.keys(this.levelkeys);
                          if (keyFormats.length === 1) {
                            return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
                          } else {
                          }
                        }
                      }
                      return this._decryptdata;
                    }
                  }, {
                    key: "end",
                    get: function get() {
                      return this.start + this.duration;
                    }
                  }, {
                    key: "endProgramDateTime",
                    get: function get() {
                      if (this.programDateTime === null) {
                        return null;
                      }
                      if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.programDateTime)) {
                        return null;
                      }
                      var duration = !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.duration) ? 0 : this.duration;
                      return this.programDateTime + duration * 1e3;
                    }
                  }, {
                    key: "encrypted",
                    get: function get() {
                      var _this$_decryptdata;
                      if ((_this$_decryptdata = this._decryptdata) !== null && _this$_decryptdata !== void 0 && _this$_decryptdata.encrypted) {
                        return true;
                      } else if (this.levelkeys) {
                        var keyFormats = Object.keys(this.levelkeys);
                        var len = keyFormats.length;
                        if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
                          return true;
                        }
                      }
                      return false;
                    }
                  }]);
                  return Fragment2;
                }(BaseSegment);
                var Part = function(_BaseSegment2) {
                  _inheritsLoose(Part2, _BaseSegment2);
                  function Part2(partAttrs, frag, baseurl, index, previous) {
                    var _this2;
                    _this2 = _BaseSegment2.call(this, baseurl) || this;
                    _this2.fragOffset = 0;
                    _this2.duration = 0;
                    _this2.gap = false;
                    _this2.independent = false;
                    _this2.relurl = void 0;
                    _this2.fragment = void 0;
                    _this2.index = void 0;
                    _this2.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_2__.LoadStats();
                    _this2.duration = partAttrs.decimalFloatingPoint("DURATION");
                    _this2.gap = partAttrs.bool("GAP");
                    _this2.independent = partAttrs.bool("INDEPENDENT");
                    _this2.relurl = partAttrs.enumeratedString("URI");
                    _this2.fragment = frag;
                    _this2.index = index;
                    var byteRange = partAttrs.enumeratedString("BYTERANGE");
                    if (byteRange) {
                      _this2.setByteRange(byteRange, previous);
                    }
                    if (previous) {
                      _this2.fragOffset = previous.fragOffset + previous.duration;
                    }
                    return _this2;
                  }
                  _createClass(Part2, [{
                    key: "start",
                    get: function get() {
                      return this.fragment.start + this.fragOffset;
                    }
                  }, {
                    key: "end",
                    get: function get() {
                      return this.start + this.duration;
                    }
                  }, {
                    key: "loaded",
                    get: function get() {
                      var elementaryStreams = this.elementaryStreams;
                      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
                    }
                  }]);
                  return Part2;
                }(BaseSegment);
              }
            ),
            /***/
            "./src/loader/key-loader.ts": (
              /*!**********************************!*\
                !*** ./src/loader/key-loader.ts ***!
                \**********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    KeyLoader
                  )
                  /* harmony export */
                });
                var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _fragment_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./fragment-loader */
                  "./src/loader/fragment-loader.ts"
                );
                var KeyLoader = function() {
                  function KeyLoader2(config) {
                    this.config = void 0;
                    this.keyUriToKeyInfo = {};
                    this.emeController = null;
                    this.config = config;
                  }
                  var _proto = KeyLoader2.prototype;
                  _proto.abort = function abort() {
                    for (var uri in this.keyUriToKeyInfo) {
                      var loader = this.keyUriToKeyInfo[uri].loader;
                      if (loader) {
                        loader.abort();
                      }
                    }
                  };
                  _proto.detach = function detach() {
                    for (var uri in this.keyUriToKeyInfo) {
                      var keyInfo = this.keyUriToKeyInfo[uri];
                      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
                        delete this.keyUriToKeyInfo[uri];
                      }
                    }
                  };
                  _proto.destroy = function destroy() {
                    this.detach();
                    for (var uri in this.keyUriToKeyInfo) {
                      var loader = this.keyUriToKeyInfo[uri].loader;
                      if (loader) {
                        loader.destroy();
                      }
                    }
                    this.keyUriToKeyInfo = {};
                  };
                  _proto.createKeyLoadError = function createKeyLoadError(frag, details, networkDetails, message) {
                    if (details === void 0) {
                      details = _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR;
                    }
                    return new _fragment_loader__WEBPACK_IMPORTED_MODULE_1__.LoadError({
                      type: _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorTypes.NETWORK_ERROR,
                      details,
                      fatal: false,
                      frag,
                      networkDetails
                    });
                  };
                  _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {
                    var _this = this;
                    if (this.emeController && this.config.emeEnabled) {
                      var sn = loadingFrag.sn, cc = loadingFrag.cc;
                      var _loop = function _loop2(i2) {
                        var frag = encryptedFragments[i2];
                        if (cc <= frag.cc && (sn === "initSegment" || sn < frag.sn)) {
                          _this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
                            frag.setKeyFormat(keySystemFormat);
                          });
                          return "break";
                        }
                      };
                      for (var i = 0; i < encryptedFragments.length; i++) {
                        var _ret = _loop(i);
                        if (_ret === "break")
                          break;
                      }
                    }
                  };
                  _proto.load = function load(frag) {
                    var _this2 = this;
                    if (!frag.decryptdata && frag.encrypted && this.emeController) {
                      return this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
                        return _this2.loadInternal(frag, keySystemFormat);
                      });
                    }
                    return this.loadInternal(frag);
                  };
                  _proto.loadInternal = function loadInternal(frag, keySystemFormat) {
                    var _keyInfo, _keyInfo2;
                    if (keySystemFormat) {
                      frag.setKeyFormat(keySystemFormat);
                    }
                    var decryptdata = frag.decryptdata;
                    if (!decryptdata) {
                      var errorMessage = keySystemFormat ? "Expected frag.decryptdata to be defined after setting format " + keySystemFormat : "Missing decryption data on fragment in onKeyLoading";
                      return Promise.reject(this.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, null, errorMessage));
                    }
                    var uri = decryptdata.uri;
                    if (!uri) {
                      return Promise.reject(this.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, null, 'Invalid key URI: "' + uri + '"'));
                    }
                    var keyInfo = this.keyUriToKeyInfo[uri];
                    if ((_keyInfo = keyInfo) !== null && _keyInfo !== void 0 && _keyInfo.decryptdata.key) {
                      decryptdata.key = keyInfo.decryptdata.key;
                      return Promise.resolve({
                        frag,
                        keyInfo
                      });
                    }
                    if ((_keyInfo2 = keyInfo) !== null && _keyInfo2 !== void 0 && _keyInfo2.keyLoadPromise) {
                      var _keyInfo$mediaKeySess;
                      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) === null || _keyInfo$mediaKeySess === void 0 ? void 0 : _keyInfo$mediaKeySess.keyStatus) {
                        case void 0:
                        case "status-pending":
                        case "usable":
                        case "usable-in-future":
                          return keyInfo.keyLoadPromise.then(function(keyLoadedData) {
                            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
                            return {
                              frag,
                              keyInfo
                            };
                          });
                      }
                    }
                    keyInfo = this.keyUriToKeyInfo[uri] = {
                      decryptdata,
                      keyLoadPromise: null,
                      loader: null,
                      mediaKeySessionContext: null
                    };
                    switch (decryptdata.method) {
                      case "ISO-23001-7":
                      case "SAMPLE-AES":
                      case "SAMPLE-AES-CENC":
                      case "SAMPLE-AES-CTR":
                        if (decryptdata.keyFormat === "identity") {
                          return this.loadKeyHTTP(keyInfo, frag);
                        }
                        return this.loadKeyEME(keyInfo, frag);
                      case "AES-128":
                        return this.loadKeyHTTP(keyInfo, frag);
                      default:
                        return Promise.reject(this.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, null, 'Key supplied with unsupported METHOD: "' + decryptdata.method + '"'));
                    }
                  };
                  _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {
                    var keyLoadedData = {
                      frag,
                      keyInfo
                    };
                    if (this.emeController && this.config.emeEnabled) {
                      var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
                      if (keySessionContextPromise) {
                        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function(keySessionContext) {
                          keyInfo.mediaKeySessionContext = keySessionContext;
                          return keyLoadedData;
                        })).catch(function(error) {
                          keyInfo.keyLoadPromise = null;
                          throw error;
                        });
                      }
                    }
                    return Promise.resolve(keyLoadedData);
                  };
                  _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {
                    var _this3 = this;
                    var config = this.config;
                    var Loader = config.loader;
                    var keyLoader = new Loader(config);
                    frag.keyLoader = keyInfo.loader = keyLoader;
                    return keyInfo.keyLoadPromise = new Promise(function(resolve, reject) {
                      var loaderContext = {
                        keyInfo,
                        frag,
                        responseType: "arraybuffer",
                        url: keyInfo.decryptdata.uri
                      };
                      var loaderConfig = {
                        timeout: config.fragLoadingTimeOut,
                        maxRetry: 0,
                        retryDelay: config.fragLoadingRetryDelay,
                        maxRetryDelay: config.fragLoadingMaxRetryTimeout,
                        highWaterMark: 0
                      };
                      var loaderCallbacks = {
                        onSuccess: function onSuccess(response, stats, context, networkDetails) {
                          var frag2 = context.frag, keyInfo2 = context.keyInfo, uri = context.url;
                          if (!frag2.decryptdata || keyInfo2 !== _this3.keyUriToKeyInfo[uri]) {
                            return reject(_this3.createKeyLoadError(frag2, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, networkDetails, "after key load, decryptdata unset or changed"));
                          }
                          keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
                          frag2.keyLoader = null;
                          keyInfo2.loader = null;
                          resolve({
                            frag: frag2,
                            keyInfo: keyInfo2
                          });
                        },
                        onError: function onError(error, context, networkDetails) {
                          _this3.resetLoader(context);
                          reject(_this3.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_ERROR, networkDetails));
                        },
                        onTimeout: function onTimeout(stats, context, networkDetails) {
                          _this3.resetLoader(context);
                          reject(_this3.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.KEY_LOAD_TIMEOUT, networkDetails));
                        },
                        onAbort: function onAbort(stats, context, networkDetails) {
                          _this3.resetLoader(context);
                          reject(_this3.createKeyLoadError(frag, _errors__WEBPACK_IMPORTED_MODULE_0__.ErrorDetails.INTERNAL_ABORTED, networkDetails));
                        }
                      };
                      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
                    });
                  };
                  _proto.resetLoader = function resetLoader(context) {
                    var frag = context.frag, keyInfo = context.keyInfo, uri = context.url;
                    var loader = keyInfo.loader;
                    if (frag.keyLoader === loader) {
                      frag.keyLoader = null;
                      keyInfo.loader = null;
                    }
                    delete this.keyUriToKeyInfo[uri];
                    if (loader) {
                      loader.destroy();
                    }
                  };
                  return KeyLoader2;
                }();
              }
            ),
            /***/
            "./src/loader/level-details.ts": (
              /*!*************************************!*\
                !*** ./src/loader/level-details.ts ***!
                \*************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "LevelDetails": () => (
                    /* binding */
                    LevelDetails
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var DEFAULT_TARGET_DURATION = 10;
                var LevelDetails = function() {
                  function LevelDetails2(baseUrl) {
                    this.PTSKnown = false;
                    this.alignedSliding = false;
                    this.averagetargetduration = void 0;
                    this.endCC = 0;
                    this.endSN = 0;
                    this.fragments = void 0;
                    this.fragmentHint = void 0;
                    this.partList = null;
                    this.dateRanges = void 0;
                    this.live = true;
                    this.ageHeader = 0;
                    this.advancedDateTime = void 0;
                    this.updated = true;
                    this.advanced = true;
                    this.availabilityDelay = void 0;
                    this.misses = 0;
                    this.startCC = 0;
                    this.startSN = 0;
                    this.startTimeOffset = null;
                    this.targetduration = 0;
                    this.totalduration = 0;
                    this.type = null;
                    this.url = void 0;
                    this.m3u8 = "";
                    this.version = null;
                    this.canBlockReload = false;
                    this.canSkipUntil = 0;
                    this.canSkipDateRanges = false;
                    this.skippedSegments = 0;
                    this.recentlyRemovedDateranges = void 0;
                    this.partHoldBack = 0;
                    this.holdBack = 0;
                    this.partTarget = 0;
                    this.preloadHint = void 0;
                    this.renditionReports = void 0;
                    this.tuneInGoal = 0;
                    this.deltaUpdateFailed = void 0;
                    this.driftStartTime = 0;
                    this.driftEndTime = 0;
                    this.driftStart = 0;
                    this.driftEnd = 0;
                    this.encryptedFragments = void 0;
                    this.fragments = [];
                    this.encryptedFragments = [];
                    this.dateRanges = {};
                    this.url = baseUrl;
                  }
                  var _proto = LevelDetails2.prototype;
                  _proto.reloaded = function reloaded(previous) {
                    if (!previous) {
                      this.advanced = true;
                      this.updated = true;
                      return;
                    }
                    var partSnDiff = this.lastPartSn - previous.lastPartSn;
                    var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
                    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;
                    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
                    if (this.updated || this.advanced) {
                      this.misses = Math.floor(previous.misses * 0.6);
                    } else {
                      this.misses = previous.misses + 1;
                    }
                    this.availabilityDelay = previous.availabilityDelay;
                  };
                  _createClass(LevelDetails2, [{
                    key: "hasProgramDateTime",
                    get: function get() {
                      if (this.fragments.length) {
                        return (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this.fragments[this.fragments.length - 1].programDateTime);
                      }
                      return false;
                    }
                  }, {
                    key: "levelTargetDuration",
                    get: function get() {
                      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
                    }
                  }, {
                    key: "drift",
                    get: function get() {
                      var runTime = this.driftEndTime - this.driftStartTime;
                      if (runTime > 0) {
                        var runDuration = this.driftEnd - this.driftStart;
                        return runDuration * 1e3 / runTime;
                      }
                      return 1;
                    }
                  }, {
                    key: "edge",
                    get: function get() {
                      return this.partEnd || this.fragmentEnd;
                    }
                  }, {
                    key: "partEnd",
                    get: function get() {
                      var _this$partList;
                      if ((_this$partList = this.partList) !== null && _this$partList !== void 0 && _this$partList.length) {
                        return this.partList[this.partList.length - 1].end;
                      }
                      return this.fragmentEnd;
                    }
                  }, {
                    key: "fragmentEnd",
                    get: function get() {
                      var _this$fragments;
                      if ((_this$fragments = this.fragments) !== null && _this$fragments !== void 0 && _this$fragments.length) {
                        return this.fragments[this.fragments.length - 1].end;
                      }
                      return 0;
                    }
                  }, {
                    key: "age",
                    get: function get() {
                      if (this.advancedDateTime) {
                        return Math.max(Date.now() - this.advancedDateTime, 0) / 1e3;
                      }
                      return 0;
                    }
                  }, {
                    key: "lastPartIndex",
                    get: function get() {
                      var _this$partList2;
                      if ((_this$partList2 = this.partList) !== null && _this$partList2 !== void 0 && _this$partList2.length) {
                        return this.partList[this.partList.length - 1].index;
                      }
                      return -1;
                    }
                  }, {
                    key: "lastPartSn",
                    get: function get() {
                      var _this$partList3;
                      if ((_this$partList3 = this.partList) !== null && _this$partList3 !== void 0 && _this$partList3.length) {
                        return this.partList[this.partList.length - 1].fragment.sn;
                      }
                      return this.endSN;
                    }
                  }]);
                  return LevelDetails2;
                }();
              }
            ),
            /***/
            "./src/loader/level-key.ts": (
              /*!*********************************!*\
                !*** ./src/loader/level-key.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "LevelKey": () => (
                    /* binding */
                    LevelKey
                  )
                  /* harmony export */
                });
                var _utils_keysystem_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/keysystem-util */
                  "./src/utils/keysystem-util.ts"
                );
                var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../utils/mediakeys-helper */
                  "./src/utils/mediakeys-helper.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/numeric-encoding-utils */
                  "./src/utils/numeric-encoding-utils.ts"
                );
                var keyUriToKeyIdMap = {};
                var LevelKey = function() {
                  LevelKey2.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {
                    keyUriToKeyIdMap = {};
                  };
                  function LevelKey2(method, uri, format, formatversions, iv) {
                    if (formatversions === void 0) {
                      formatversions = [1];
                    }
                    if (iv === void 0) {
                      iv = null;
                    }
                    this.uri = void 0;
                    this.method = void 0;
                    this.keyFormat = void 0;
                    this.keyFormatVersions = void 0;
                    this.encrypted = void 0;
                    this.isCommonEncryption = void 0;
                    this.iv = null;
                    this.key = null;
                    this.keyId = null;
                    this.pssh = null;
                    this.method = method;
                    this.uri = uri;
                    this.keyFormat = format;
                    this.keyFormatVersions = formatversions;
                    this.iv = iv;
                    this.encrypted = method ? method !== "NONE" : false;
                    this.isCommonEncryption = this.encrypted && method !== "AES-128";
                  }
                  var _proto = LevelKey2.prototype;
                  _proto.isSupported = function isSupported() {
                    if (this.method) {
                      if (this.method === "AES-128" || this.method === "NONE") {
                        return true;
                      }
                      switch (this.keyFormat) {
                        case "identity":
                          return this.method === "SAMPLE-AES";
                        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.FAIRPLAY:
                        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.WIDEVINE:
                        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.PLAYREADY:
                        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.CLEARKEY:
                          return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
                      }
                    }
                    return false;
                  };
                  _proto.getDecryptData = function getDecryptData(sn) {
                    if (!this.encrypted || !this.uri) {
                      return null;
                    }
                    if (this.method === "AES-128" && this.uri && !this.iv) {
                      if (typeof sn !== "number") {
                        if (this.method === "AES-128" && !this.iv) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn('missing IV for initialization segment with method="' + this.method + '" - compliance issue');
                        }
                        sn = 0;
                      }
                      var iv = createInitializationVector(sn);
                      var decryptdata = new LevelKey2(this.method, this.uri, "identity", this.keyFormatVersions, iv);
                      return decryptdata;
                    }
                    var keyBytes = (0, _utils_keysystem_util__WEBPACK_IMPORTED_MODULE_0__.convertDataUriToArrayBytes)(this.uri);
                    if (keyBytes) {
                      switch (this.keyFormat) {
                        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.WIDEVINE:
                          this.pssh = keyBytes;
                          if (keyBytes.length >= 22) {
                            this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
                          }
                          break;
                        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_1__.KeySystemFormats.PLAYREADY: {
                          var PlayReadyKeySystemUUID = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
                          this.pssh = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.mp4pssh)(PlayReadyKeySystemUUID, null, keyBytes);
                          var keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
                          var keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));
                          var xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf("<"), keyByteStr.length);
                          var parser = new DOMParser();
                          var xmlDoc = parser.parseFromString(xmlKeyBytes, "text/xml");
                          var keyData = xmlDoc.getElementsByTagName("KID")[0];
                          if (keyData) {
                            var keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute("VALUE");
                            if (keyId) {
                              var keyIdArray = (0, _utils_numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_4__.base64Decode)(keyId).subarray(0, 16);
                              (0, _utils_keysystem_util__WEBPACK_IMPORTED_MODULE_0__.changeEndianness)(keyIdArray);
                              this.keyId = keyIdArray;
                            }
                          }
                          break;
                        }
                        default: {
                          var keydata = keyBytes.subarray(0, 16);
                          if (keydata.length !== 16) {
                            var padded = new Uint8Array(16);
                            padded.set(keydata, 16 - keydata.length);
                            keydata = padded;
                          }
                          this.keyId = keydata;
                          break;
                        }
                      }
                    }
                    if (!this.keyId || this.keyId.byteLength !== 16) {
                      var _keyId = keyUriToKeyIdMap[this.uri];
                      if (!_keyId) {
                        var val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
                        _keyId = new Uint8Array(16);
                        var dv = new DataView(_keyId.buffer, 12, 4);
                        dv.setUint32(0, val);
                        keyUriToKeyIdMap[this.uri] = _keyId;
                      }
                      this.keyId = _keyId;
                    }
                    return this;
                  };
                  return LevelKey2;
                }();
                function createInitializationVector(segmentNumber) {
                  var uint8View = new Uint8Array(16);
                  for (var i = 12; i < 16; i++) {
                    uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
                  }
                  return uint8View;
                }
              }
            ),
            /***/
            "./src/loader/load-stats.ts": (
              /*!**********************************!*\
                !*** ./src/loader/load-stats.ts ***!
                \**********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "LoadStats": () => (
                    /* binding */
                    LoadStats
                  )
                  /* harmony export */
                });
                var LoadStats = function LoadStats2() {
                  this.aborted = false;
                  this.loaded = 0;
                  this.retry = 0;
                  this.total = 0;
                  this.chunkCount = 0;
                  this.bwEstimate = 0;
                  this.loading = {
                    start: 0,
                    first: 0,
                    end: 0
                  };
                  this.parsing = {
                    start: 0,
                    end: 0
                  };
                  this.buffering = {
                    start: 0,
                    first: 0,
                    end: 0
                  };
                };
              }
            ),
            /***/
            "./src/loader/m3u8-parser.ts": (
              /*!***********************************!*\
                !*** ./src/loader/m3u8-parser.ts ***!
                \***********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    M3U8Parser
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! url-toolkit */
                  "./node_modules/url-toolkit/src/url-toolkit.js"
                );
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);
                var _date_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./date-range */
                  "./src/loader/date-range.ts"
                );
                var _fragment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./fragment */
                  "./src/loader/fragment.ts"
                );
                var _level_details__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./level-details */
                  "./src/loader/level-details.ts"
                );
                var _level_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./level-key */
                  "./src/loader/level-key.ts"
                );
                var _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../utils/attr-list */
                  "./src/utils/attr-list.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _utils_codecs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ../utils/codecs */
                  "./src/utils/codecs.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+|#EXT-X-SESSION-KEY:([^\n\r]*)[\r\n]+/g;
                var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
                var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
                  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
                  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
                  /(?!#) *(\S[\S ]*)/.source,
                  // segment URI, group 3 => the URI (note newline is not eaten)
                  /#EXT-X-BYTERANGE:*(.+)/.source,
                  // next segment's byterange, group 4 => range spec (x@y)
                  /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
                  // next segment's program date/time group 5 => the datetime spec
                  /#.*/.source
                  // All other non-segment oriented tags will match with all groups empty
                ].join("|"), "g");
                var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
                var M3U8Parser = function() {
                  function M3U8Parser2() {
                  }
                  M3U8Parser2.findGroup = function findGroup(groups, mediaGroupId) {
                    for (var i = 0; i < groups.length; i++) {
                      var group = groups[i];
                      if (group.id === mediaGroupId) {
                        return group;
                      }
                    }
                  };
                  M3U8Parser2.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {
                    var avcdata = codec.split(".");
                    if (avcdata.length > 2) {
                      var result = avcdata.shift() + ".";
                      result += parseInt(avcdata.shift()).toString(16);
                      result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
                      return result;
                    }
                    return codec;
                  };
                  M3U8Parser2.resolve = function resolve(url, baseUrl) {
                    return (0, url_toolkit__WEBPACK_IMPORTED_MODULE_1__.buildAbsoluteURL)(baseUrl, url, {
                      alwaysNormalize: true
                    });
                  };
                  M3U8Parser2.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
                    var levels = [];
                    var levelsWithKnownCodecs = [];
                    var sessionData = {};
                    var sessionKeys = [];
                    var hasSessionData = false;
                    MASTER_PLAYLIST_REGEX.lastIndex = 0;
                    var result;
                    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
                      if (result[1]) {
                        var _level$unknownCodecs;
                        var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(result[1]);
                        var level = {
                          attrs,
                          bitrate: attrs.decimalInteger("AVERAGE-BANDWIDTH") || attrs.decimalInteger("BANDWIDTH"),
                          name: attrs.NAME,
                          url: M3U8Parser2.resolve(result[2], baseurl)
                        };
                        var resolution = attrs.decimalResolution("RESOLUTION");
                        if (resolution) {
                          level.width = resolution.width;
                          level.height = resolution.height;
                        }
                        setCodecs((attrs.CODECS || "").split(/[ ,]+/).filter(function(c) {
                          return c;
                        }), level);
                        if (level.videoCodec && level.videoCodec.indexOf("avc1") !== -1) {
                          level.videoCodec = M3U8Parser2.convertAVC1ToAVCOTI(level.videoCodec);
                        }
                        if (!((_level$unknownCodecs = level.unknownCodecs) !== null && _level$unknownCodecs !== void 0 && _level$unknownCodecs.length)) {
                          levelsWithKnownCodecs.push(level);
                        }
                        levels.push(level);
                      } else if (result[3]) {
                        var sessionAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(result[3]);
                        if (sessionAttrs["DATA-ID"]) {
                          hasSessionData = true;
                          sessionData[sessionAttrs["DATA-ID"]] = sessionAttrs;
                        }
                      } else if (result[4]) {
                        var keyTag = result[4];
                        var sessionKey = parseKey(keyTag, baseurl);
                        if (sessionKey.encrypted && sessionKey.isSupported()) {
                          sessionKeys.push(sessionKey);
                        } else {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn('[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "' + keyTag + '"');
                        }
                      }
                    }
                    var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < levels.length;
                    return {
                      levels: stripUnknownCodecLevels ? levelsWithKnownCodecs : levels,
                      sessionData: hasSessionData ? sessionData : null,
                      sessionKeys: sessionKeys.length ? sessionKeys : null
                    };
                  };
                  M3U8Parser2.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type, groups) {
                    if (groups === void 0) {
                      groups = [];
                    }
                    var result;
                    var medias = [];
                    var id = 0;
                    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
                    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
                      var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(result[1]);
                      if (attrs.TYPE === type) {
                        var media = {
                          attrs,
                          bitrate: 0,
                          id: id++,
                          groupId: attrs["GROUP-ID"],
                          instreamId: attrs["INSTREAM-ID"],
                          name: attrs.NAME || attrs.LANGUAGE || "",
                          type,
                          default: attrs.bool("DEFAULT"),
                          autoselect: attrs.bool("AUTOSELECT"),
                          forced: attrs.bool("FORCED"),
                          lang: attrs.LANGUAGE,
                          url: attrs.URI ? M3U8Parser2.resolve(attrs.URI, baseurl) : ""
                        };
                        if (groups.length) {
                          var groupCodec = M3U8Parser2.findGroup(groups, media.groupId) || groups[0];
                          assignCodec(media, groupCodec, "audioCodec");
                          assignCodec(media, groupCodec, "textCodec");
                        }
                        medias.push(media);
                      }
                    }
                    return medias;
                  };
                  M3U8Parser2.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
                    var level = new _level_details__WEBPACK_IMPORTED_MODULE_4__.LevelDetails(baseurl);
                    var fragments = level.fragments;
                    var currentInitSegment = null;
                    var currentSN = 0;
                    var currentPart = 0;
                    var totalduration = 0;
                    var discontinuityCounter = 0;
                    var prevFrag = null;
                    var frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Fragment(type, baseurl);
                    var result;
                    var i;
                    var levelkeys;
                    var firstPdtIndex = -1;
                    var createNextFrag = false;
                    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
                    level.m3u8 = string;
                    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
                      if (createNextFrag) {
                        createNextFrag = false;
                        frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Fragment(type, baseurl);
                        frag.start = totalduration;
                        frag.sn = currentSN;
                        frag.cc = discontinuityCounter;
                        frag.level = id;
                        if (currentInitSegment) {
                          frag.initSegment = currentInitSegment;
                          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                          currentInitSegment.rawProgramDateTime = null;
                        }
                      }
                      var duration = result[1];
                      if (duration) {
                        frag.duration = parseFloat(duration);
                        var title = (" " + result[2]).slice(1);
                        frag.title = title || null;
                        frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
                      } else if (result[3]) {
                        if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.duration)) {
                          frag.start = totalduration;
                          if (levelkeys) {
                            setFragLevelKeys(frag, levelkeys, level);
                          }
                          frag.sn = currentSN;
                          frag.level = id;
                          frag.cc = discontinuityCounter;
                          frag.urlId = levelUrlId;
                          fragments.push(frag);
                          frag.relurl = (" " + result[3]).slice(1);
                          assignProgramDateTime(frag, prevFrag);
                          prevFrag = frag;
                          totalduration += frag.duration;
                          currentSN++;
                          currentPart = 0;
                          createNextFrag = true;
                        }
                      } else if (result[4]) {
                        var data = (" " + result[4]).slice(1);
                        if (prevFrag) {
                          frag.setByteRange(data, prevFrag);
                        } else {
                          frag.setByteRange(data);
                        }
                      } else if (result[5]) {
                        frag.rawProgramDateTime = (" " + result[5]).slice(1);
                        frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
                        if (firstPdtIndex === -1) {
                          firstPdtIndex = fragments.length;
                        }
                      } else {
                        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
                        if (!result) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn("No matches on slow regex match for level playlist!");
                          continue;
                        }
                        for (i = 1; i < result.length; i++) {
                          if (typeof result[i] !== "undefined") {
                            break;
                          }
                        }
                        var tag = (" " + result[i]).slice(1);
                        var value1 = (" " + result[i + 1]).slice(1);
                        var value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : "";
                        switch (tag) {
                          case "PLAYLIST-TYPE":
                            level.type = value1.toUpperCase();
                            break;
                          case "MEDIA-SEQUENCE":
                            currentSN = level.startSN = parseInt(value1);
                            break;
                          case "SKIP": {
                            var skipAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            var skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
                            if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(skippedSegments)) {
                              level.skippedSegments = skippedSegments;
                              for (var _i = skippedSegments; _i--; ) {
                                fragments.unshift(null);
                              }
                              currentSN += skippedSegments;
                            }
                            var recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                            if (recentlyRemovedDateranges) {
                              level.recentlyRemovedDateranges = recentlyRemovedDateranges.split("	");
                            }
                            break;
                          }
                          case "TARGETDURATION":
                            level.targetduration = parseFloat(value1);
                            break;
                          case "VERSION":
                            level.version = parseInt(value1);
                            break;
                          case "EXTM3U":
                            break;
                          case "ENDLIST":
                            level.live = false;
                            break;
                          case "#":
                            if (value1 || value2) {
                              frag.tagList.push(value2 ? [value1, value2] : [value1]);
                            }
                            break;
                          case "DISCONTINUITY":
                            discontinuityCounter++;
                            frag.tagList.push(["DIS"]);
                            break;
                          case "GAP":
                            frag.tagList.push([tag]);
                            break;
                          case "BITRATE":
                            frag.tagList.push([tag, value1]);
                            break;
                          case "DATERANGE": {
                            var dateRangeAttr = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            var dateRange = new _date_range__WEBPACK_IMPORTED_MODULE_2__.DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
                            if (dateRange.isValid || level.skippedSegments) {
                              level.dateRanges[dateRange.id] = dateRange;
                            } else {
                              _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn('Ignoring invalid DATERANGE tag: "' + value1 + '"');
                            }
                            frag.tagList.push(["EXT-X-DATERANGE", value1]);
                            break;
                          }
                          case "DISCONTINUITY-SEQUENCE":
                            discontinuityCounter = parseInt(value1);
                            break;
                          case "KEY": {
                            var levelKey = parseKey(value1, baseurl);
                            if (levelKey.isSupported()) {
                              if (levelKey.method === "NONE") {
                                levelkeys = void 0;
                                break;
                              }
                              if (!levelkeys) {
                                levelkeys = {};
                              }
                              if (levelkeys[levelKey.keyFormat]) {
                                levelkeys = _extends({}, levelkeys);
                              }
                              levelkeys[levelKey.keyFormat] = levelKey;
                            } else {
                              _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn('[Keys] Ignoring invalid EXT-X-KEY tag: "' + value1 + '"');
                            }
                            break;
                          }
                          case "START": {
                            var startAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            var startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
                            if ((0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(startTimeOffset)) {
                              level.startTimeOffset = startTimeOffset;
                            }
                            break;
                          }
                          case "MAP": {
                            var mapAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            if (frag.duration) {
                              var init = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Fragment(type, baseurl);
                              setInitSegment(init, mapAttrs, id, levelkeys);
                              currentInitSegment = init;
                              frag.initSegment = currentInitSegment;
                              if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                                frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                              }
                            } else {
                              setInitSegment(frag, mapAttrs, id, levelkeys);
                              currentInitSegment = frag;
                              createNextFrag = true;
                            }
                            break;
                          }
                          case "SERVER-CONTROL": {
                            var serverControlAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
                            level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
                            level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
                            level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
                            level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
                            break;
                          }
                          case "PART-INF": {
                            var partInfAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
                            break;
                          }
                          case "PART": {
                            var partList = level.partList;
                            if (!partList) {
                              partList = level.partList = [];
                            }
                            var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : void 0;
                            var index = currentPart++;
                            var part = new _fragment__WEBPACK_IMPORTED_MODULE_3__.Part(new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1), frag, baseurl, index, previousFragmentPart);
                            partList.push(part);
                            frag.duration += part.duration;
                            break;
                          }
                          case "PRELOAD-HINT": {
                            var preloadHintAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            level.preloadHint = preloadHintAttrs;
                            break;
                          }
                          case "RENDITION-REPORT": {
                            var renditionReportAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(value1);
                            level.renditionReports = level.renditionReports || [];
                            level.renditionReports.push(renditionReportAttrs);
                            break;
                          }
                          default:
                            _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.warn("line parsed but not handled: " + result);
                            break;
                        }
                      }
                    }
                    if (prevFrag && !prevFrag.relurl) {
                      fragments.pop();
                      totalduration -= prevFrag.duration;
                      if (level.partList) {
                        level.fragmentHint = prevFrag;
                      }
                    } else if (level.partList) {
                      assignProgramDateTime(frag, prevFrag);
                      frag.cc = discontinuityCounter;
                      level.fragmentHint = frag;
                      if (levelkeys) {
                        setFragLevelKeys(frag, levelkeys, level);
                      }
                    }
                    var fragmentLength = fragments.length;
                    var firstFragment = fragments[0];
                    var lastFragment = fragments[fragmentLength - 1];
                    totalduration += level.skippedSegments * level.targetduration;
                    if (totalduration > 0 && fragmentLength && lastFragment) {
                      level.averagetargetduration = totalduration / fragmentLength;
                      var lastSn = lastFragment.sn;
                      level.endSN = lastSn !== "initSegment" ? lastSn : 0;
                      if (!level.live) {
                        lastFragment.endList = true;
                      }
                      if (firstFragment) {
                        level.startCC = firstFragment.cc;
                      }
                    } else {
                      level.endSN = 0;
                      level.startCC = 0;
                    }
                    if (level.fragmentHint) {
                      totalduration += level.fragmentHint.duration;
                    }
                    level.totalduration = totalduration;
                    level.endCC = discontinuityCounter;
                    if (firstPdtIndex > 0) {
                      backfillProgramDateTimes(fragments, firstPdtIndex);
                    }
                    return level;
                  };
                  return M3U8Parser2;
                }();
                function parseKey(keyTag, baseurl) {
                  var _keyAttrs$enumeratedS, _keyAttrs$enumeratedS2;
                  var keyAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList(keyTag);
                  var decryptmethod = (_keyAttrs$enumeratedS = keyAttrs.enumeratedString("METHOD")) != null ? _keyAttrs$enumeratedS : "";
                  var decrypturi = keyAttrs.URI;
                  var decryptiv = keyAttrs.hexadecimalInteger("IV");
                  var decryptkeyformatversions = keyAttrs.enumeratedString("KEYFORMATVERSIONS");
                  var decryptkeyformat = (_keyAttrs$enumeratedS2 = keyAttrs.enumeratedString("KEYFORMAT")) != null ? _keyAttrs$enumeratedS2 : "identity";
                  if (decrypturi && keyAttrs.IV && !decryptiv) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_7__.logger.error("Invalid IV: " + keyAttrs.IV);
                  }
                  var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
                  var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
                  return new _level_key__WEBPACK_IMPORTED_MODULE_5__.LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
                }
                function setCodecs(codecs, level) {
                  ["video", "audio", "text"].forEach(function(type) {
                    var filtered = codecs.filter(function(codec) {
                      return (0, _utils_codecs__WEBPACK_IMPORTED_MODULE_8__.isCodecType)(codec, type);
                    });
                    if (filtered.length) {
                      var preferred = filtered.filter(function(codec) {
                        return codec.lastIndexOf("avc1", 0) === 0 || codec.lastIndexOf("mp4a", 0) === 0;
                      });
                      level[type + "Codec"] = preferred.length > 0 ? preferred[0] : filtered[0];
                      codecs = codecs.filter(function(codec) {
                        return filtered.indexOf(codec) === -1;
                      });
                    }
                  });
                  level.unknownCodecs = codecs;
                }
                function assignCodec(media, groupItem, codecProperty) {
                  var codecValue = groupItem[codecProperty];
                  if (codecValue) {
                    media[codecProperty] = codecValue;
                  }
                }
                function backfillProgramDateTimes(fragments, firstPdtIndex) {
                  var fragPrev = fragments[firstPdtIndex];
                  for (var i = firstPdtIndex; i--; ) {
                    var frag = fragments[i];
                    if (!frag) {
                      return;
                    }
                    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
                    fragPrev = frag;
                  }
                }
                function assignProgramDateTime(frag, prevFrag) {
                  if (frag.rawProgramDateTime) {
                    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
                  } else if (prevFrag !== null && prevFrag !== void 0 && prevFrag.programDateTime) {
                    frag.programDateTime = prevFrag.endProgramDateTime;
                  }
                  if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(frag.programDateTime)) {
                    frag.programDateTime = null;
                    frag.rawProgramDateTime = null;
                  }
                }
                function setInitSegment(frag, mapAttrs, id, levelkeys) {
                  frag.relurl = mapAttrs.URI;
                  if (mapAttrs.BYTERANGE) {
                    frag.setByteRange(mapAttrs.BYTERANGE);
                  }
                  frag.level = id;
                  frag.sn = "initSegment";
                  if (levelkeys) {
                    frag.levelkeys = levelkeys;
                  }
                  frag.initSegment = null;
                }
                function setFragLevelKeys(frag, levelkeys, level) {
                  frag.levelkeys = levelkeys;
                  var encryptedFragments = level.encryptedFragments;
                  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function(format) {
                    return levelkeys[format].isCommonEncryption;
                  })) {
                    encryptedFragments.push(frag);
                  }
                }
              }
            ),
            /***/
            "./src/loader/playlist-loader.ts": (
              /*!***************************************!*\
                !*** ./src/loader/playlist-loader.ts ***!
                \***************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./m3u8-parser */
                  "./src/loader/m3u8-parser.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../utils/attr-list */
                  "./src/utils/attr-list.ts"
                );
                function mapContextToLevelType(context) {
                  var type = context.type;
                  switch (type) {
                    case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:
                      return _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistLevelType.AUDIO;
                    case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:
                      return _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistLevelType.SUBTITLE;
                    default:
                      return _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistLevelType.MAIN;
                  }
                }
                function getResponseUrl(response, context) {
                  var url = response.url;
                  if (url === void 0 || url.indexOf("data:") === 0) {
                    url = context.url;
                  }
                  return url;
                }
                var PlaylistLoader = function() {
                  function PlaylistLoader2(hls) {
                    this.hls = void 0;
                    this.loaders = /* @__PURE__ */ Object.create(null);
                    this.hls = hls;
                    this.registerListeners();
                  }
                  var _proto = PlaylistLoader2.prototype;
                  _proto.startLoad = function startLoad(startPosition) {
                  };
                  _proto.stopLoad = function stopLoad() {
                    this.destroyInternalLoaders();
                  };
                  _proto.registerListeners = function registerListeners() {
                    var hls = this.hls;
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADING, this.onLevelLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
                    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
                  };
                  _proto.unregisterListeners = function unregisterListeners() {
                    var hls = this.hls;
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADING, this.onManifestLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADING, this.onLevelLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
                    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
                  };
                  _proto.createInternalLoader = function createInternalLoader(context) {
                    var config = this.hls.config;
                    var PLoader = config.pLoader;
                    var Loader = config.loader;
                    var InternalLoader = PLoader || Loader;
                    var loader = new InternalLoader(config);
                    context.loader = loader;
                    this.loaders[context.type] = loader;
                    return loader;
                  };
                  _proto.getInternalLoader = function getInternalLoader(context) {
                    return this.loaders[context.type];
                  };
                  _proto.resetInternalLoader = function resetInternalLoader(contextType) {
                    if (this.loaders[contextType]) {
                      delete this.loaders[contextType];
                    }
                  };
                  _proto.destroyInternalLoaders = function destroyInternalLoaders() {
                    for (var contextType in this.loaders) {
                      var loader = this.loaders[contextType];
                      if (loader) {
                        loader.destroy();
                      }
                      this.resetInternalLoader(contextType);
                    }
                  };
                  _proto.destroy = function destroy() {
                    this.unregisterListeners();
                    this.destroyInternalLoaders();
                  };
                  _proto.onManifestLoading = function onManifestLoading(event, data) {
                    var url = data.url;
                    this.load({
                      id: null,
                      groupId: null,
                      level: 0,
                      responseType: "text",
                      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST,
                      url,
                      deliveryDirectives: null
                    });
                  };
                  _proto.onLevelLoading = function onLevelLoading(event, data) {
                    var id = data.id, level = data.level, url = data.url, deliveryDirectives = data.deliveryDirectives;
                    this.load({
                      id,
                      groupId: null,
                      level,
                      responseType: "text",
                      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL,
                      url,
                      deliveryDirectives
                    });
                  };
                  _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {
                    var id = data.id, groupId = data.groupId, url = data.url, deliveryDirectives = data.deliveryDirectives;
                    this.load({
                      id,
                      groupId,
                      level: null,
                      responseType: "text",
                      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK,
                      url,
                      deliveryDirectives
                    });
                  };
                  _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {
                    var id = data.id, groupId = data.groupId, url = data.url, deliveryDirectives = data.deliveryDirectives;
                    this.load({
                      id,
                      groupId,
                      level: null,
                      responseType: "text",
                      type: _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK,
                      url,
                      deliveryDirectives
                    });
                  };
                  _proto.load = function load(context) {
                    var _context$deliveryDire;
                    var config = this.hls.config;
                    var loader = this.getInternalLoader(context);
                    if (loader) {
                      var loaderContext = loader.context;
                      if (loaderContext && loaderContext.url === context.url) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.trace("[playlist-loader]: playlist request ongoing");
                        return;
                      }
                      _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log("[playlist-loader]: aborting previous loader for type: " + context.type);
                      loader.abort();
                    }
                    var maxRetry;
                    var timeout;
                    var retryDelay;
                    var maxRetryDelay;
                    switch (context.type) {
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST:
                        maxRetry = config.manifestLoadingMaxRetry;
                        timeout = config.manifestLoadingTimeOut;
                        retryDelay = config.manifestLoadingRetryDelay;
                        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
                        break;
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL:
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:
                        maxRetry = 0;
                        timeout = config.levelLoadingTimeOut;
                        break;
                      default:
                        maxRetry = config.levelLoadingMaxRetry;
                        timeout = config.levelLoadingTimeOut;
                        retryDelay = config.levelLoadingRetryDelay;
                        maxRetryDelay = config.levelLoadingMaxRetryTimeout;
                        break;
                    }
                    loader = this.createInternalLoader(context);
                    if ((_context$deliveryDire = context.deliveryDirectives) !== null && _context$deliveryDire !== void 0 && _context$deliveryDire.part) {
                      var levelDetails;
                      if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL && context.level !== null) {
                        levelDetails = this.hls.levels[context.level].details;
                      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK && context.id !== null) {
                        levelDetails = this.hls.audioTracks[context.id].details;
                      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
                        levelDetails = this.hls.subtitleTracks[context.id].details;
                      }
                      if (levelDetails) {
                        var partTarget = levelDetails.partTarget;
                        var targetDuration = levelDetails.targetduration;
                        if (partTarget && targetDuration) {
                          timeout = Math.min(Math.max(partTarget * 3, targetDuration * 0.8) * 1e3, timeout);
                        }
                      }
                    }
                    var loaderConfig = {
                      timeout,
                      maxRetry,
                      retryDelay,
                      maxRetryDelay,
                      highWaterMark: 0
                    };
                    var loaderCallbacks = {
                      onSuccess: this.loadsuccess.bind(this),
                      onError: this.loaderror.bind(this),
                      onTimeout: this.loadtimeout.bind(this)
                    };
                    loader.load(context, loaderConfig, loaderCallbacks);
                  };
                  _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {
                    if (networkDetails === void 0) {
                      networkDetails = null;
                    }
                    this.resetInternalLoader(context.type);
                    var string = response.data;
                    if (string.indexOf("#EXTM3U") !== 0) {
                      this.handleManifestParsingError(response, context, "no EXTM3U delimiter", networkDetails);
                      return;
                    }
                    stats.parsing.start = performance.now();
                    if (string.indexOf("#EXTINF:") > 0 || string.indexOf("#EXT-X-TARGETDURATION:") > 0) {
                      this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
                    } else {
                      this.handleMasterPlaylist(response, stats, context, networkDetails);
                    }
                  };
                  _proto.loaderror = function loaderror(response, context, networkDetails) {
                    if (networkDetails === void 0) {
                      networkDetails = null;
                    }
                    this.handleNetworkError(context, networkDetails, false, response);
                  };
                  _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {
                    if (networkDetails === void 0) {
                      networkDetails = null;
                    }
                    this.handleNetworkError(context, networkDetails, true);
                  };
                  _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {
                    var hls = this.hls;
                    var string = response.data;
                    var url = getResponseUrl(response, context);
                    var _M3U8Parser$parseMast = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__["default"].parseMasterPlaylist(string, url), levels = _M3U8Parser$parseMast.levels, sessionData = _M3U8Parser$parseMast.sessionData, sessionKeys = _M3U8Parser$parseMast.sessionKeys;
                    if (!levels.length) {
                      this.handleManifestParsingError(response, context, "no level found in manifest", networkDetails);
                      return;
                    }
                    var audioGroups = levels.map(function(level) {
                      return {
                        id: level.attrs.AUDIO,
                        audioCodec: level.audioCodec
                      };
                    });
                    var subtitleGroups = levels.map(function(level) {
                      return {
                        id: level.attrs.SUBTITLES,
                        textCodec: level.textCodec
                      };
                    });
                    var audioTracks = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__["default"].parseMasterPlaylistMedia(string, url, "AUDIO", audioGroups);
                    var subtitles = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__["default"].parseMasterPlaylistMedia(string, url, "SUBTITLES", subtitleGroups);
                    var captions = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__["default"].parseMasterPlaylistMedia(string, url, "CLOSED-CAPTIONS");
                    if (audioTracks.length) {
                      var embeddedAudioFound = audioTracks.some(function(audioTrack) {
                        return !audioTrack.url;
                      });
                      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
                        audioTracks.unshift({
                          type: "main",
                          name: "main",
                          default: false,
                          autoselect: false,
                          forced: false,
                          id: -1,
                          attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList({}),
                          bitrate: 0,
                          url: ""
                        });
                      }
                    }
                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, {
                      levels,
                      audioTracks,
                      subtitles,
                      captions,
                      url,
                      stats,
                      networkDetails,
                      sessionData,
                      sessionKeys
                    });
                  };
                  _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
                    var hls = this.hls;
                    var id = context.id, level = context.level, type = context.type;
                    var url = getResponseUrl(response, context);
                    var levelUrlId = (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(id) ? id : 0;
                    var levelId = (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(level) ? level : levelUrlId;
                    var levelType = mapContextToLevelType(context);
                    var levelDetails = _m3u8_parser__WEBPACK_IMPORTED_MODULE_4__["default"].parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);
                    if (!levelDetails.fragments.length) {
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.NETWORK_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_EMPTY_ERROR,
                        fatal: false,
                        url,
                        reason: "no fragments found in level",
                        level: typeof context.level === "number" ? context.level : void 0
                      });
                      return;
                    }
                    if (type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST) {
                      var singleLevel = {
                        attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__.AttrList({}),
                        bitrate: 0,
                        details: levelDetails,
                        name: "",
                        url
                      };
                      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.MANIFEST_LOADED, {
                        levels: [singleLevel],
                        audioTracks: [],
                        url,
                        stats,
                        networkDetails,
                        sessionData: null,
                        sessionKeys: null
                      });
                    }
                    stats.parsing.end = performance.now();
                    context.levelDetails = levelDetails;
                    this.handlePlaylistLoaded(response, stats, context, networkDetails);
                  };
                  _proto.handleManifestParsingError = function handleManifestParsingError(response, context, reason, networkDetails) {
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, {
                      type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.NETWORK_ERROR,
                      details: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_PARSING_ERROR,
                      fatal: context.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST,
                      url: response.url,
                      reason,
                      response,
                      context,
                      networkDetails
                    });
                  };
                  _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response) {
                    if (timeout === void 0) {
                      timeout = false;
                    }
                    _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.warn("[playlist-loader]: A network " + (timeout ? "timeout" : "error") + " occurred while loading " + context.type + " level: " + context.level + " id: " + context.id + ' group-id: "' + context.groupId + '"');
                    var details = _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.UNKNOWN;
                    var fatal = false;
                    var loader = this.getInternalLoader(context);
                    switch (context.type) {
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST:
                        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.MANIFEST_LOAD_ERROR;
                        fatal = true;
                        break;
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL:
                        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.LEVEL_LOAD_ERROR;
                        fatal = false;
                        break;
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:
                        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
                        fatal = false;
                        break;
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:
                        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorDetails.SUBTITLE_LOAD_ERROR;
                        fatal = false;
                        break;
                    }
                    if (loader) {
                      this.resetInternalLoader(context.type);
                    }
                    var errorData = {
                      type: _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorTypes.NETWORK_ERROR,
                      details,
                      fatal,
                      url: context.url,
                      loader,
                      context,
                      networkDetails
                    };
                    if (response) {
                      errorData.response = response;
                    }
                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.ERROR, errorData);
                  };
                  _proto.handlePlaylistLoaded = function handlePlaylistLoaded(response, stats, context, networkDetails) {
                    var type = context.type, level = context.level, id = context.id, groupId = context.groupId, loader = context.loader, levelDetails = context.levelDetails, deliveryDirectives = context.deliveryDirectives;
                    if (!(levelDetails !== null && levelDetails !== void 0 && levelDetails.targetduration)) {
                      this.handleManifestParsingError(response, context, "invalid target duration", networkDetails);
                      return;
                    }
                    if (!loader) {
                      return;
                    }
                    if (levelDetails.live) {
                      if (loader.getCacheAge) {
                        levelDetails.ageHeader = loader.getCacheAge() || 0;
                      }
                      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
                        levelDetails.ageHeader = 0;
                      }
                    }
                    switch (type) {
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.MANIFEST:
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.LEVEL:
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.LEVEL_LOADED, {
                          details: levelDetails,
                          level: level || 0,
                          id: id || 0,
                          stats,
                          networkDetails,
                          deliveryDirectives
                        });
                        break;
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.AUDIO_TRACK:
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.AUDIO_TRACK_LOADED, {
                          details: levelDetails,
                          id: id || 0,
                          groupId: groupId || "",
                          stats,
                          networkDetails,
                          deliveryDirectives
                        });
                        break;
                      case _types_loader__WEBPACK_IMPORTED_MODULE_5__.PlaylistContextType.SUBTITLE_TRACK:
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__.Events.SUBTITLE_TRACK_LOADED, {
                          details: levelDetails,
                          id: id || 0,
                          groupId: groupId || "",
                          stats,
                          networkDetails,
                          deliveryDirectives
                        });
                        break;
                    }
                  };
                  return PlaylistLoader2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = PlaylistLoader;
              }
            ),
            /***/
            "./src/polyfills/number.ts": (
              /*!*********************************!*\
                !*** ./src/polyfills/number.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "MAX_SAFE_INTEGER": () => (
                    /* binding */
                    MAX_SAFE_INTEGER
                  ),
                  /* harmony export */
                  "isFiniteNumber": () => (
                    /* binding */
                    isFiniteNumber
                  )
                  /* harmony export */
                });
                var isFiniteNumber = Number.isFinite || function(value) {
                  return typeof value === "number" && isFinite(value);
                };
                var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
              }
            ),
            /***/
            "./src/remux/aac-helper.ts": (
              /*!*********************************!*\
                !*** ./src/remux/aac-helper.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var AAC = function() {
                  function AAC2() {
                  }
                  AAC2.getSilentFrame = function getSilentFrame(codec, channelCount) {
                    switch (codec) {
                      case "mp4a.40.2":
                        if (channelCount === 1) {
                          return new Uint8Array([0, 200, 0, 128, 35, 128]);
                        } else if (channelCount === 2) {
                          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                        } else if (channelCount === 3) {
                          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                        } else if (channelCount === 4) {
                          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                        } else if (channelCount === 5) {
                          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                        } else if (channelCount === 6) {
                          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                        }
                        break;
                      default:
                        if (channelCount === 1) {
                          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        } else if (channelCount === 2) {
                          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        } else if (channelCount === 3) {
                          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        }
                        break;
                    }
                    return void 0;
                  };
                  return AAC2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = AAC;
              }
            ),
            /***/
            "./src/remux/mp4-generator.ts": (
              /*!************************************!*\
                !*** ./src/remux/mp4-generator.ts ***!
                \************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var UINT32_MAX = Math.pow(2, 32) - 1;
                var MP4 = function() {
                  function MP42() {
                  }
                  MP42.init = function init() {
                    MP42.types = {
                      avc1: [],
                      // codingname
                      avcC: [],
                      btrt: [],
                      dinf: [],
                      dref: [],
                      esds: [],
                      ftyp: [],
                      hdlr: [],
                      mdat: [],
                      mdhd: [],
                      mdia: [],
                      mfhd: [],
                      minf: [],
                      moof: [],
                      moov: [],
                      mp4a: [],
                      ".mp3": [],
                      mvex: [],
                      mvhd: [],
                      pasp: [],
                      sdtp: [],
                      stbl: [],
                      stco: [],
                      stsc: [],
                      stsd: [],
                      stsz: [],
                      stts: [],
                      tfdt: [],
                      tfhd: [],
                      traf: [],
                      trak: [],
                      trun: [],
                      trex: [],
                      tkhd: [],
                      vmhd: [],
                      smhd: []
                    };
                    var i;
                    for (i in MP42.types) {
                      if (MP42.types.hasOwnProperty(i)) {
                        MP42.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
                      }
                    }
                    var videoHdlr = new Uint8Array([
                      0,
                      // version 0
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      0,
                      // pre_defined
                      118,
                      105,
                      100,
                      101,
                      // handler_type: 'vide'
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      86,
                      105,
                      100,
                      101,
                      111,
                      72,
                      97,
                      110,
                      100,
                      108,
                      101,
                      114,
                      0
                      // name: 'VideoHandler'
                    ]);
                    var audioHdlr = new Uint8Array([
                      0,
                      // version 0
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      0,
                      // pre_defined
                      115,
                      111,
                      117,
                      110,
                      // handler_type: 'soun'
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      83,
                      111,
                      117,
                      110,
                      100,
                      72,
                      97,
                      110,
                      100,
                      108,
                      101,
                      114,
                      0
                      // name: 'SoundHandler'
                    ]);
                    MP42.HDLR_TYPES = {
                      video: videoHdlr,
                      audio: audioHdlr
                    };
                    var dref = new Uint8Array([
                      0,
                      // version 0
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      1,
                      // entry_count
                      0,
                      0,
                      0,
                      12,
                      // entry_size
                      117,
                      114,
                      108,
                      32,
                      // 'url' type
                      0,
                      // version 0
                      0,
                      0,
                      1
                      // entry_flags
                    ]);
                    var stco = new Uint8Array([
                      0,
                      // version
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      0
                      // entry_count
                    ]);
                    MP42.STTS = MP42.STSC = MP42.STCO = stco;
                    MP42.STSZ = new Uint8Array([
                      0,
                      // version
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      0,
                      // sample_size
                      0,
                      0,
                      0,
                      0
                      // sample_count
                    ]);
                    MP42.VMHD = new Uint8Array([
                      0,
                      // version
                      0,
                      0,
                      1,
                      // flags
                      0,
                      0,
                      // graphicsmode
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                      // opcolor
                    ]);
                    MP42.SMHD = new Uint8Array([
                      0,
                      // version
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      // balance
                      0,
                      0
                      // reserved
                    ]);
                    MP42.STSD = new Uint8Array([
                      0,
                      // version 0
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      1
                    ]);
                    var majorBrand = new Uint8Array([105, 115, 111, 109]);
                    var avc1Brand = new Uint8Array([97, 118, 99, 49]);
                    var minorVersion = new Uint8Array([0, 0, 0, 1]);
                    MP42.FTYP = MP42.box(MP42.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
                    MP42.DINF = MP42.box(MP42.types.dinf, MP42.box(MP42.types.dref, dref));
                  };
                  MP42.box = function box(type) {
                    var size = 8;
                    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      payload[_key - 1] = arguments[_key];
                    }
                    var i = payload.length;
                    var len = i;
                    while (i--) {
                      size += payload[i].byteLength;
                    }
                    var result = new Uint8Array(size);
                    result[0] = size >> 24 & 255;
                    result[1] = size >> 16 & 255;
                    result[2] = size >> 8 & 255;
                    result[3] = size & 255;
                    result.set(type, 4);
                    for (i = 0, size = 8; i < len; i++) {
                      result.set(payload[i], size);
                      size += payload[i].byteLength;
                    }
                    return result;
                  };
                  MP42.hdlr = function hdlr(type) {
                    return MP42.box(MP42.types.hdlr, MP42.HDLR_TYPES[type]);
                  };
                  MP42.mdat = function mdat(data) {
                    return MP42.box(MP42.types.mdat, data);
                  };
                  MP42.mdhd = function mdhd(timescale, duration) {
                    duration *= timescale;
                    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                    return MP42.box(MP42.types.mdhd, new Uint8Array([
                      1,
                      // version 1
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      2,
                      // creation_time
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      3,
                      // modification_time
                      timescale >> 24 & 255,
                      timescale >> 16 & 255,
                      timescale >> 8 & 255,
                      timescale & 255,
                      // timescale
                      upperWordDuration >> 24,
                      upperWordDuration >> 16 & 255,
                      upperWordDuration >> 8 & 255,
                      upperWordDuration & 255,
                      lowerWordDuration >> 24,
                      lowerWordDuration >> 16 & 255,
                      lowerWordDuration >> 8 & 255,
                      lowerWordDuration & 255,
                      85,
                      196,
                      // 'und' language (undetermined)
                      0,
                      0
                    ]));
                  };
                  MP42.mdia = function mdia(track) {
                    return MP42.box(MP42.types.mdia, MP42.mdhd(track.timescale, track.duration), MP42.hdlr(track.type), MP42.minf(track));
                  };
                  MP42.mfhd = function mfhd(sequenceNumber) {
                    return MP42.box(MP42.types.mfhd, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      // flags
                      sequenceNumber >> 24,
                      sequenceNumber >> 16 & 255,
                      sequenceNumber >> 8 & 255,
                      sequenceNumber & 255
                      // sequence_number
                    ]));
                  };
                  MP42.minf = function minf(track) {
                    if (track.type === "audio") {
                      return MP42.box(MP42.types.minf, MP42.box(MP42.types.smhd, MP42.SMHD), MP42.DINF, MP42.stbl(track));
                    } else {
                      return MP42.box(MP42.types.minf, MP42.box(MP42.types.vmhd, MP42.VMHD), MP42.DINF, MP42.stbl(track));
                    }
                  };
                  MP42.moof = function moof(sn, baseMediaDecodeTime, track) {
                    return MP42.box(MP42.types.moof, MP42.mfhd(sn), MP42.traf(track, baseMediaDecodeTime));
                  };
                  MP42.moov = function moov(tracks) {
                    var i = tracks.length;
                    var boxes = [];
                    while (i--) {
                      boxes[i] = MP42.trak(tracks[i]);
                    }
                    return MP42.box.apply(null, [MP42.types.moov, MP42.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP42.mvex(tracks)));
                  };
                  MP42.mvex = function mvex(tracks) {
                    var i = tracks.length;
                    var boxes = [];
                    while (i--) {
                      boxes[i] = MP42.trex(tracks[i]);
                    }
                    return MP42.box.apply(null, [MP42.types.mvex].concat(boxes));
                  };
                  MP42.mvhd = function mvhd(timescale, duration) {
                    duration *= timescale;
                    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                    var bytes = new Uint8Array([
                      1,
                      // version 1
                      0,
                      0,
                      0,
                      // flags
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      2,
                      // creation_time
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      3,
                      // modification_time
                      timescale >> 24 & 255,
                      timescale >> 16 & 255,
                      timescale >> 8 & 255,
                      timescale & 255,
                      // timescale
                      upperWordDuration >> 24,
                      upperWordDuration >> 16 & 255,
                      upperWordDuration >> 8 & 255,
                      upperWordDuration & 255,
                      lowerWordDuration >> 24,
                      lowerWordDuration >> 16 & 255,
                      lowerWordDuration >> 8 & 255,
                      lowerWordDuration & 255,
                      0,
                      1,
                      0,
                      0,
                      // 1.0 rate
                      1,
                      0,
                      // 1.0 volume
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      // transformation: unity matrix
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      // pre_defined
                      255,
                      255,
                      255,
                      255
                      // next_track_ID
                    ]);
                    return MP42.box(MP42.types.mvhd, bytes);
                  };
                  MP42.sdtp = function sdtp(track) {
                    var samples = track.samples || [];
                    var bytes = new Uint8Array(4 + samples.length);
                    var i;
                    var flags;
                    for (i = 0; i < samples.length; i++) {
                      flags = samples[i].flags;
                      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
                    }
                    return MP42.box(MP42.types.sdtp, bytes);
                  };
                  MP42.stbl = function stbl(track) {
                    return MP42.box(MP42.types.stbl, MP42.stsd(track), MP42.box(MP42.types.stts, MP42.STTS), MP42.box(MP42.types.stsc, MP42.STSC), MP42.box(MP42.types.stsz, MP42.STSZ), MP42.box(MP42.types.stco, MP42.STCO));
                  };
                  MP42.avc1 = function avc1(track) {
                    var sps = [];
                    var pps = [];
                    var i;
                    var data;
                    var len;
                    for (i = 0; i < track.sps.length; i++) {
                      data = track.sps[i];
                      len = data.byteLength;
                      sps.push(len >>> 8 & 255);
                      sps.push(len & 255);
                      sps = sps.concat(Array.prototype.slice.call(data));
                    }
                    for (i = 0; i < track.pps.length; i++) {
                      data = track.pps[i];
                      len = data.byteLength;
                      pps.push(len >>> 8 & 255);
                      pps.push(len & 255);
                      pps = pps.concat(Array.prototype.slice.call(data));
                    }
                    var avcc = MP42.box(MP42.types.avcC, new Uint8Array([
                      1,
                      // version
                      sps[3],
                      // profile
                      sps[4],
                      // profile compat
                      sps[5],
                      // level
                      252 | 3,
                      // lengthSizeMinusOne, hard-coded to 4 bytes
                      224 | track.sps.length
                      // 3bit reserved (111) + numOfSequenceParameterSets
                    ].concat(sps).concat([
                      track.pps.length
                      // numOfPictureParameterSets
                    ]).concat(pps)));
                    var width = track.width;
                    var height = track.height;
                    var hSpacing = track.pixelRatio[0];
                    var vSpacing = track.pixelRatio[1];
                    return MP42.box(
                      MP42.types.avc1,
                      new Uint8Array([
                        0,
                        0,
                        0,
                        // reserved
                        0,
                        0,
                        0,
                        // reserved
                        0,
                        1,
                        // data_reference_index
                        0,
                        0,
                        // pre_defined
                        0,
                        0,
                        // reserved
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        // pre_defined
                        width >> 8 & 255,
                        width & 255,
                        // width
                        height >> 8 & 255,
                        height & 255,
                        // height
                        0,
                        72,
                        0,
                        0,
                        // horizresolution
                        0,
                        72,
                        0,
                        0,
                        // vertresolution
                        0,
                        0,
                        0,
                        0,
                        // reserved
                        0,
                        1,
                        // frame_count
                        18,
                        100,
                        97,
                        105,
                        108,
                        // dailymotion/hls.js
                        121,
                        109,
                        111,
                        116,
                        105,
                        111,
                        110,
                        47,
                        104,
                        108,
                        115,
                        46,
                        106,
                        115,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        // compressorname
                        0,
                        24,
                        // depth = 24
                        17,
                        17
                      ]),
                      // pre_defined = -1
                      avcc,
                      MP42.box(MP42.types.btrt, new Uint8Array([
                        0,
                        28,
                        156,
                        128,
                        // bufferSizeDB
                        0,
                        45,
                        198,
                        192,
                        // maxBitrate
                        0,
                        45,
                        198,
                        192
                      ])),
                      // avgBitrate
                      MP42.box(MP42.types.pasp, new Uint8Array([
                        hSpacing >> 24,
                        // hSpacing
                        hSpacing >> 16 & 255,
                        hSpacing >> 8 & 255,
                        hSpacing & 255,
                        vSpacing >> 24,
                        // vSpacing
                        vSpacing >> 16 & 255,
                        vSpacing >> 8 & 255,
                        vSpacing & 255
                      ]))
                    );
                  };
                  MP42.esds = function esds(track) {
                    var configlen = track.config.length;
                    return new Uint8Array([
                      0,
                      // version 0
                      0,
                      0,
                      0,
                      // flags
                      3,
                      // descriptor_type
                      23 + configlen,
                      // length
                      0,
                      1,
                      // es_id
                      0,
                      // stream_priority
                      4,
                      // descriptor_type
                      15 + configlen,
                      // length
                      64,
                      // codec : mpeg4_audio
                      21,
                      // stream_type
                      0,
                      0,
                      0,
                      // buffer_size
                      0,
                      0,
                      0,
                      0,
                      // maxBitrate
                      0,
                      0,
                      0,
                      0,
                      // avgBitrate
                      5
                      // descriptor_type
                    ].concat([configlen]).concat(track.config).concat([6, 1, 2]));
                  };
                  MP42.mp4a = function mp4a(track) {
                    var samplerate = track.samplerate;
                    return MP42.box(MP42.types.mp4a, new Uint8Array([
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      1,
                      // data_reference_index
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      track.channelCount,
                      // channelcount
                      0,
                      16,
                      // sampleSize:16bits
                      0,
                      0,
                      0,
                      0,
                      // reserved2
                      samplerate >> 8 & 255,
                      samplerate & 255,
                      //
                      0,
                      0
                    ]), MP42.box(MP42.types.esds, MP42.esds(track)));
                  };
                  MP42.mp3 = function mp3(track) {
                    var samplerate = track.samplerate;
                    return MP42.box(MP42.types[".mp3"], new Uint8Array([
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      1,
                      // data_reference_index
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      track.channelCount,
                      // channelcount
                      0,
                      16,
                      // sampleSize:16bits
                      0,
                      0,
                      0,
                      0,
                      // reserved2
                      samplerate >> 8 & 255,
                      samplerate & 255,
                      //
                      0,
                      0
                    ]));
                  };
                  MP42.stsd = function stsd(track) {
                    if (track.type === "audio") {
                      if (track.segmentCodec === "mp3" && track.codec === "mp3") {
                        return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp3(track));
                      }
                      return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp4a(track));
                    } else {
                      return MP42.box(MP42.types.stsd, MP42.STSD, MP42.avc1(track));
                    }
                  };
                  MP42.tkhd = function tkhd(track) {
                    var id = track.id;
                    var duration = track.duration * track.timescale;
                    var width = track.width;
                    var height = track.height;
                    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                    return MP42.box(MP42.types.tkhd, new Uint8Array([
                      1,
                      // version 1
                      0,
                      0,
                      7,
                      // flags
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      2,
                      // creation_time
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      3,
                      // modification_time
                      id >> 24 & 255,
                      id >> 16 & 255,
                      id >> 8 & 255,
                      id & 255,
                      // track_ID
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      upperWordDuration >> 24,
                      upperWordDuration >> 16 & 255,
                      upperWordDuration >> 8 & 255,
                      upperWordDuration & 255,
                      lowerWordDuration >> 24,
                      lowerWordDuration >> 16 & 255,
                      lowerWordDuration >> 8 & 255,
                      lowerWordDuration & 255,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      // layer
                      0,
                      0,
                      // alternate_group
                      0,
                      0,
                      // non-audio track volume
                      0,
                      0,
                      // reserved
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      // transformation: unity matrix
                      width >> 8 & 255,
                      width & 255,
                      0,
                      0,
                      // width
                      height >> 8 & 255,
                      height & 255,
                      0,
                      0
                      // height
                    ]));
                  };
                  MP42.traf = function traf(track, baseMediaDecodeTime) {
                    var sampleDependencyTable = MP42.sdtp(track);
                    var id = track.id;
                    var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
                    var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                    return MP42.box(
                      MP42.types.traf,
                      MP42.box(MP42.types.tfhd, new Uint8Array([
                        0,
                        // version 0
                        0,
                        0,
                        0,
                        // flags
                        id >> 24,
                        id >> 16 & 255,
                        id >> 8 & 255,
                        id & 255
                        // track_ID
                      ])),
                      MP42.box(MP42.types.tfdt, new Uint8Array([
                        1,
                        // version 1
                        0,
                        0,
                        0,
                        // flags
                        upperWordBaseMediaDecodeTime >> 24,
                        upperWordBaseMediaDecodeTime >> 16 & 255,
                        upperWordBaseMediaDecodeTime >> 8 & 255,
                        upperWordBaseMediaDecodeTime & 255,
                        lowerWordBaseMediaDecodeTime >> 24,
                        lowerWordBaseMediaDecodeTime >> 16 & 255,
                        lowerWordBaseMediaDecodeTime >> 8 & 255,
                        lowerWordBaseMediaDecodeTime & 255
                      ])),
                      MP42.trun(track, sampleDependencyTable.length + 16 + // tfhd
                      20 + // tfdt
                      8 + // traf header
                      16 + // mfhd
                      8 + // moof header
                      8),
                      // mdat header
                      sampleDependencyTable
                    );
                  };
                  MP42.trak = function trak(track) {
                    track.duration = track.duration || 4294967295;
                    return MP42.box(MP42.types.trak, MP42.tkhd(track), MP42.mdia(track));
                  };
                  MP42.trex = function trex(track) {
                    var id = track.id;
                    return MP42.box(MP42.types.trex, new Uint8Array([
                      0,
                      // version 0
                      0,
                      0,
                      0,
                      // flags
                      id >> 24,
                      id >> 16 & 255,
                      id >> 8 & 255,
                      id & 255,
                      // track_ID
                      0,
                      0,
                      0,
                      1,
                      // default_sample_description_index
                      0,
                      0,
                      0,
                      0,
                      // default_sample_duration
                      0,
                      0,
                      0,
                      0,
                      // default_sample_size
                      0,
                      1,
                      0,
                      1
                      // default_sample_flags
                    ]));
                  };
                  MP42.trun = function trun(track, offset) {
                    var samples = track.samples || [];
                    var len = samples.length;
                    var arraylen = 12 + 16 * len;
                    var array = new Uint8Array(arraylen);
                    var i;
                    var sample;
                    var duration;
                    var size;
                    var flags;
                    var cts;
                    offset += 8 + arraylen;
                    array.set([
                      track.type === "video" ? 1 : 0,
                      // version 1 for video with signed-int sample_composition_time_offset
                      0,
                      15,
                      1,
                      // flags
                      len >>> 24 & 255,
                      len >>> 16 & 255,
                      len >>> 8 & 255,
                      len & 255,
                      // sample_count
                      offset >>> 24 & 255,
                      offset >>> 16 & 255,
                      offset >>> 8 & 255,
                      offset & 255
                      // data_offset
                    ], 0);
                    for (i = 0; i < len; i++) {
                      sample = samples[i];
                      duration = sample.duration;
                      size = sample.size;
                      flags = sample.flags;
                      cts = sample.cts;
                      array.set([
                        duration >>> 24 & 255,
                        duration >>> 16 & 255,
                        duration >>> 8 & 255,
                        duration & 255,
                        // sample_duration
                        size >>> 24 & 255,
                        size >>> 16 & 255,
                        size >>> 8 & 255,
                        size & 255,
                        // sample_size
                        flags.isLeading << 2 | flags.dependsOn,
                        flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
                        flags.degradPrio & 240 << 8,
                        flags.degradPrio & 15,
                        // sample_flags
                        cts >>> 24 & 255,
                        cts >>> 16 & 255,
                        cts >>> 8 & 255,
                        cts & 255
                        // sample_composition_time_offset
                      ], 12 + 16 * i);
                    }
                    return MP42.box(MP42.types.trun, array);
                  };
                  MP42.initSegment = function initSegment(tracks) {
                    if (!MP42.types) {
                      MP42.init();
                    }
                    var movie = MP42.moov(tracks);
                    var result = new Uint8Array(MP42.FTYP.byteLength + movie.byteLength);
                    result.set(MP42.FTYP);
                    result.set(movie, MP42.FTYP.byteLength);
                    return result;
                  };
                  return MP42;
                }();
                MP4.types = void 0;
                MP4.HDLR_TYPES = void 0;
                MP4.STTS = void 0;
                MP4.STSC = void 0;
                MP4.STCO = void 0;
                MP4.STSZ = void 0;
                MP4.VMHD = void 0;
                MP4.SMHD = void 0;
                MP4.STSD = void 0;
                MP4.FTYP = void 0;
                MP4.DINF = void 0;
                const __WEBPACK_DEFAULT_EXPORT__ = MP4;
              }
            ),
            /***/
            "./src/remux/mp4-remuxer.ts": (
              /*!**********************************!*\
                !*** ./src/remux/mp4-remuxer.ts ***!
                \**********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    MP4Remuxer
                  ),
                  /* harmony export */
                  "flushTextTrackMetadataCueSamples": () => (
                    /* binding */
                    flushTextTrackMetadataCueSamples
                  ),
                  /* harmony export */
                  "flushTextTrackUserdataCueSamples": () => (
                    /* binding */
                    flushTextTrackUserdataCueSamples
                  ),
                  /* harmony export */
                  "normalizePts": () => (
                    /* binding */
                    normalizePts
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _aac_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./aac-helper */
                  "./src/remux/aac-helper.ts"
                );
                var _mp4_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./mp4-generator */
                  "./src/remux/mp4-generator.ts"
                );
                var _events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../events */
                  "./src/events.ts"
                );
                var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../errors */
                  "./src/errors.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ../types/loader */
                  "./src/types/loader.ts"
                );
                var _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ../utils/timescale-conversion */
                  "./src/utils/timescale-conversion.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                var MAX_SILENT_FRAME_DURATION = 10 * 1e3;
                var AAC_SAMPLES_PER_FRAME = 1024;
                var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
                var chromeVersion = null;
                var safariWebkitVersion = null;
                var MP4Remuxer = function() {
                  function MP4Remuxer2(observer, config, typeSupported, vendor) {
                    if (vendor === void 0) {
                      vendor = "";
                    }
                    this.observer = void 0;
                    this.config = void 0;
                    this.typeSupported = void 0;
                    this.ISGenerated = false;
                    this._initPTS = void 0;
                    this._initDTS = void 0;
                    this.nextAvcDts = null;
                    this.nextAudioPts = null;
                    this.videoSampleDuration = null;
                    this.isAudioContiguous = false;
                    this.isVideoContiguous = false;
                    this.observer = observer;
                    this.config = config;
                    this.typeSupported = typeSupported;
                    this.ISGenerated = false;
                    if (chromeVersion === null) {
                      var userAgent = navigator.userAgent || "";
                      var result = userAgent.match(/Chrome\/(\d+)/i);
                      chromeVersion = result ? parseInt(result[1]) : 0;
                    }
                    if (safariWebkitVersion === null) {
                      var _result = navigator.userAgent.match(/Safari\/(\d+)/i);
                      safariWebkitVersion = _result ? parseInt(_result[1]) : 0;
                    }
                  }
                  var _proto = MP4Remuxer2.prototype;
                  _proto.destroy = function destroy() {
                  };
                  _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log("[mp4-remuxer]: initPTS & initDTS reset");
                    this._initPTS = this._initDTS = defaultTimeStamp;
                  };
                  _proto.resetNextTimestamp = function resetNextTimestamp() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log("[mp4-remuxer]: reset next timestamp");
                    this.isVideoContiguous = false;
                    this.isAudioContiguous = false;
                  };
                  _proto.resetInitSegment = function resetInitSegment() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log("[mp4-remuxer]: ISGenerated flag reset");
                    this.ISGenerated = false;
                  };
                  _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {
                    var rolloverDetected = false;
                    var startPTS = videoSamples.reduce(function(minPTS, sample) {
                      var delta = sample.pts - minPTS;
                      if (delta < -4294967296) {
                        rolloverDetected = true;
                        return normalizePts(minPTS, sample.pts);
                      } else if (delta > 0) {
                        return minPTS;
                      } else {
                        return sample.pts;
                      }
                    }, videoSamples[0].pts);
                    if (rolloverDetected) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.debug("PTS rollover detected");
                    }
                    return startPTS;
                  };
                  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
                    var video;
                    var audio;
                    var initSegment;
                    var text;
                    var id3;
                    var independent;
                    var audioTimeOffset = timeOffset;
                    var videoTimeOffset = timeOffset;
                    var hasAudio = audioTrack.pid > -1;
                    var hasVideo = videoTrack.pid > -1;
                    var length = videoTrack.samples.length;
                    var enoughAudioSamples = audioTrack.samples.length > 0;
                    var enoughVideoSamples = flush && length > 0 || length > 1;
                    var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
                    if (canRemuxAvc) {
                      if (!this.ISGenerated) {
                        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
                      }
                      var isVideoContiguous = this.isVideoContiguous;
                      var firstKeyFrameIndex = -1;
                      var firstKeyFramePTS;
                      if (enoughVideoSamples) {
                        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
                        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
                          independent = true;
                          if (firstKeyFrameIndex > 0) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("[mp4-remuxer]: Dropped " + firstKeyFrameIndex + " out of " + length + " video samples due to a missing keyframe");
                            var startPTS = this.getVideoStartPts(videoTrack.samples);
                            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
                            videoTrack.dropped += firstKeyFrameIndex;
                            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
                            firstKeyFramePTS = videoTimeOffset;
                          } else if (firstKeyFrameIndex === -1) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("[mp4-remuxer]: No keyframe found out of " + length + " video samples");
                            independent = false;
                          }
                        }
                      }
                      if (this.ISGenerated) {
                        if (enoughAudioSamples && enoughVideoSamples) {
                          var _startPTS = this.getVideoStartPts(videoTrack.samples);
                          var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;
                          var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
                          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
                          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
                        }
                        if (enoughAudioSamples) {
                          if (!audioTrack.samplerate) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
                            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
                          }
                          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === _types_loader__WEBPACK_IMPORTED_MODULE_6__.PlaylistLevelType.AUDIO ? videoTimeOffset : void 0);
                          if (enoughVideoSamples) {
                            var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
                            if (!videoTrack.inputTimeScale) {
                              _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected");
                              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
                            }
                            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
                          }
                        } else if (enoughVideoSamples) {
                          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
                        }
                        if (video) {
                          video.firstKeyFrame = firstKeyFrameIndex;
                          video.independent = firstKeyFrameIndex !== -1;
                          video.firstKeyFramePTS = firstKeyFramePTS;
                        }
                      }
                    }
                    if (this.ISGenerated) {
                      if (id3Track.samples.length) {
                        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
                      }
                      if (textTrack.samples.length) {
                        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
                      }
                    }
                    return {
                      audio,
                      video,
                      initSegment,
                      independent,
                      text,
                      id3
                    };
                  };
                  _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {
                    var audioSamples = audioTrack.samples;
                    var videoSamples = videoTrack.samples;
                    var typeSupported = this.typeSupported;
                    var tracks = {};
                    var computePTSDTS = !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(this._initPTS);
                    var container = "audio/mp4";
                    var initPTS;
                    var initDTS;
                    var timescale;
                    if (computePTSDTS) {
                      initPTS = initDTS = Infinity;
                    }
                    if (audioTrack.config && audioSamples.length) {
                      audioTrack.timescale = audioTrack.samplerate;
                      switch (audioTrack.segmentCodec) {
                        case "mp3":
                          if (typeSupported.mpeg) {
                            container = "audio/mpeg";
                            audioTrack.codec = "";
                          } else if (typeSupported.mp3) {
                            audioTrack.codec = "mp3";
                          }
                          break;
                      }
                      tracks.audio = {
                        id: "audio",
                        container,
                        codec: audioTrack.codec,
                        initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].initSegment([audioTrack]),
                        metadata: {
                          channelCount: audioTrack.channelCount
                        }
                      };
                      if (computePTSDTS) {
                        timescale = audioTrack.inputTimeScale;
                        initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
                      }
                    }
                    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
                      videoTrack.timescale = videoTrack.inputTimeScale;
                      tracks.video = {
                        id: "main",
                        container: "video/mp4",
                        codec: videoTrack.codec,
                        initSegment: _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].initSegment([videoTrack]),
                        metadata: {
                          width: videoTrack.width,
                          height: videoTrack.height
                        }
                      };
                      if (computePTSDTS) {
                        timescale = videoTrack.inputTimeScale;
                        var startPTS = this.getVideoStartPts(videoSamples);
                        var startOffset = Math.round(timescale * timeOffset);
                        initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
                        initPTS = Math.min(initPTS, startPTS - startOffset);
                      }
                    }
                    if (Object.keys(tracks).length) {
                      this.ISGenerated = true;
                      if (computePTSDTS) {
                        this._initPTS = initPTS;
                        this._initDTS = initDTS;
                      }
                      return {
                        tracks,
                        initPTS,
                        timescale
                      };
                    }
                  };
                  _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
                    var timeScale = track.inputTimeScale;
                    var inputSamples = track.samples;
                    var outputSamples = [];
                    var nbSamples = inputSamples.length;
                    var initPTS = this._initPTS;
                    var nextAvcDts = this.nextAvcDts;
                    var offset = 8;
                    var mp4SampleDuration = this.videoSampleDuration;
                    var firstDTS;
                    var lastDTS;
                    var minPTS = Number.POSITIVE_INFINITY;
                    var maxPTS = Number.NEGATIVE_INFINITY;
                    var sortSamples = false;
                    if (!contiguous || nextAvcDts === null) {
                      var pts = timeOffset * timeScale;
                      var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
                      nextAvcDts = pts - cts;
                    }
                    for (var i = 0; i < nbSamples; i++) {
                      var sample = inputSamples[i];
                      sample.pts = normalizePts(sample.pts - initPTS, nextAvcDts);
                      sample.dts = normalizePts(sample.dts - initPTS, nextAvcDts);
                      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
                        sortSamples = true;
                      }
                    }
                    if (sortSamples) {
                      inputSamples.sort(function(a, b) {
                        var deltadts = a.dts - b.dts;
                        var deltapts = a.pts - b.pts;
                        return deltadts || deltapts;
                      });
                    }
                    firstDTS = inputSamples[0].dts;
                    lastDTS = inputSamples[inputSamples.length - 1].dts;
                    var inputDuration = lastDTS - firstDTS;
                    var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
                    if (contiguous) {
                      var delta = firstDTS - nextAvcDts;
                      var foundHole = delta > averageSampleDuration;
                      var foundOverlap = delta < -1;
                      if (foundHole || foundOverlap) {
                        if (foundHole) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("AVC: " + (0, _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(delta, true) + " ms (" + delta + "dts) hole between fragments detected, filling it");
                        } else {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("AVC: " + (0, _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(-delta, true) + " ms (" + delta + "dts) overlapping between fragments detected");
                        }
                        if (!foundOverlap || nextAvcDts > inputSamples[0].pts) {
                          firstDTS = nextAvcDts;
                          var firstPTS = inputSamples[0].pts - delta;
                          inputSamples[0].dts = firstDTS;
                          inputSamples[0].pts = firstPTS;
                          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log("Video: First PTS/DTS adjusted: " + (0, _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(firstPTS, true) + "/" + (0, _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(firstDTS, true) + ", delta: " + (0, _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__.toMsFromMpegTsClock)(delta, true) + " ms");
                        }
                      }
                    }
                    firstDTS = Math.max(0, firstDTS);
                    var nbNalu = 0;
                    var naluLen = 0;
                    for (var _i = 0; _i < nbSamples; _i++) {
                      var _sample = inputSamples[_i];
                      var units = _sample.units;
                      var nbUnits = units.length;
                      var sampleLen = 0;
                      for (var j = 0; j < nbUnits; j++) {
                        sampleLen += units[j].data.length;
                      }
                      naluLen += sampleLen;
                      nbNalu += nbUnits;
                      _sample.length = sampleLen;
                      _sample.dts = Math.max(_sample.dts, firstDTS);
                      minPTS = Math.min(_sample.pts, minPTS);
                      maxPTS = Math.max(_sample.pts, maxPTS);
                    }
                    lastDTS = inputSamples[nbSamples - 1].dts;
                    var mdatSize = naluLen + 4 * nbNalu + 8;
                    var mdat;
                    try {
                      mdat = new Uint8Array(mdatSize);
                    } catch (err) {
                      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, {
                        type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MUX_ERROR,
                        details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.REMUX_ALLOC_ERROR,
                        fatal: false,
                        bytes: mdatSize,
                        reason: "fail allocating video mdat " + mdatSize
                      });
                      return;
                    }
                    var view = new DataView(mdat.buffer);
                    view.setUint32(0, mdatSize);
                    mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].types.mdat, 4);
                    var stretchedLastFrame = false;
                    var minDtsDelta = Number.POSITIVE_INFINITY;
                    var minPtsDelta = Number.POSITIVE_INFINITY;
                    var maxDtsDelta = Number.NEGATIVE_INFINITY;
                    var maxPtsDelta = Number.NEGATIVE_INFINITY;
                    for (var _i2 = 0; _i2 < nbSamples; _i2++) {
                      var avcSample = inputSamples[_i2];
                      var avcSampleUnits = avcSample.units;
                      var mp4SampleLength = 0;
                      for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
                        var unit = avcSampleUnits[_j];
                        var unitData = unit.data;
                        var unitDataLen = unit.data.byteLength;
                        view.setUint32(offset, unitDataLen);
                        offset += 4;
                        mdat.set(unitData, offset);
                        offset += unitDataLen;
                        mp4SampleLength += 4 + unitDataLen;
                      }
                      var ptsDelta = void 0;
                      if (_i2 < nbSamples - 1) {
                        mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
                        ptsDelta = inputSamples[_i2 + 1].pts - avcSample.pts;
                      } else {
                        var config = this.config;
                        var lastFrameDuration = _i2 > 0 ? avcSample.dts - inputSamples[_i2 - 1].dts : averageSampleDuration;
                        ptsDelta = _i2 > 0 ? avcSample.pts - inputSamples[_i2 - 1].pts : averageSampleDuration;
                        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
                          var gapTolerance = Math.floor(config.maxBufferHole * timeScale);
                          var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
                          if (deltaToFrameEnd > gapTolerance) {
                            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                            if (mp4SampleDuration < 0) {
                              mp4SampleDuration = lastFrameDuration;
                            } else {
                              stretchedLastFrame = true;
                            }
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log("[mp4-remuxer]: It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame.");
                          } else {
                            mp4SampleDuration = lastFrameDuration;
                          }
                        } else {
                          mp4SampleDuration = lastFrameDuration;
                        }
                      }
                      var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
                      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
                      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
                      minPtsDelta = Math.min(minPtsDelta, ptsDelta);
                      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
                      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
                    }
                    if (outputSamples.length) {
                      if (chromeVersion) {
                        if (chromeVersion < 70) {
                          var flags = outputSamples[0].flags;
                          flags.dependsOn = 2;
                          flags.isNonSync = 0;
                        }
                      } else if (safariWebkitVersion) {
                        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
                          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                          var dts = firstDTS;
                          for (var _i3 = 0, len = outputSamples.length; _i3 < len; _i3++) {
                            var nextDts = dts + outputSamples[_i3].duration;
                            var _pts = dts + outputSamples[_i3].cts;
                            if (_i3 < len - 1) {
                              var nextPts = nextDts + outputSamples[_i3 + 1].cts;
                              outputSamples[_i3].duration = nextPts - _pts;
                            } else {
                              outputSamples[_i3].duration = _i3 ? outputSamples[_i3 - 1].duration : averageSampleDuration;
                            }
                            outputSamples[_i3].cts = 0;
                            dts = nextDts;
                          }
                        }
                      }
                    }
                    console.assert(mp4SampleDuration !== null, "mp4SampleDuration must be computed");
                    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
                    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
                    this.videoSampleDuration = mp4SampleDuration;
                    this.isVideoContiguous = true;
                    var moof = _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].moof(track.sequenceNumber++, firstDTS, _extends({}, track, {
                      samples: outputSamples
                    }));
                    var type = "video";
                    var data = {
                      data1: moof,
                      data2: mdat,
                      startPTS: minPTS / timeScale,
                      endPTS: (maxPTS + mp4SampleDuration) / timeScale,
                      startDTS: firstDTS / timeScale,
                      endDTS: nextAvcDts / timeScale,
                      type,
                      hasAudio: false,
                      hasVideo: true,
                      nb: outputSamples.length,
                      dropped: track.dropped
                    };
                    track.samples = [];
                    track.dropped = 0;
                    console.assert(mdat.length, "MDAT length must not be zero");
                    return data;
                  };
                  _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
                    var inputTimeScale = track.inputTimeScale;
                    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
                    var scaleFactor = inputTimeScale / mp4timeScale;
                    var mp4SampleDuration = track.segmentCodec === "aac" ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;
                    var inputSampleDuration = mp4SampleDuration * scaleFactor;
                    var initPTS = this._initPTS;
                    var rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
                    var outputSamples = [];
                    var alignedWithVideo = videoTimeOffset !== void 0;
                    var inputSamples = track.samples;
                    var offset = rawMPEG ? 0 : 8;
                    var nextAudioPts = this.nextAudioPts || -1;
                    var timeOffsetMpegTS = timeOffset * inputTimeScale;
                    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9e3 || Math.abs(normalizePts(inputSamples[0].pts - initPTS, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);
                    inputSamples.forEach(function(sample2) {
                      sample2.pts = normalizePts(sample2.pts - initPTS, timeOffsetMpegTS);
                    });
                    if (!contiguous || nextAudioPts < 0) {
                      inputSamples = inputSamples.filter(function(sample2) {
                        return sample2.pts >= 0;
                      });
                      if (!inputSamples.length) {
                        return;
                      }
                      if (videoTimeOffset === 0) {
                        nextAudioPts = 0;
                      } else if (accurateTimeOffset && !alignedWithVideo) {
                        nextAudioPts = Math.max(0, timeOffsetMpegTS);
                      } else {
                        nextAudioPts = inputSamples[0].pts;
                      }
                    }
                    if (track.segmentCodec === "aac") {
                      var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
                      for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {
                        var sample = inputSamples[i];
                        var pts = sample.pts;
                        var delta = pts - nextPts;
                        var duration = Math.abs(1e3 * delta / inputTimeScale);
                        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
                          if (i === 0) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Audio frame @ " + (pts / inputTimeScale).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * delta / inputTimeScale) + " ms.");
                            this.nextAudioPts = nextAudioPts = nextPts = pts;
                          }
                        } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
                          var missing = Math.round(delta / inputSampleDuration);
                          nextPts = pts - missing * inputSampleDuration;
                          if (nextPts < 0) {
                            missing--;
                            nextPts += inputSampleDuration;
                          }
                          if (i === 0) {
                            this.nextAudioPts = nextAudioPts = nextPts;
                          }
                          _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("[mp4-remuxer]: Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(1e3 * delta / inputTimeScale) + " ms gap.");
                          for (var j = 0; j < missing; j++) {
                            var newStamp = Math.max(nextPts, 0);
                            var fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                            if (!fillFrame) {
                              _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
                              fillFrame = sample.unit.subarray();
                            }
                            inputSamples.splice(i, 0, {
                              unit: fillFrame,
                              pts: newStamp
                            });
                            nextPts += inputSampleDuration;
                            i++;
                          }
                        }
                        sample.pts = nextPts;
                        nextPts += inputSampleDuration;
                      }
                    }
                    var firstPTS = null;
                    var lastPTS = null;
                    var mdat;
                    var mdatSize = 0;
                    var sampleLength = inputSamples.length;
                    while (sampleLength--) {
                      mdatSize += inputSamples[sampleLength].unit.byteLength;
                    }
                    for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
                      var audioSample = inputSamples[_j2];
                      var unit = audioSample.unit;
                      var _pts2 = audioSample.pts;
                      if (lastPTS !== null) {
                        var prevSample = outputSamples[_j2 - 1];
                        prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);
                      } else {
                        if (contiguous && track.segmentCodec === "aac") {
                          _pts2 = nextAudioPts;
                        }
                        firstPTS = _pts2;
                        if (mdatSize > 0) {
                          mdatSize += offset;
                          try {
                            mdat = new Uint8Array(mdatSize);
                          } catch (err) {
                            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, _events__WEBPACK_IMPORTED_MODULE_3__.Events.ERROR, {
                              type: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorTypes.MUX_ERROR,
                              details: _errors__WEBPACK_IMPORTED_MODULE_4__.ErrorDetails.REMUX_ALLOC_ERROR,
                              fatal: false,
                              bytes: mdatSize,
                              reason: "fail allocating audio mdat " + mdatSize
                            });
                            return;
                          }
                          if (!rawMPEG) {
                            var view = new DataView(mdat.buffer);
                            view.setUint32(0, mdatSize);
                            mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].types.mdat, 4);
                          }
                        } else {
                          return;
                        }
                      }
                      mdat.set(unit, offset);
                      var unitLen = unit.byteLength;
                      offset += unitLen;
                      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
                      lastPTS = _pts2;
                    }
                    var nbSamples = outputSamples.length;
                    if (!nbSamples) {
                      return;
                    }
                    var lastSample = outputSamples[outputSamples.length - 1];
                    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
                    var moof = rawMPEG ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {
                      samples: outputSamples
                    }));
                    track.samples = [];
                    var start = firstPTS / inputTimeScale;
                    var end = nextAudioPts / inputTimeScale;
                    var type = "audio";
                    var audioData = {
                      data1: moof,
                      data2: mdat,
                      startPTS: start,
                      endPTS: end,
                      startDTS: start,
                      endDTS: end,
                      type,
                      hasAudio: true,
                      hasVideo: false,
                      nb: nbSamples
                    };
                    this.isAudioContiguous = true;
                    console.assert(mdat.length, "MDAT length must not be zero");
                    return audioData;
                  };
                  _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
                    var inputTimeScale = track.inputTimeScale;
                    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
                    var scaleFactor = inputTimeScale / mp4timeScale;
                    var nextAudioPts = this.nextAudioPts;
                    var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS;
                    var endDTS = videoData.endDTS * inputTimeScale + this._initDTS;
                    var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
                    var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
                    var silentFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.warn("[mp4-remuxer]: remux empty Audio");
                    if (!silentFrame) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_5__.logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
                      return;
                    }
                    var samples = [];
                    for (var i = 0; i < nbSamples; i++) {
                      var stamp = startDTS + i * frameDuration;
                      samples.push({
                        unit: silentFrame,
                        pts: stamp,
                        dts: stamp
                      });
                    }
                    track.samples = samples;
                    return this.remuxAudio(track, timeOffset, contiguous, false);
                  };
                  return MP4Remuxer2;
                }();
                function normalizePts(value, reference) {
                  var offset;
                  if (reference === null) {
                    return value;
                  }
                  if (reference < value) {
                    offset = -8589934592;
                  } else {
                    offset = 8589934592;
                  }
                  while (Math.abs(value - reference) > 4294967296) {
                    value += offset;
                  }
                  return value;
                }
                function findKeyframeIndex(samples) {
                  for (var i = 0; i < samples.length; i++) {
                    if (samples[i].key) {
                      return i;
                    }
                  }
                  return -1;
                }
                function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
                  var length = track.samples.length;
                  if (!length) {
                    return;
                  }
                  var inputTimeScale = track.inputTimeScale;
                  for (var index = 0; index < length; index++) {
                    var sample = track.samples[index];
                    sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
                    sample.dts = normalizePts(sample.dts - initDTS, timeOffset * inputTimeScale) / inputTimeScale;
                  }
                  var samples = track.samples;
                  track.samples = [];
                  return {
                    samples
                  };
                }
                function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
                  var length = track.samples.length;
                  if (!length) {
                    return;
                  }
                  var inputTimeScale = track.inputTimeScale;
                  for (var index = 0; index < length; index++) {
                    var sample = track.samples[index];
                    sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
                  }
                  track.samples.sort(function(a, b) {
                    return a.pts - b.pts;
                  });
                  var samples = track.samples;
                  track.samples = [];
                  return {
                    samples
                  };
                }
                var Mp4Sample = function Mp4Sample2(isKeyframe, duration, size, cts) {
                  this.size = void 0;
                  this.duration = void 0;
                  this.cts = void 0;
                  this.flags = void 0;
                  this.duration = duration;
                  this.size = size;
                  this.cts = cts;
                  this.flags = new Mp4SampleFlags(isKeyframe);
                };
                var Mp4SampleFlags = function Mp4SampleFlags2(isKeyframe) {
                  this.isLeading = 0;
                  this.isDependedOn = 0;
                  this.hasRedundancy = 0;
                  this.degradPrio = 0;
                  this.dependsOn = 1;
                  this.isNonSync = 1;
                  this.dependsOn = isKeyframe ? 2 : 1;
                  this.isNonSync = isKeyframe ? 0 : 1;
                };
              }
            ),
            /***/
            "./src/remux/passthrough-remuxer.ts": (
              /*!******************************************!*\
                !*** ./src/remux/passthrough-remuxer.ts ***!
                \******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./mp4-remuxer */
                  "./src/remux/mp4-remuxer.ts"
                );
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../utils/mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../loader/fragment */
                  "./src/loader/fragment.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var PassThroughRemuxer = function() {
                  function PassThroughRemuxer2() {
                    this.emitInitSegment = false;
                    this.audioCodec = void 0;
                    this.videoCodec = void 0;
                    this.initData = void 0;
                    this.initPTS = void 0;
                    this.initTracks = void 0;
                    this.lastEndTime = null;
                  }
                  var _proto = PassThroughRemuxer2.prototype;
                  _proto.destroy = function destroy() {
                  };
                  _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {
                    this.initPTS = defaultInitPTS;
                    this.lastEndTime = null;
                  };
                  _proto.resetNextTimestamp = function resetNextTimestamp() {
                    this.lastEndTime = null;
                  };
                  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
                    this.audioCodec = audioCodec;
                    this.videoCodec = videoCodec;
                    this.generateInitSegment((0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.patchEncyptionData)(initSegment, decryptdata));
                    this.emitInitSegment = true;
                  };
                  _proto.generateInitSegment = function generateInitSegment(initSegment) {
                    var audioCodec = this.audioCodec, videoCodec = this.videoCodec;
                    if (!initSegment || !initSegment.byteLength) {
                      this.initTracks = void 0;
                      this.initData = void 0;
                      return;
                    }
                    var initData = this.initData = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.parseInitSegment)(initSegment);
                    if (!audioCodec) {
                      audioCodec = getParsedTrackCodec(initData.audio, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__.ElementaryStreamTypes.AUDIO);
                    }
                    if (!videoCodec) {
                      videoCodec = getParsedTrackCodec(initData.video, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__.ElementaryStreamTypes.VIDEO);
                    }
                    var tracks = {};
                    if (initData.audio && initData.video) {
                      tracks.audiovideo = {
                        container: "video/mp4",
                        codec: audioCodec + "," + videoCodec,
                        initSegment,
                        id: "main"
                      };
                    } else if (initData.audio) {
                      tracks.audio = {
                        container: "audio/mp4",
                        codec: audioCodec,
                        initSegment,
                        id: "audio"
                      };
                    } else if (initData.video) {
                      tracks.video = {
                        container: "video/mp4",
                        codec: videoCodec,
                        initSegment,
                        id: "main"
                      };
                    } else {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
                    }
                    this.initTracks = tracks;
                  };
                  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset) {
                    var _this$initPTS;
                    var initPTS = this.initPTS, lastEndTime = this.lastEndTime;
                    var result = {
                      audio: void 0,
                      video: void 0,
                      text: textTrack,
                      id3: id3Track,
                      initSegment: void 0
                    };
                    if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(lastEndTime)) {
                      lastEndTime = this.lastEndTime = timeOffset || 0;
                    }
                    var data = videoTrack.samples;
                    if (!data || !data.length) {
                      return result;
                    }
                    var initSegment = {
                      initPTS: void 0,
                      timescale: 1
                    };
                    var initData = this.initData;
                    if (!initData || !initData.length) {
                      this.generateInitSegment(data);
                      initData = this.initData;
                    }
                    if (!initData || !initData.length) {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
                      return result;
                    }
                    if (this.emitInitSegment) {
                      initSegment.tracks = this.initTracks;
                      this.emitInitSegment = false;
                    }
                    var startDTS = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.getStartDTS)(initData, data);
                    if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(initPTS)) {
                      this.initPTS = initSegment.initPTS = initPTS = startDTS - timeOffset;
                    }
                    var duration = (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.getDuration)(data, initData);
                    var startTime = audioTrack ? startDTS - initPTS : lastEndTime;
                    var endTime = startTime + duration;
                    (0, _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__.offsetStartDTS)(initData, data, initPTS);
                    if (duration > 0) {
                      this.lastEndTime = endTime;
                    } else {
                      _utils_logger__WEBPACK_IMPORTED_MODULE_4__.logger.warn("Duration parsed from mp4 should be greater than zero");
                      this.resetNextTimestamp();
                    }
                    var hasAudio = !!initData.audio;
                    var hasVideo = !!initData.video;
                    var type = "";
                    if (hasAudio) {
                      type += "audio";
                    }
                    if (hasVideo) {
                      type += "video";
                    }
                    var track = {
                      data1: data,
                      startPTS: startTime,
                      startDTS: startTime,
                      endPTS: endTime,
                      endDTS: endTime,
                      type,
                      hasAudio,
                      hasVideo,
                      nb: 1,
                      dropped: 0
                    };
                    result.audio = track.type === "audio" ? track : void 0;
                    result.video = track.type !== "audio" ? track : void 0;
                    result.initSegment = initSegment;
                    var initPtsNum = (_this$initPTS = this.initPTS) != null ? _this$initPTS : 0;
                    result.id3 = (0, _mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__.flushTextTrackMetadataCueSamples)(id3Track, timeOffset, initPtsNum, initPtsNum);
                    if (textTrack.samples.length) {
                      result.text = (0, _mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__.flushTextTrackUserdataCueSamples)(textTrack, timeOffset, initPtsNum);
                    }
                    return result;
                  };
                  return PassThroughRemuxer2;
                }();
                function getParsedTrackCodec(track, type) {
                  var parsedCodec = track === null || track === void 0 ? void 0 : track.codec;
                  if (parsedCodec && parsedCodec.length > 4) {
                    return parsedCodec;
                  }
                  if (parsedCodec === "hvc1" || parsedCodec === "hev1") {
                    return "hvc1.1.c.L120.90";
                  }
                  if (parsedCodec === "av01") {
                    return "av01.0.04M.08";
                  }
                  if (parsedCodec === "avc1" || type === _loader_fragment__WEBPACK_IMPORTED_MODULE_3__.ElementaryStreamTypes.VIDEO) {
                    return "avc1.42e01e";
                  }
                  return "mp4a.40.5";
                }
                const __WEBPACK_DEFAULT_EXPORT__ = PassThroughRemuxer;
              }
            ),
            /***/
            "./src/task-loop.ts": (
              /*!**************************!*\
                !*** ./src/task-loop.ts ***!
                \**************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    TaskLoop
                  )
                  /* harmony export */
                });
                var TaskLoop = function() {
                  function TaskLoop2() {
                    this._boundTick = void 0;
                    this._tickTimer = null;
                    this._tickInterval = null;
                    this._tickCallCount = 0;
                    this._boundTick = this.tick.bind(this);
                  }
                  var _proto = TaskLoop2.prototype;
                  _proto.destroy = function destroy() {
                    this.onHandlerDestroying();
                    this.onHandlerDestroyed();
                  };
                  _proto.onHandlerDestroying = function onHandlerDestroying() {
                    this.clearNextTick();
                    this.clearInterval();
                  };
                  _proto.onHandlerDestroyed = function onHandlerDestroyed() {
                  };
                  _proto.hasInterval = function hasInterval() {
                    return !!this._tickInterval;
                  };
                  _proto.hasNextTick = function hasNextTick() {
                    return !!this._tickTimer;
                  };
                  _proto.setInterval = function setInterval(millis) {
                    if (!this._tickInterval) {
                      this._tickInterval = self.setInterval(this._boundTick, millis);
                      return true;
                    }
                    return false;
                  };
                  _proto.clearInterval = function clearInterval2() {
                    if (this._tickInterval) {
                      self.clearInterval(this._tickInterval);
                      this._tickInterval = null;
                      return true;
                    }
                    return false;
                  };
                  _proto.clearNextTick = function clearNextTick() {
                    if (this._tickTimer) {
                      self.clearTimeout(this._tickTimer);
                      this._tickTimer = null;
                      return true;
                    }
                    return false;
                  };
                  _proto.tick = function tick() {
                    this._tickCallCount++;
                    if (this._tickCallCount === 1) {
                      this.doTick();
                      if (this._tickCallCount > 1) {
                        this.tickImmediate();
                      }
                      this._tickCallCount = 0;
                    }
                  };
                  _proto.tickImmediate = function tickImmediate() {
                    this.clearNextTick();
                    this._tickTimer = self.setTimeout(this._boundTick, 0);
                  };
                  _proto.doTick = function doTick() {
                  };
                  return TaskLoop2;
                }();
              }
            ),
            /***/
            "./src/types/cmcd.ts": (
              /*!***************************!*\
                !*** ./src/types/cmcd.ts ***!
                \***************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "CMCDObjectType": () => (
                    /* binding */
                    CMCDObjectType
                  ),
                  /* harmony export */
                  "CMCDStreamType": () => (
                    /* binding */
                    CMCDStreamType
                  ),
                  /* harmony export */
                  "CMCDStreamingFormat": () => (
                    /* binding */
                    CMCDStreamingFormat
                  ),
                  /* harmony export */
                  "CMCDVersion": () => (
                    /* binding */
                    CMCDVersion
                  )
                  /* harmony export */
                });
                var CMCDVersion = 1;
                var CMCDObjectType;
                (function(CMCDObjectType2) {
                  CMCDObjectType2["MANIFEST"] = "m";
                  CMCDObjectType2["AUDIO"] = "a";
                  CMCDObjectType2["VIDEO"] = "v";
                  CMCDObjectType2["MUXED"] = "av";
                  CMCDObjectType2["INIT"] = "i";
                  CMCDObjectType2["CAPTION"] = "c";
                  CMCDObjectType2["TIMED_TEXT"] = "tt";
                  CMCDObjectType2["KEY"] = "k";
                  CMCDObjectType2["OTHER"] = "o";
                })(CMCDObjectType || (CMCDObjectType = {}));
                var CMCDStreamingFormat;
                (function(CMCDStreamingFormat2) {
                  CMCDStreamingFormat2["DASH"] = "d";
                  CMCDStreamingFormat2["HLS"] = "h";
                  CMCDStreamingFormat2["SMOOTH"] = "s";
                  CMCDStreamingFormat2["OTHER"] = "o";
                })(CMCDStreamingFormat || (CMCDStreamingFormat = {}));
                var CMCDStreamType;
                (function(CMCDStreamType2) {
                  CMCDStreamType2["VOD"] = "v";
                  CMCDStreamType2["LIVE"] = "l";
                })(CMCDStreamType || (CMCDStreamType = {}));
              }
            ),
            /***/
            "./src/types/demuxer.ts": (
              /*!******************************!*\
                !*** ./src/types/demuxer.ts ***!
                \******************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "MetadataSchema": () => (
                    /* binding */
                    MetadataSchema
                  )
                  /* harmony export */
                });
                var MetadataSchema;
                (function(MetadataSchema2) {
                  MetadataSchema2["audioId3"] = "org.id3";
                  MetadataSchema2["dateRange"] = "com.apple.quicktime.HLS";
                  MetadataSchema2["emsg"] = "https://aomedia.org/emsg/ID3";
                })(MetadataSchema || (MetadataSchema = {}));
              }
            ),
            /***/
            "./src/types/level.ts": (
              /*!****************************!*\
                !*** ./src/types/level.ts ***!
                \****************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "HdcpLevels": () => (
                    /* binding */
                    HdcpLevels
                  ),
                  /* harmony export */
                  "HlsSkip": () => (
                    /* binding */
                    HlsSkip
                  ),
                  /* harmony export */
                  "HlsUrlParameters": () => (
                    /* binding */
                    HlsUrlParameters
                  ),
                  /* harmony export */
                  "Level": () => (
                    /* binding */
                    Level
                  ),
                  /* harmony export */
                  "getSkipValue": () => (
                    /* binding */
                    getSkipValue
                  )
                  /* harmony export */
                });
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", "TYPE-2", null];
                var HlsSkip;
                (function(HlsSkip2) {
                  HlsSkip2["No"] = "";
                  HlsSkip2["Yes"] = "YES";
                  HlsSkip2["v2"] = "v2";
                })(HlsSkip || (HlsSkip = {}));
                function getSkipValue(details, msn) {
                  var canSkipUntil = details.canSkipUntil, canSkipDateRanges = details.canSkipDateRanges, endSN = details.endSN;
                  var snChangeGoal = msn !== void 0 ? msn - endSN : 0;
                  if (canSkipUntil && snChangeGoal < canSkipUntil) {
                    if (canSkipDateRanges) {
                      return HlsSkip.v2;
                    }
                    return HlsSkip.Yes;
                  }
                  return HlsSkip.No;
                }
                var HlsUrlParameters = function() {
                  function HlsUrlParameters2(msn, part, skip) {
                    this.msn = void 0;
                    this.part = void 0;
                    this.skip = void 0;
                    this.msn = msn;
                    this.part = part;
                    this.skip = skip;
                  }
                  var _proto = HlsUrlParameters2.prototype;
                  _proto.addDirectives = function addDirectives(uri) {
                    var url = new self.URL(uri);
                    if (this.msn !== void 0) {
                      url.searchParams.set("_HLS_msn", this.msn.toString());
                    }
                    if (this.part !== void 0) {
                      url.searchParams.set("_HLS_part", this.part.toString());
                    }
                    if (this.skip) {
                      url.searchParams.set("_HLS_skip", this.skip);
                    }
                    return url.href;
                  };
                  return HlsUrlParameters2;
                }();
                var Level = function() {
                  function Level2(data) {
                    this.attrs = void 0;
                    this.audioCodec = void 0;
                    this.bitrate = void 0;
                    this.codecSet = void 0;
                    this.height = void 0;
                    this.id = void 0;
                    this.name = void 0;
                    this.videoCodec = void 0;
                    this.width = void 0;
                    this.unknownCodecs = void 0;
                    this.audioGroupIds = void 0;
                    this.details = void 0;
                    this.fragmentError = 0;
                    this.loadError = 0;
                    this.loaded = void 0;
                    this.realBitrate = 0;
                    this.textGroupIds = void 0;
                    this.url = void 0;
                    this._urlId = 0;
                    this.url = [data.url];
                    this.attrs = data.attrs;
                    this.bitrate = data.bitrate;
                    if (data.details) {
                      this.details = data.details;
                    }
                    this.id = data.id || 0;
                    this.name = data.name;
                    this.width = data.width || 0;
                    this.height = data.height || 0;
                    this.audioCodec = data.audioCodec;
                    this.videoCodec = data.videoCodec;
                    this.unknownCodecs = data.unknownCodecs;
                    this.codecSet = [data.videoCodec, data.audioCodec].filter(function(c) {
                      return c;
                    }).join(",").replace(/\.[^.,]+/g, "");
                  }
                  _createClass(Level2, [{
                    key: "maxBitrate",
                    get: function get() {
                      return Math.max(this.realBitrate, this.bitrate);
                    }
                  }, {
                    key: "uri",
                    get: function get() {
                      return this.url[this._urlId] || "";
                    }
                  }, {
                    key: "urlId",
                    get: function get() {
                      return this._urlId;
                    },
                    set: function set(value) {
                      var newValue = value % this.url.length;
                      if (this._urlId !== newValue) {
                        this.details = void 0;
                        this._urlId = newValue;
                      }
                    }
                  }]);
                  return Level2;
                }();
              }
            ),
            /***/
            "./src/types/loader.ts": (
              /*!*****************************!*\
                !*** ./src/types/loader.ts ***!
                \*****************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "PlaylistContextType": () => (
                    /* binding */
                    PlaylistContextType
                  ),
                  /* harmony export */
                  "PlaylistLevelType": () => (
                    /* binding */
                    PlaylistLevelType
                  )
                  /* harmony export */
                });
                var PlaylistContextType;
                (function(PlaylistContextType2) {
                  PlaylistContextType2["MANIFEST"] = "manifest";
                  PlaylistContextType2["LEVEL"] = "level";
                  PlaylistContextType2["AUDIO_TRACK"] = "audioTrack";
                  PlaylistContextType2["SUBTITLE_TRACK"] = "subtitleTrack";
                })(PlaylistContextType || (PlaylistContextType = {}));
                var PlaylistLevelType;
                (function(PlaylistLevelType2) {
                  PlaylistLevelType2["MAIN"] = "main";
                  PlaylistLevelType2["AUDIO"] = "audio";
                  PlaylistLevelType2["SUBTITLE"] = "subtitle";
                })(PlaylistLevelType || (PlaylistLevelType = {}));
              }
            ),
            /***/
            "./src/types/transmuxer.ts": (
              /*!*********************************!*\
                !*** ./src/types/transmuxer.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "ChunkMetadata": () => (
                    /* binding */
                    ChunkMetadata
                  )
                  /* harmony export */
                });
                var ChunkMetadata = function ChunkMetadata2(level, sn, id, size, part, partial) {
                  if (size === void 0) {
                    size = 0;
                  }
                  if (part === void 0) {
                    part = -1;
                  }
                  if (partial === void 0) {
                    partial = false;
                  }
                  this.level = void 0;
                  this.sn = void 0;
                  this.part = void 0;
                  this.id = void 0;
                  this.size = void 0;
                  this.partial = void 0;
                  this.transmuxing = getNewPerformanceTiming();
                  this.buffering = {
                    audio: getNewPerformanceTiming(),
                    video: getNewPerformanceTiming(),
                    audiovideo: getNewPerformanceTiming()
                  };
                  this.level = level;
                  this.sn = sn;
                  this.id = id;
                  this.size = size;
                  this.part = part;
                  this.partial = partial;
                };
                function getNewPerformanceTiming() {
                  return {
                    start: 0,
                    executeStart: 0,
                    executeEnd: 0,
                    end: 0
                  };
                }
              }
            ),
            /***/
            "./src/utils/attr-list.ts": (
              /*!********************************!*\
                !*** ./src/utils/attr-list.ts ***!
                \********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "AttrList": () => (
                    /* binding */
                    AttrList
                  )
                  /* harmony export */
                });
                var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
                var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
                var AttrList = function() {
                  function AttrList2(attrs) {
                    if (typeof attrs === "string") {
                      attrs = AttrList2.parseAttrList(attrs);
                    }
                    for (var attr in attrs) {
                      if (attrs.hasOwnProperty(attr)) {
                        this[attr] = attrs[attr];
                      }
                    }
                  }
                  var _proto = AttrList2.prototype;
                  _proto.decimalInteger = function decimalInteger(attrName) {
                    var intValue = parseInt(this[attrName], 10);
                    if (intValue > Number.MAX_SAFE_INTEGER) {
                      return Infinity;
                    }
                    return intValue;
                  };
                  _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
                    if (this[attrName]) {
                      var stringValue = (this[attrName] || "0x").slice(2);
                      stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
                      var value = new Uint8Array(stringValue.length / 2);
                      for (var i = 0; i < stringValue.length / 2; i++) {
                        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
                      }
                      return value;
                    } else {
                      return null;
                    }
                  };
                  _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
                    var intValue = parseInt(this[attrName], 16);
                    if (intValue > Number.MAX_SAFE_INTEGER) {
                      return Infinity;
                    }
                    return intValue;
                  };
                  _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
                    return parseFloat(this[attrName]);
                  };
                  _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {
                    var value = this[attrName];
                    return value ? parseFloat(value) : defaultValue;
                  };
                  _proto.enumeratedString = function enumeratedString(attrName) {
                    return this[attrName];
                  };
                  _proto.bool = function bool(attrName) {
                    return this[attrName] === "YES";
                  };
                  _proto.decimalResolution = function decimalResolution(attrName) {
                    var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
                    if (res === null) {
                      return void 0;
                    }
                    return {
                      width: parseInt(res[1], 10),
                      height: parseInt(res[2], 10)
                    };
                  };
                  AttrList2.parseAttrList = function parseAttrList(input) {
                    var match;
                    var attrs = {};
                    var quote = '"';
                    ATTR_LIST_REGEX.lastIndex = 0;
                    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
                      var value = match[2];
                      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
                        value = value.slice(1, -1);
                      }
                      attrs[match[1]] = value;
                    }
                    return attrs;
                  };
                  return AttrList2;
                }();
              }
            ),
            /***/
            "./src/utils/binary-search.ts": (
              /*!************************************!*\
                !*** ./src/utils/binary-search.ts ***!
                \************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var BinarySearch = {
                  /**
                   * Searches for an item in an array which matches a certain condition.
                   * This requires the condition to only match one item in the array,
                   * and for the array to be ordered.
                   *
                   * @param {Array<T>} list The array to search.
                   * @param {BinarySearchComparison<T>} comparisonFn
                   *      Called and provided a candidate item as the first argument.
                   *      Should return:
                   *          > -1 if the item should be located at a lower index than the provided item.
                   *          > 1 if the item should be located at a higher index than the provided item.
                   *          > 0 if the item is the item you're looking for.
                   *
                   * @return {T | null} The object if it is found or null otherwise.
                   */
                  search: function search(list, comparisonFn) {
                    var minIndex = 0;
                    var maxIndex = list.length - 1;
                    var currentIndex = null;
                    var currentElement = null;
                    while (minIndex <= maxIndex) {
                      currentIndex = (minIndex + maxIndex) / 2 | 0;
                      currentElement = list[currentIndex];
                      var comparisonResult = comparisonFn(currentElement);
                      if (comparisonResult > 0) {
                        minIndex = currentIndex + 1;
                      } else if (comparisonResult < 0) {
                        maxIndex = currentIndex - 1;
                      } else {
                        return currentElement;
                      }
                    }
                    return null;
                  }
                };
                const __WEBPACK_DEFAULT_EXPORT__ = BinarySearch;
              }
            ),
            /***/
            "./src/utils/buffer-helper.ts": (
              /*!************************************!*\
                !*** ./src/utils/buffer-helper.ts ***!
                \************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "BufferHelper": () => (
                    /* binding */
                    BufferHelper
                  )
                  /* harmony export */
                });
                var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./logger */
                  "./src/utils/logger.ts"
                );
                var noopBuffered = {
                  length: 0,
                  start: function start() {
                    return 0;
                  },
                  end: function end() {
                    return 0;
                  }
                };
                var BufferHelper = function() {
                  function BufferHelper2() {
                  }
                  BufferHelper2.isBuffered = function isBuffered(media, position) {
                    try {
                      if (media) {
                        var buffered = BufferHelper2.getBuffered(media);
                        for (var i = 0; i < buffered.length; i++) {
                          if (position >= buffered.start(i) && position <= buffered.end(i)) {
                            return true;
                          }
                        }
                      }
                    } catch (error) {
                    }
                    return false;
                  };
                  BufferHelper2.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
                    try {
                      if (media) {
                        var vbuffered = BufferHelper2.getBuffered(media);
                        var buffered = [];
                        var i;
                        for (i = 0; i < vbuffered.length; i++) {
                          buffered.push({
                            start: vbuffered.start(i),
                            end: vbuffered.end(i)
                          });
                        }
                        return this.bufferedInfo(buffered, pos, maxHoleDuration);
                      }
                    } catch (error) {
                    }
                    return {
                      len: 0,
                      start: pos,
                      end: pos,
                      nextStart: void 0
                    };
                  };
                  BufferHelper2.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
                    pos = Math.max(0, pos);
                    buffered.sort(function(a, b) {
                      var diff = a.start - b.start;
                      if (diff) {
                        return diff;
                      } else {
                        return b.end - a.end;
                      }
                    });
                    var buffered2 = [];
                    if (maxHoleDuration) {
                      for (var i = 0; i < buffered.length; i++) {
                        var buf2len = buffered2.length;
                        if (buf2len) {
                          var buf2end = buffered2[buf2len - 1].end;
                          if (buffered[i].start - buf2end < maxHoleDuration) {
                            if (buffered[i].end > buf2end) {
                              buffered2[buf2len - 1].end = buffered[i].end;
                            }
                          } else {
                            buffered2.push(buffered[i]);
                          }
                        } else {
                          buffered2.push(buffered[i]);
                        }
                      }
                    } else {
                      buffered2 = buffered;
                    }
                    var bufferLen = 0;
                    var bufferStartNext;
                    var bufferStart = pos;
                    var bufferEnd = pos;
                    for (var _i = 0; _i < buffered2.length; _i++) {
                      var start = buffered2[_i].start;
                      var end = buffered2[_i].end;
                      if (pos + maxHoleDuration >= start && pos < end) {
                        bufferStart = start;
                        bufferEnd = end;
                        bufferLen = bufferEnd - pos;
                      } else if (pos + maxHoleDuration < start) {
                        bufferStartNext = start;
                        break;
                      }
                    }
                    return {
                      len: bufferLen,
                      start: bufferStart || 0,
                      end: bufferEnd || 0,
                      nextStart: bufferStartNext
                    };
                  };
                  BufferHelper2.getBuffered = function getBuffered(media) {
                    try {
                      return media.buffered;
                    } catch (e) {
                      _logger__WEBPACK_IMPORTED_MODULE_0__.logger.log("failed to get media.buffered", e);
                      return noopBuffered;
                    }
                  };
                  return BufferHelper2;
                }();
              }
            ),
            /***/
            "./src/utils/cea-608-parser.ts": (
              /*!*************************************!*\
                !*** ./src/utils/cea-608-parser.ts ***!
                \*************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "CaptionScreen": () => (
                    /* binding */
                    CaptionScreen
                  ),
                  /* harmony export */
                  "Row": () => (
                    /* binding */
                    Row
                  ),
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var specialCea608CharsCodes = {
                  42: 225,
                  // lowercase a, acute accent
                  92: 233,
                  // lowercase e, acute accent
                  94: 237,
                  // lowercase i, acute accent
                  95: 243,
                  // lowercase o, acute accent
                  96: 250,
                  // lowercase u, acute accent
                  123: 231,
                  // lowercase c with cedilla
                  124: 247,
                  // division symbol
                  125: 209,
                  // uppercase N tilde
                  126: 241,
                  // lowercase n tilde
                  127: 9608,
                  // Full block
                  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
                  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
                  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
                  128: 174,
                  // Registered symbol (R)
                  129: 176,
                  // degree sign
                  130: 189,
                  // 1/2 symbol
                  131: 191,
                  // Inverted (open) question mark
                  132: 8482,
                  // Trademark symbol (TM)
                  133: 162,
                  // Cents symbol
                  134: 163,
                  // Pounds sterling
                  135: 9834,
                  // Music 8'th note
                  136: 224,
                  // lowercase a, grave accent
                  137: 32,
                  // transparent space (regular)
                  138: 232,
                  // lowercase e, grave accent
                  139: 226,
                  // lowercase a, circumflex accent
                  140: 234,
                  // lowercase e, circumflex accent
                  141: 238,
                  // lowercase i, circumflex accent
                  142: 244,
                  // lowercase o, circumflex accent
                  143: 251,
                  // lowercase u, circumflex accent
                  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
                  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
                  144: 193,
                  // capital letter A with acute
                  145: 201,
                  // capital letter E with acute
                  146: 211,
                  // capital letter O with acute
                  147: 218,
                  // capital letter U with acute
                  148: 220,
                  // capital letter U with diaresis
                  149: 252,
                  // lowercase letter U with diaeresis
                  150: 8216,
                  // opening single quote
                  151: 161,
                  // inverted exclamation mark
                  152: 42,
                  // asterisk
                  153: 8217,
                  // closing single quote
                  154: 9473,
                  // box drawings heavy horizontal
                  155: 169,
                  // copyright sign
                  156: 8480,
                  // Service mark
                  157: 8226,
                  // (round) bullet
                  158: 8220,
                  // Left double quotation mark
                  159: 8221,
                  // Right double quotation mark
                  160: 192,
                  // uppercase A, grave accent
                  161: 194,
                  // uppercase A, circumflex
                  162: 199,
                  // uppercase C with cedilla
                  163: 200,
                  // uppercase E, grave accent
                  164: 202,
                  // uppercase E, circumflex
                  165: 203,
                  // capital letter E with diaresis
                  166: 235,
                  // lowercase letter e with diaresis
                  167: 206,
                  // uppercase I, circumflex
                  168: 207,
                  // uppercase I, with diaresis
                  169: 239,
                  // lowercase i, with diaresis
                  170: 212,
                  // uppercase O, circumflex
                  171: 217,
                  // uppercase U, grave accent
                  172: 249,
                  // lowercase u, grave accent
                  173: 219,
                  // uppercase U, circumflex
                  174: 171,
                  // left-pointing double angle quotation mark
                  175: 187,
                  // right-pointing double angle quotation mark
                  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
                  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
                  176: 195,
                  // Uppercase A, tilde
                  177: 227,
                  // Lowercase a, tilde
                  178: 205,
                  // Uppercase I, acute accent
                  179: 204,
                  // Uppercase I, grave accent
                  180: 236,
                  // Lowercase i, grave accent
                  181: 210,
                  // Uppercase O, grave accent
                  182: 242,
                  // Lowercase o, grave accent
                  183: 213,
                  // Uppercase O, tilde
                  184: 245,
                  // Lowercase o, tilde
                  185: 123,
                  // Open curly brace
                  186: 125,
                  // Closing curly brace
                  187: 92,
                  // Backslash
                  188: 94,
                  // Caret
                  189: 95,
                  // Underscore
                  190: 124,
                  // Pipe (vertical line)
                  191: 8764,
                  // Tilde operator
                  192: 196,
                  // Uppercase A, umlaut
                  193: 228,
                  // Lowercase A, umlaut
                  194: 214,
                  // Uppercase O, umlaut
                  195: 246,
                  // Lowercase o, umlaut
                  196: 223,
                  // Esszett (sharp S)
                  197: 165,
                  // Yen symbol
                  198: 164,
                  // Generic currency sign
                  199: 9475,
                  // Box drawings heavy vertical
                  200: 197,
                  // Uppercase A, ring
                  201: 229,
                  // Lowercase A, ring
                  202: 216,
                  // Uppercase O, stroke
                  203: 248,
                  // Lowercase o, strok
                  204: 9487,
                  // Box drawings heavy down and right
                  205: 9491,
                  // Box drawings heavy down and left
                  206: 9495,
                  // Box drawings heavy up and right
                  207: 9499
                  // Box drawings heavy up and left
                };
                var getCharForByte = function getCharForByte2(_byte) {
                  var charCode = _byte;
                  if (specialCea608CharsCodes.hasOwnProperty(_byte)) {
                    charCode = specialCea608CharsCodes[_byte];
                  }
                  return String.fromCharCode(charCode);
                };
                var NR_ROWS = 15;
                var NR_COLS = 100;
                var rowsLowCh1 = {
                  17: 1,
                  18: 3,
                  21: 5,
                  22: 7,
                  23: 9,
                  16: 11,
                  19: 12,
                  20: 14
                };
                var rowsHighCh1 = {
                  17: 2,
                  18: 4,
                  21: 6,
                  22: 8,
                  23: 10,
                  19: 13,
                  20: 15
                };
                var rowsLowCh2 = {
                  25: 1,
                  26: 3,
                  29: 5,
                  30: 7,
                  31: 9,
                  24: 11,
                  27: 12,
                  28: 14
                };
                var rowsHighCh2 = {
                  25: 2,
                  26: 4,
                  29: 6,
                  30: 8,
                  31: 10,
                  27: 13,
                  28: 15
                };
                var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
                var VerboseLevel;
                (function(VerboseLevel2) {
                  VerboseLevel2[VerboseLevel2["ERROR"] = 0] = "ERROR";
                  VerboseLevel2[VerboseLevel2["TEXT"] = 1] = "TEXT";
                  VerboseLevel2[VerboseLevel2["WARNING"] = 2] = "WARNING";
                  VerboseLevel2[VerboseLevel2["INFO"] = 2] = "INFO";
                  VerboseLevel2[VerboseLevel2["DEBUG"] = 3] = "DEBUG";
                  VerboseLevel2[VerboseLevel2["DATA"] = 3] = "DATA";
                })(VerboseLevel || (VerboseLevel = {}));
                var CaptionsLogger = function() {
                  function CaptionsLogger2() {
                    this.time = null;
                    this.verboseLevel = VerboseLevel.ERROR;
                  }
                  var _proto = CaptionsLogger2.prototype;
                  _proto.log = function log(severity, msg) {
                    if (this.verboseLevel >= severity) {
                      var m = typeof msg === "function" ? msg() : msg;
                      _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.log(this.time + " [" + severity + "] " + m);
                    }
                  };
                  return CaptionsLogger2;
                }();
                var numArrayToHexArray = function numArrayToHexArray2(numArray) {
                  var hexArray = [];
                  for (var j = 0; j < numArray.length; j++) {
                    hexArray.push(numArray[j].toString(16));
                  }
                  return hexArray;
                };
                var PenState = function() {
                  function PenState2(foreground, underline, italics, background, flash) {
                    this.foreground = void 0;
                    this.underline = void 0;
                    this.italics = void 0;
                    this.background = void 0;
                    this.flash = void 0;
                    this.foreground = foreground || "white";
                    this.underline = underline || false;
                    this.italics = italics || false;
                    this.background = background || "black";
                    this.flash = flash || false;
                  }
                  var _proto2 = PenState2.prototype;
                  _proto2.reset = function reset() {
                    this.foreground = "white";
                    this.underline = false;
                    this.italics = false;
                    this.background = "black";
                    this.flash = false;
                  };
                  _proto2.setStyles = function setStyles(styles) {
                    var attribs = ["foreground", "underline", "italics", "background", "flash"];
                    for (var i = 0; i < attribs.length; i++) {
                      var style = attribs[i];
                      if (styles.hasOwnProperty(style)) {
                        this[style] = styles[style];
                      }
                    }
                  };
                  _proto2.isDefault = function isDefault() {
                    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
                  };
                  _proto2.equals = function equals(other) {
                    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
                  };
                  _proto2.copy = function copy(newPenState) {
                    this.foreground = newPenState.foreground;
                    this.underline = newPenState.underline;
                    this.italics = newPenState.italics;
                    this.background = newPenState.background;
                    this.flash = newPenState.flash;
                  };
                  _proto2.toString = function toString() {
                    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
                  };
                  return PenState2;
                }();
                var StyledUnicodeChar = function() {
                  function StyledUnicodeChar2(uchar, foreground, underline, italics, background, flash) {
                    this.uchar = void 0;
                    this.penState = void 0;
                    this.uchar = uchar || " ";
                    this.penState = new PenState(foreground, underline, italics, background, flash);
                  }
                  var _proto3 = StyledUnicodeChar2.prototype;
                  _proto3.reset = function reset() {
                    this.uchar = " ";
                    this.penState.reset();
                  };
                  _proto3.setChar = function setChar(uchar, newPenState) {
                    this.uchar = uchar;
                    this.penState.copy(newPenState);
                  };
                  _proto3.setPenState = function setPenState(newPenState) {
                    this.penState.copy(newPenState);
                  };
                  _proto3.equals = function equals(other) {
                    return this.uchar === other.uchar && this.penState.equals(other.penState);
                  };
                  _proto3.copy = function copy(newChar) {
                    this.uchar = newChar.uchar;
                    this.penState.copy(newChar.penState);
                  };
                  _proto3.isEmpty = function isEmpty() {
                    return this.uchar === " " && this.penState.isDefault();
                  };
                  return StyledUnicodeChar2;
                }();
                var Row = function() {
                  function Row2(logger) {
                    this.chars = void 0;
                    this.pos = void 0;
                    this.currPenState = void 0;
                    this.cueStartTime = void 0;
                    this.logger = void 0;
                    this.chars = [];
                    for (var i = 0; i < NR_COLS; i++) {
                      this.chars.push(new StyledUnicodeChar());
                    }
                    this.logger = logger;
                    this.pos = 0;
                    this.currPenState = new PenState();
                  }
                  var _proto4 = Row2.prototype;
                  _proto4.equals = function equals(other) {
                    var equal = true;
                    for (var i = 0; i < NR_COLS; i++) {
                      if (!this.chars[i].equals(other.chars[i])) {
                        equal = false;
                        break;
                      }
                    }
                    return equal;
                  };
                  _proto4.copy = function copy(other) {
                    for (var i = 0; i < NR_COLS; i++) {
                      this.chars[i].copy(other.chars[i]);
                    }
                  };
                  _proto4.isEmpty = function isEmpty() {
                    var empty = true;
                    for (var i = 0; i < NR_COLS; i++) {
                      if (!this.chars[i].isEmpty()) {
                        empty = false;
                        break;
                      }
                    }
                    return empty;
                  };
                  _proto4.setCursor = function setCursor(absPos) {
                    if (this.pos !== absPos) {
                      this.pos = absPos;
                    }
                    if (this.pos < 0) {
                      this.logger.log(VerboseLevel.DEBUG, "Negative cursor position " + this.pos);
                      this.pos = 0;
                    } else if (this.pos > NR_COLS) {
                      this.logger.log(VerboseLevel.DEBUG, "Too large cursor position " + this.pos);
                      this.pos = NR_COLS;
                    }
                  };
                  _proto4.moveCursor = function moveCursor(relPos) {
                    var newPos = this.pos + relPos;
                    if (relPos > 1) {
                      for (var i = this.pos + 1; i < newPos + 1; i++) {
                        this.chars[i].setPenState(this.currPenState);
                      }
                    }
                    this.setCursor(newPos);
                  };
                  _proto4.backSpace = function backSpace() {
                    this.moveCursor(-1);
                    this.chars[this.pos].setChar(" ", this.currPenState);
                  };
                  _proto4.insertChar = function insertChar(_byte2) {
                    var _this = this;
                    if (_byte2 >= 144) {
                      this.backSpace();
                    }
                    var _char = getCharForByte(_byte2);
                    if (this.pos >= NR_COLS) {
                      this.logger.log(VerboseLevel.ERROR, function() {
                        return "Cannot insert " + _byte2.toString(16) + " (" + _char + ") at position " + _this.pos + ". Skipping it!";
                      });
                      return;
                    }
                    this.chars[this.pos].setChar(_char, this.currPenState);
                    this.moveCursor(1);
                  };
                  _proto4.clearFromPos = function clearFromPos(startPos) {
                    var i;
                    for (i = startPos; i < NR_COLS; i++) {
                      this.chars[i].reset();
                    }
                  };
                  _proto4.clear = function clear() {
                    this.clearFromPos(0);
                    this.pos = 0;
                    this.currPenState.reset();
                  };
                  _proto4.clearToEndOfRow = function clearToEndOfRow() {
                    this.clearFromPos(this.pos);
                  };
                  _proto4.getTextString = function getTextString() {
                    var chars = [];
                    var empty = true;
                    for (var i = 0; i < NR_COLS; i++) {
                      var _char2 = this.chars[i].uchar;
                      if (_char2 !== " ") {
                        empty = false;
                      }
                      chars.push(_char2);
                    }
                    if (empty) {
                      return "";
                    } else {
                      return chars.join("");
                    }
                  };
                  _proto4.setPenStyles = function setPenStyles(styles) {
                    this.currPenState.setStyles(styles);
                    var currChar = this.chars[this.pos];
                    currChar.setPenState(this.currPenState);
                  };
                  return Row2;
                }();
                var CaptionScreen = function() {
                  function CaptionScreen2(logger) {
                    this.rows = void 0;
                    this.currRow = void 0;
                    this.nrRollUpRows = void 0;
                    this.lastOutputScreen = void 0;
                    this.logger = void 0;
                    this.rows = [];
                    for (var i = 0; i < NR_ROWS; i++) {
                      this.rows.push(new Row(logger));
                    }
                    this.logger = logger;
                    this.currRow = NR_ROWS - 1;
                    this.nrRollUpRows = null;
                    this.lastOutputScreen = null;
                    this.reset();
                  }
                  var _proto5 = CaptionScreen2.prototype;
                  _proto5.reset = function reset() {
                    for (var i = 0; i < NR_ROWS; i++) {
                      this.rows[i].clear();
                    }
                    this.currRow = NR_ROWS - 1;
                  };
                  _proto5.equals = function equals(other) {
                    var equal = true;
                    for (var i = 0; i < NR_ROWS; i++) {
                      if (!this.rows[i].equals(other.rows[i])) {
                        equal = false;
                        break;
                      }
                    }
                    return equal;
                  };
                  _proto5.copy = function copy(other) {
                    for (var i = 0; i < NR_ROWS; i++) {
                      this.rows[i].copy(other.rows[i]);
                    }
                  };
                  _proto5.isEmpty = function isEmpty() {
                    var empty = true;
                    for (var i = 0; i < NR_ROWS; i++) {
                      if (!this.rows[i].isEmpty()) {
                        empty = false;
                        break;
                      }
                    }
                    return empty;
                  };
                  _proto5.backSpace = function backSpace() {
                    var row = this.rows[this.currRow];
                    row.backSpace();
                  };
                  _proto5.clearToEndOfRow = function clearToEndOfRow() {
                    var row = this.rows[this.currRow];
                    row.clearToEndOfRow();
                  };
                  _proto5.insertChar = function insertChar(_char3) {
                    var row = this.rows[this.currRow];
                    row.insertChar(_char3);
                  };
                  _proto5.setPen = function setPen(styles) {
                    var row = this.rows[this.currRow];
                    row.setPenStyles(styles);
                  };
                  _proto5.moveCursor = function moveCursor(relPos) {
                    var row = this.rows[this.currRow];
                    row.moveCursor(relPos);
                  };
                  _proto5.setCursor = function setCursor(absPos) {
                    this.logger.log(VerboseLevel.INFO, "setCursor: " + absPos);
                    var row = this.rows[this.currRow];
                    row.setCursor(absPos);
                  };
                  _proto5.setPAC = function setPAC(pacData) {
                    this.logger.log(VerboseLevel.INFO, function() {
                      return "pacData = " + JSON.stringify(pacData);
                    });
                    var newRow = pacData.row - 1;
                    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                      newRow = this.nrRollUpRows - 1;
                    }
                    if (this.nrRollUpRows && this.currRow !== newRow) {
                      for (var i = 0; i < NR_ROWS; i++) {
                        this.rows[i].clear();
                      }
                      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                      var lastOutputScreen = this.lastOutputScreen;
                      if (lastOutputScreen) {
                        var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                        var time = this.logger.time;
                        if (prevLineTime && time !== null && prevLineTime < time) {
                          for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                          }
                        }
                      }
                    }
                    this.currRow = newRow;
                    var row = this.rows[this.currRow];
                    if (pacData.indent !== null) {
                      var indent = pacData.indent;
                      var prevPos = Math.max(indent - 1, 0);
                      row.setCursor(pacData.indent);
                      pacData.color = row.chars[prevPos].penState.foreground;
                    }
                    var styles = {
                      foreground: pacData.color,
                      underline: pacData.underline,
                      italics: pacData.italics,
                      background: "black",
                      flash: false
                    };
                    this.setPen(styles);
                  };
                  _proto5.setBkgData = function setBkgData(bkgData) {
                    this.logger.log(VerboseLevel.INFO, function() {
                      return "bkgData = " + JSON.stringify(bkgData);
                    });
                    this.backSpace();
                    this.setPen(bkgData);
                    this.insertChar(32);
                  };
                  _proto5.setRollUpRows = function setRollUpRows(nrRows) {
                    this.nrRollUpRows = nrRows;
                  };
                  _proto5.rollUp = function rollUp() {
                    var _this2 = this;
                    if (this.nrRollUpRows === null) {
                      this.logger.log(VerboseLevel.DEBUG, "roll_up but nrRollUpRows not set yet");
                      return;
                    }
                    this.logger.log(VerboseLevel.TEXT, function() {
                      return _this2.getDisplayText();
                    });
                    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                    var topRow = this.rows.splice(topRowIndex, 1)[0];
                    topRow.clear();
                    this.rows.splice(this.currRow, 0, topRow);
                    this.logger.log(VerboseLevel.INFO, "Rolling up");
                  };
                  _proto5.getDisplayText = function getDisplayText(asOneRow) {
                    asOneRow = asOneRow || false;
                    var displayText = [];
                    var text = "";
                    var rowNr = -1;
                    for (var i = 0; i < NR_ROWS; i++) {
                      var rowText = this.rows[i].getTextString();
                      if (rowText) {
                        rowNr = i + 1;
                        if (asOneRow) {
                          displayText.push("Row " + rowNr + ": '" + rowText + "'");
                        } else {
                          displayText.push(rowText.trim());
                        }
                      }
                    }
                    if (displayText.length > 0) {
                      if (asOneRow) {
                        text = "[" + displayText.join(" | ") + "]";
                      } else {
                        text = displayText.join("\n");
                      }
                    }
                    return text;
                  };
                  _proto5.getTextAndFormat = function getTextAndFormat() {
                    return this.rows;
                  };
                  return CaptionScreen2;
                }();
                var Cea608Channel = function() {
                  function Cea608Channel2(channelNumber, outputFilter, logger) {
                    this.chNr = void 0;
                    this.outputFilter = void 0;
                    this.mode = void 0;
                    this.verbose = void 0;
                    this.displayedMemory = void 0;
                    this.nonDisplayedMemory = void 0;
                    this.lastOutputScreen = void 0;
                    this.currRollUpRow = void 0;
                    this.writeScreen = void 0;
                    this.cueStartTime = void 0;
                    this.logger = void 0;
                    this.chNr = channelNumber;
                    this.outputFilter = outputFilter;
                    this.mode = null;
                    this.verbose = 0;
                    this.displayedMemory = new CaptionScreen(logger);
                    this.nonDisplayedMemory = new CaptionScreen(logger);
                    this.lastOutputScreen = new CaptionScreen(logger);
                    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                    this.writeScreen = this.displayedMemory;
                    this.mode = null;
                    this.cueStartTime = null;
                    this.logger = logger;
                  }
                  var _proto6 = Cea608Channel2.prototype;
                  _proto6.reset = function reset() {
                    this.mode = null;
                    this.displayedMemory.reset();
                    this.nonDisplayedMemory.reset();
                    this.lastOutputScreen.reset();
                    this.outputFilter.reset();
                    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                    this.writeScreen = this.displayedMemory;
                    this.mode = null;
                    this.cueStartTime = null;
                  };
                  _proto6.getHandler = function getHandler() {
                    return this.outputFilter;
                  };
                  _proto6.setHandler = function setHandler(newHandler) {
                    this.outputFilter = newHandler;
                  };
                  _proto6.setPAC = function setPAC(pacData) {
                    this.writeScreen.setPAC(pacData);
                  };
                  _proto6.setBkgData = function setBkgData(bkgData) {
                    this.writeScreen.setBkgData(bkgData);
                  };
                  _proto6.setMode = function setMode(newMode) {
                    if (newMode === this.mode) {
                      return;
                    }
                    this.mode = newMode;
                    this.logger.log(VerboseLevel.INFO, function() {
                      return "MODE=" + newMode;
                    });
                    if (this.mode === "MODE_POP-ON") {
                      this.writeScreen = this.nonDisplayedMemory;
                    } else {
                      this.writeScreen = this.displayedMemory;
                      this.writeScreen.reset();
                    }
                    if (this.mode !== "MODE_ROLL-UP") {
                      this.displayedMemory.nrRollUpRows = null;
                      this.nonDisplayedMemory.nrRollUpRows = null;
                    }
                    this.mode = newMode;
                  };
                  _proto6.insertChars = function insertChars(chars) {
                    var _this3 = this;
                    for (var i = 0; i < chars.length; i++) {
                      this.writeScreen.insertChar(chars[i]);
                    }
                    var screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                    this.logger.log(VerboseLevel.INFO, function() {
                      return screen + ": " + _this3.writeScreen.getDisplayText(true);
                    });
                    if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
                      this.logger.log(VerboseLevel.TEXT, function() {
                        return "DISPLAYED: " + _this3.displayedMemory.getDisplayText(true);
                      });
                      this.outputDataUpdate();
                    }
                  };
                  _proto6.ccRCL = function ccRCL() {
                    this.logger.log(VerboseLevel.INFO, "RCL - Resume Caption Loading");
                    this.setMode("MODE_POP-ON");
                  };
                  _proto6.ccBS = function ccBS() {
                    this.logger.log(VerboseLevel.INFO, "BS - BackSpace");
                    if (this.mode === "MODE_TEXT") {
                      return;
                    }
                    this.writeScreen.backSpace();
                    if (this.writeScreen === this.displayedMemory) {
                      this.outputDataUpdate();
                    }
                  };
                  _proto6.ccAOF = function ccAOF() {
                  };
                  _proto6.ccAON = function ccAON() {
                  };
                  _proto6.ccDER = function ccDER() {
                    this.logger.log(VerboseLevel.INFO, "DER- Delete to End of Row");
                    this.writeScreen.clearToEndOfRow();
                    this.outputDataUpdate();
                  };
                  _proto6.ccRU = function ccRU(nrRows) {
                    this.logger.log(VerboseLevel.INFO, "RU(" + nrRows + ") - Roll Up");
                    this.writeScreen = this.displayedMemory;
                    this.setMode("MODE_ROLL-UP");
                    this.writeScreen.setRollUpRows(nrRows);
                  };
                  _proto6.ccFON = function ccFON() {
                    this.logger.log(VerboseLevel.INFO, "FON - Flash On");
                    this.writeScreen.setPen({
                      flash: true
                    });
                  };
                  _proto6.ccRDC = function ccRDC() {
                    this.logger.log(VerboseLevel.INFO, "RDC - Resume Direct Captioning");
                    this.setMode("MODE_PAINT-ON");
                  };
                  _proto6.ccTR = function ccTR() {
                    this.logger.log(VerboseLevel.INFO, "TR");
                    this.setMode("MODE_TEXT");
                  };
                  _proto6.ccRTD = function ccRTD() {
                    this.logger.log(VerboseLevel.INFO, "RTD");
                    this.setMode("MODE_TEXT");
                  };
                  _proto6.ccEDM = function ccEDM() {
                    this.logger.log(VerboseLevel.INFO, "EDM - Erase Displayed Memory");
                    this.displayedMemory.reset();
                    this.outputDataUpdate(true);
                  };
                  _proto6.ccCR = function ccCR() {
                    this.logger.log(VerboseLevel.INFO, "CR - Carriage Return");
                    this.writeScreen.rollUp();
                    this.outputDataUpdate(true);
                  };
                  _proto6.ccENM = function ccENM() {
                    this.logger.log(VerboseLevel.INFO, "ENM - Erase Non-displayed Memory");
                    this.nonDisplayedMemory.reset();
                  };
                  _proto6.ccEOC = function ccEOC() {
                    var _this4 = this;
                    this.logger.log(VerboseLevel.INFO, "EOC - End Of Caption");
                    if (this.mode === "MODE_POP-ON") {
                      var tmp = this.displayedMemory;
                      this.displayedMemory = this.nonDisplayedMemory;
                      this.nonDisplayedMemory = tmp;
                      this.writeScreen = this.nonDisplayedMemory;
                      this.logger.log(VerboseLevel.TEXT, function() {
                        return "DISP: " + _this4.displayedMemory.getDisplayText();
                      });
                    }
                    this.outputDataUpdate(true);
                  };
                  _proto6.ccTO = function ccTO(nrCols) {
                    this.logger.log(VerboseLevel.INFO, "TO(" + nrCols + ") - Tab Offset");
                    this.writeScreen.moveCursor(nrCols);
                  };
                  _proto6.ccMIDROW = function ccMIDROW(secondByte) {
                    var styles = {
                      flash: false
                    };
                    styles.underline = secondByte % 2 === 1;
                    styles.italics = secondByte >= 46;
                    if (!styles.italics) {
                      var colorIndex = Math.floor(secondByte / 2) - 16;
                      var colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                      styles.foreground = colors[colorIndex];
                    } else {
                      styles.foreground = "white";
                    }
                    this.logger.log(VerboseLevel.INFO, "MIDROW: " + JSON.stringify(styles));
                    this.writeScreen.setPen(styles);
                  };
                  _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {
                    if (dispatch === void 0) {
                      dispatch = false;
                    }
                    var time = this.logger.time;
                    if (time === null) {
                      return;
                    }
                    if (this.outputFilter) {
                      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                        this.cueStartTime = time;
                      } else {
                        if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
                          if (dispatch && this.outputFilter.dispatchCue) {
                            this.outputFilter.dispatchCue();
                          }
                          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
                        }
                      }
                      this.lastOutputScreen.copy(this.displayedMemory);
                    }
                  };
                  _proto6.cueSplitAtTime = function cueSplitAtTime(t) {
                    if (this.outputFilter) {
                      if (!this.displayedMemory.isEmpty()) {
                        if (this.outputFilter.newCue) {
                          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                        }
                        this.cueStartTime = t;
                      }
                    }
                  };
                  return Cea608Channel2;
                }();
                var Cea608Parser = function() {
                  function Cea608Parser2(field, out1, out2) {
                    this.channels = void 0;
                    this.currentChannel = 0;
                    this.cmdHistory = void 0;
                    this.logger = void 0;
                    var logger = new CaptionsLogger();
                    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];
                    this.cmdHistory = createCmdHistory();
                    this.logger = logger;
                  }
                  var _proto7 = Cea608Parser2.prototype;
                  _proto7.getHandler = function getHandler(channel) {
                    return this.channels[channel].getHandler();
                  };
                  _proto7.setHandler = function setHandler(channel, newHandler) {
                    this.channels[channel].setHandler(newHandler);
                  };
                  _proto7.addData = function addData(time, byteList) {
                    var cmdFound;
                    var a;
                    var b;
                    var charsFound = false;
                    this.logger.time = time;
                    for (var i = 0; i < byteList.length; i += 2) {
                      a = byteList[i] & 127;
                      b = byteList[i + 1] & 127;
                      if (a === 0 && b === 0) {
                        continue;
                      } else {
                        this.logger.log(VerboseLevel.DATA, "[" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")");
                      }
                      cmdFound = this.parseCmd(a, b);
                      if (!cmdFound) {
                        cmdFound = this.parseMidrow(a, b);
                      }
                      if (!cmdFound) {
                        cmdFound = this.parsePAC(a, b);
                      }
                      if (!cmdFound) {
                        cmdFound = this.parseBackgroundAttributes(a, b);
                      }
                      if (!cmdFound) {
                        charsFound = this.parseChars(a, b);
                        if (charsFound) {
                          var currChNr = this.currentChannel;
                          if (currChNr && currChNr > 0) {
                            var channel = this.channels[currChNr];
                            channel.insertChars(charsFound);
                          } else {
                            this.logger.log(VerboseLevel.WARNING, "No channel found yet. TEXT-MODE?");
                          }
                        }
                      }
                      if (!cmdFound && !charsFound) {
                        this.logger.log(VerboseLevel.WARNING, "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                      }
                    }
                  };
                  _proto7.parseCmd = function parseCmd(a, b) {
                    var cmdHistory = this.cmdHistory;
                    var cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
                    var cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
                    if (!(cond1 || cond2)) {
                      return false;
                    }
                    if (hasCmdRepeated(a, b, cmdHistory)) {
                      setLastCmd(null, null, cmdHistory);
                      this.logger.log(VerboseLevel.DEBUG, "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped");
                      return true;
                    }
                    var chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
                    var channel = this.channels[chNr];
                    if (a === 20 || a === 21 || a === 28 || a === 29) {
                      if (b === 32) {
                        channel.ccRCL();
                      } else if (b === 33) {
                        channel.ccBS();
                      } else if (b === 34) {
                        channel.ccAOF();
                      } else if (b === 35) {
                        channel.ccAON();
                      } else if (b === 36) {
                        channel.ccDER();
                      } else if (b === 37) {
                        channel.ccRU(2);
                      } else if (b === 38) {
                        channel.ccRU(3);
                      } else if (b === 39) {
                        channel.ccRU(4);
                      } else if (b === 40) {
                        channel.ccFON();
                      } else if (b === 41) {
                        channel.ccRDC();
                      } else if (b === 42) {
                        channel.ccTR();
                      } else if (b === 43) {
                        channel.ccRTD();
                      } else if (b === 44) {
                        channel.ccEDM();
                      } else if (b === 45) {
                        channel.ccCR();
                      } else if (b === 46) {
                        channel.ccENM();
                      } else if (b === 47) {
                        channel.ccEOC();
                      }
                    } else {
                      channel.ccTO(b - 32);
                    }
                    setLastCmd(a, b, cmdHistory);
                    this.currentChannel = chNr;
                    return true;
                  };
                  _proto7.parseMidrow = function parseMidrow(a, b) {
                    var chNr = 0;
                    if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
                      if (a === 17) {
                        chNr = 1;
                      } else {
                        chNr = 2;
                      }
                      if (chNr !== this.currentChannel) {
                        this.logger.log(VerboseLevel.ERROR, "Mismatch channel in midrow parsing");
                        return false;
                      }
                      var channel = this.channels[chNr];
                      if (!channel) {
                        return false;
                      }
                      channel.ccMIDROW(b);
                      this.logger.log(VerboseLevel.DEBUG, "MIDROW (" + numArrayToHexArray([a, b]) + ")");
                      return true;
                    }
                    return false;
                  };
                  _proto7.parsePAC = function parsePAC(a, b) {
                    var row;
                    var cmdHistory = this.cmdHistory;
                    var case1 = (a >= 17 && a <= 23 || a >= 25 && a <= 31) && b >= 64 && b <= 127;
                    var case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
                    if (!(case1 || case2)) {
                      return false;
                    }
                    if (hasCmdRepeated(a, b, cmdHistory)) {
                      setLastCmd(null, null, cmdHistory);
                      return true;
                    }
                    var chNr = a <= 23 ? 1 : 2;
                    if (b >= 64 && b <= 95) {
                      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
                    } else {
                      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
                    }
                    var channel = this.channels[chNr];
                    if (!channel) {
                      return false;
                    }
                    channel.setPAC(this.interpretPAC(row, b));
                    setLastCmd(a, b, cmdHistory);
                    this.currentChannel = chNr;
                    return true;
                  };
                  _proto7.interpretPAC = function interpretPAC(row, _byte3) {
                    var pacIndex;
                    var pacData = {
                      color: null,
                      italics: false,
                      indent: null,
                      underline: false,
                      row
                    };
                    if (_byte3 > 95) {
                      pacIndex = _byte3 - 96;
                    } else {
                      pacIndex = _byte3 - 64;
                    }
                    pacData.underline = (pacIndex & 1) === 1;
                    if (pacIndex <= 13) {
                      pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
                    } else if (pacIndex <= 15) {
                      pacData.italics = true;
                      pacData.color = "white";
                    } else {
                      pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
                    }
                    return pacData;
                  };
                  _proto7.parseChars = function parseChars(a, b) {
                    var channelNr;
                    var charCodes = null;
                    var charCode1 = null;
                    if (a >= 25) {
                      channelNr = 2;
                      charCode1 = a - 8;
                    } else {
                      channelNr = 1;
                      charCode1 = a;
                    }
                    if (charCode1 >= 17 && charCode1 <= 19) {
                      var oneCode;
                      if (charCode1 === 17) {
                        oneCode = b + 80;
                      } else if (charCode1 === 18) {
                        oneCode = b + 112;
                      } else {
                        oneCode = b + 144;
                      }
                      this.logger.log(VerboseLevel.INFO, "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
                      charCodes = [oneCode];
                    } else if (a >= 32 && a <= 127) {
                      charCodes = b === 0 ? [a] : [a, b];
                    }
                    if (charCodes) {
                      var hexCodes = numArrayToHexArray(charCodes);
                      this.logger.log(VerboseLevel.DEBUG, "Char codes =  " + hexCodes.join(","));
                      setLastCmd(a, b, this.cmdHistory);
                    }
                    return charCodes;
                  };
                  _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
                    var case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
                    var case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
                    if (!(case1 || case2)) {
                      return false;
                    }
                    var index;
                    var bkgData = {};
                    if (a === 16 || a === 24) {
                      index = Math.floor((b - 32) / 2);
                      bkgData.background = backgroundColors[index];
                      if (b % 2 === 1) {
                        bkgData.background = bkgData.background + "_semi";
                      }
                    } else if (b === 45) {
                      bkgData.background = "transparent";
                    } else {
                      bkgData.foreground = "black";
                      if (b === 47) {
                        bkgData.underline = true;
                      }
                    }
                    var chNr = a <= 23 ? 1 : 2;
                    var channel = this.channels[chNr];
                    channel.setBkgData(bkgData);
                    setLastCmd(a, b, this.cmdHistory);
                    return true;
                  };
                  _proto7.reset = function reset() {
                    for (var i = 0; i < Object.keys(this.channels).length; i++) {
                      var channel = this.channels[i];
                      if (channel) {
                        channel.reset();
                      }
                    }
                    this.cmdHistory = createCmdHistory();
                  };
                  _proto7.cueSplitAtTime = function cueSplitAtTime(t) {
                    for (var i = 0; i < this.channels.length; i++) {
                      var channel = this.channels[i];
                      if (channel) {
                        channel.cueSplitAtTime(t);
                      }
                    }
                  };
                  return Cea608Parser2;
                }();
                function setLastCmd(a, b, cmdHistory) {
                  cmdHistory.a = a;
                  cmdHistory.b = b;
                }
                function hasCmdRepeated(a, b, cmdHistory) {
                  return cmdHistory.a === a && cmdHistory.b === b;
                }
                function createCmdHistory() {
                  return {
                    a: null,
                    b: null
                  };
                }
                const __WEBPACK_DEFAULT_EXPORT__ = Cea608Parser;
              }
            ),
            /***/
            "./src/utils/codecs.ts": (
              /*!*****************************!*\
                !*** ./src/utils/codecs.ts ***!
                \*****************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "isCodecSupportedInMp4": () => (
                    /* binding */
                    isCodecSupportedInMp4
                  ),
                  /* harmony export */
                  "isCodecType": () => (
                    /* binding */
                    isCodecType
                  )
                  /* harmony export */
                });
                var sampleEntryCodesISO = {
                  audio: {
                    a3ds: true,
                    "ac-3": true,
                    "ac-4": true,
                    alac: true,
                    alaw: true,
                    dra1: true,
                    "dts+": true,
                    "dts-": true,
                    dtsc: true,
                    dtse: true,
                    dtsh: true,
                    "ec-3": true,
                    enca: true,
                    g719: true,
                    g726: true,
                    m4ae: true,
                    mha1: true,
                    mha2: true,
                    mhm1: true,
                    mhm2: true,
                    mlpa: true,
                    mp4a: true,
                    "raw ": true,
                    Opus: true,
                    opus: true,
                    // browsers expect this to be lowercase despite MP4RA says 'Opus'
                    samr: true,
                    sawb: true,
                    sawp: true,
                    sevc: true,
                    sqcp: true,
                    ssmv: true,
                    twos: true,
                    ulaw: true
                  },
                  video: {
                    avc1: true,
                    avc2: true,
                    avc3: true,
                    avc4: true,
                    avcp: true,
                    av01: true,
                    drac: true,
                    dva1: true,
                    dvav: true,
                    dvh1: true,
                    dvhe: true,
                    encv: true,
                    hev1: true,
                    hvc1: true,
                    mjp2: true,
                    mp4v: true,
                    mvc1: true,
                    mvc2: true,
                    mvc3: true,
                    mvc4: true,
                    resv: true,
                    rv60: true,
                    s263: true,
                    svc1: true,
                    svc2: true,
                    "vc-1": true,
                    vp08: true,
                    vp09: true
                  },
                  text: {
                    stpp: true,
                    wvtt: true
                  }
                };
                function isCodecType(codec, type) {
                  var typeCodes = sampleEntryCodesISO[type];
                  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
                }
                function isCodecSupportedInMp4(codec, type) {
                  return MediaSource.isTypeSupported((type || "video") + '/mp4;codecs="' + codec + '"');
                }
              }
            ),
            /***/
            "./src/utils/cues.ts": (
              /*!***************************!*\
                !*** ./src/utils/cues.ts ***!
                \***************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _vttparser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./vttparser */
                  "./src/utils/vttparser.ts"
                );
                var _webvtt_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./webvtt-parser */
                  "./src/utils/webvtt-parser.ts"
                );
                var _texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./texttrack-utils */
                  "./src/utils/texttrack-utils.ts"
                );
                var WHITESPACE_CHAR = /\s/;
                var Cues = {
                  newCue: function newCue(track, startTime, endTime, captionScreen) {
                    var result = [];
                    var row;
                    var cue;
                    var indenting;
                    var indent;
                    var text;
                    var Cue = self.VTTCue || self.TextTrackCue;
                    for (var r = 0; r < captionScreen.rows.length; r++) {
                      row = captionScreen.rows[r];
                      indenting = true;
                      indent = 0;
                      text = "";
                      if (!row.isEmpty()) {
                        for (var c = 0; c < row.chars.length; c++) {
                          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
                            indent++;
                          } else {
                            text += row.chars[c].uchar;
                            indenting = false;
                          }
                        }
                        row.cueStartTime = startTime;
                        if (startTime === endTime) {
                          endTime += 1e-4;
                        }
                        if (indent >= 16) {
                          indent--;
                        } else {
                          indent++;
                        }
                        var cueText = (0, _vttparser__WEBPACK_IMPORTED_MODULE_0__.fixLineBreaks)(text.trim());
                        var id = (0, _webvtt_parser__WEBPACK_IMPORTED_MODULE_1__.generateCueId)(startTime, endTime, cueText);
                        if (!track || !track.cues || !track.cues.getCueById(id)) {
                          cue = new Cue(startTime, endTime, cueText);
                          cue.id = id;
                          cue.line = r + 1;
                          cue.align = "left";
                          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
                          result.push(cue);
                        }
                      }
                    }
                    if (track && result.length) {
                      result.sort(function(cueA, cueB) {
                        if (cueA.line === "auto" || cueB.line === "auto") {
                          return 0;
                        }
                        if (cueA.line > 8 && cueB.line > 8) {
                          return cueB.line - cueA.line;
                        }
                        return cueA.line - cueB.line;
                      });
                      result.forEach(function(cue2) {
                        return (0, _texttrack_utils__WEBPACK_IMPORTED_MODULE_2__.addCueToTrack)(track, cue2);
                      });
                    }
                    return result;
                  }
                };
                const __WEBPACK_DEFAULT_EXPORT__ = Cues;
              }
            ),
            /***/
            "./src/utils/discontinuities.ts": (
              /*!**************************************!*\
                !*** ./src/utils/discontinuities.ts ***!
                \**************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "adjustSlidingStart": () => (
                    /* binding */
                    adjustSlidingStart
                  ),
                  /* harmony export */
                  "alignMediaPlaylistByPDT": () => (
                    /* binding */
                    alignMediaPlaylistByPDT
                  ),
                  /* harmony export */
                  "alignPDT": () => (
                    /* binding */
                    alignPDT
                  ),
                  /* harmony export */
                  "alignStream": () => (
                    /* binding */
                    alignStream
                  ),
                  /* harmony export */
                  "findDiscontinuousReferenceFrag": () => (
                    /* binding */
                    findDiscontinuousReferenceFrag
                  ),
                  /* harmony export */
                  "findFirstFragWithCC": () => (
                    /* binding */
                    findFirstFragWithCC
                  ),
                  /* harmony export */
                  "shouldAlignOnDiscontinuities": () => (
                    /* binding */
                    shouldAlignOnDiscontinuities
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./logger */
                  "./src/utils/logger.ts"
                );
                var _controller_level_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../controller/level-helper */
                  "./src/controller/level-helper.ts"
                );
                function findFirstFragWithCC(fragments, cc) {
                  var firstFrag = null;
                  for (var i = 0, len = fragments.length; i < len; i++) {
                    var currentFrag = fragments[i];
                    if (currentFrag && currentFrag.cc === cc) {
                      firstFrag = currentFrag;
                      break;
                    }
                  }
                  return firstFrag;
                }
                function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
                  if (lastLevel.details) {
                    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
                      return true;
                    }
                  }
                  return false;
                }
                function findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex) {
                  if (referenceIndex === void 0) {
                    referenceIndex = 0;
                  }
                  var prevFrags = prevDetails.fragments;
                  var curFrags = curDetails.fragments;
                  if (!curFrags.length || !prevFrags.length) {
                    _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log("No fragments to align");
                    return;
                  }
                  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
                  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
                    _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log("No frag in previous level to align on");
                    return;
                  }
                  return prevStartFrag;
                }
                function adjustFragmentStart(frag, sliding) {
                  if (frag) {
                    var start = frag.start + sliding;
                    frag.start = frag.startPTS = start;
                    frag.endPTS = start + frag.duration;
                  }
                }
                function adjustSlidingStart(sliding, details) {
                  var fragments = details.fragments;
                  for (var i = 0, len = fragments.length; i < len; i++) {
                    adjustFragmentStart(fragments[i], sliding);
                  }
                  if (details.fragmentHint) {
                    adjustFragmentStart(details.fragmentHint, sliding);
                  }
                  details.alignedSliding = true;
                }
                function alignStream(lastFrag, lastLevel, details) {
                  if (!lastLevel) {
                    return;
                  }
                  alignDiscontinuities(lastFrag, details, lastLevel);
                  if (!details.alignedSliding && lastLevel.details) {
                    alignPDT(details, lastLevel.details);
                  }
                  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {
                    (0, _controller_level_helper__WEBPACK_IMPORTED_MODULE_2__.adjustSliding)(lastLevel.details, details);
                  }
                }
                function alignDiscontinuities(lastFrag, details, lastLevel) {
                  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
                    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
                    if (referenceFrag && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(referenceFrag.start)) {
                      _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log("Adjusting PTS using last level due to CC increase within current level " + details.url);
                      adjustSlidingStart(referenceFrag.start, details);
                    }
                  }
                }
                function alignPDT(details, lastDetails) {
                  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
                    return;
                  }
                  var lastPDT = lastDetails.fragments[0].programDateTime;
                  var newPDT = details.fragments[0].programDateTime;
                  var sliding = (newPDT - lastPDT) / 1e3 + lastDetails.fragments[0].start;
                  if (sliding && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(sliding)) {
                    _logger__WEBPACK_IMPORTED_MODULE_1__.logger.log("Adjusting PTS using programDateTime delta " + (newPDT - lastPDT) + "ms, sliding:" + sliding.toFixed(3) + " " + details.url + " ");
                    adjustSlidingStart(sliding, details);
                  }
                }
                function alignMediaPlaylistByPDT(details, refDetails) {
                  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
                    return;
                  }
                  var fragments = details.fragments;
                  var refFragments = refDetails.fragments;
                  if (!fragments.length || !refFragments.length) {
                    return;
                  }
                  var middleFrag = Math.round(refFragments.length / 2) - 1;
                  var refFrag = refFragments[middleFrag];
                  var frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.round(fragments.length / 2) - 1];
                  var refPDT = refFrag.programDateTime;
                  var targetPDT = frag.programDateTime;
                  if (refPDT === null || targetPDT === null) {
                    return;
                  }
                  var delta = (targetPDT - refPDT) / 1e3 - (frag.start - refFrag.start);
                  adjustSlidingStart(delta, details);
                }
              }
            ),
            /***/
            "./src/utils/ewma-bandwidth-estimator.ts": (
              /*!***********************************************!*\
                !*** ./src/utils/ewma-bandwidth-estimator.ts ***!
                \***********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _utils_ewma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/ewma */
                  "./src/utils/ewma.ts"
                );
                var EwmaBandWidthEstimator = function() {
                  function EwmaBandWidthEstimator2(slow, fast, defaultEstimate) {
                    this.defaultEstimate_ = void 0;
                    this.minWeight_ = void 0;
                    this.minDelayMs_ = void 0;
                    this.slow_ = void 0;
                    this.fast_ = void 0;
                    this.defaultEstimate_ = defaultEstimate;
                    this.minWeight_ = 1e-3;
                    this.minDelayMs_ = 50;
                    this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](slow);
                    this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](fast);
                  }
                  var _proto = EwmaBandWidthEstimator2.prototype;
                  _proto.update = function update(slow, fast) {
                    var slow_ = this.slow_, fast_ = this.fast_;
                    if (this.slow_.halfLife !== slow) {
                      this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](slow, slow_.getEstimate(), slow_.getTotalWeight());
                    }
                    if (this.fast_.halfLife !== fast) {
                      this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](fast, fast_.getEstimate(), fast_.getTotalWeight());
                    }
                  };
                  _proto.sample = function sample(durationMs, numBytes) {
                    durationMs = Math.max(durationMs, this.minDelayMs_);
                    var numBits = 8 * numBytes;
                    var durationS = durationMs / 1e3;
                    var bandwidthInBps = numBits / durationS;
                    this.fast_.sample(durationS, bandwidthInBps);
                    this.slow_.sample(durationS, bandwidthInBps);
                  };
                  _proto.canEstimate = function canEstimate() {
                    var fast = this.fast_;
                    return fast && fast.getTotalWeight() >= this.minWeight_;
                  };
                  _proto.getEstimate = function getEstimate() {
                    if (this.canEstimate()) {
                      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
                    } else {
                      return this.defaultEstimate_;
                    }
                  };
                  _proto.destroy = function destroy() {
                  };
                  return EwmaBandWidthEstimator2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = EwmaBandWidthEstimator;
              }
            ),
            /***/
            "./src/utils/ewma.ts": (
              /*!***************************!*\
                !*** ./src/utils/ewma.ts ***!
                \***************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var EWMA = function() {
                  function EWMA2(halfLife, estimate, weight) {
                    if (estimate === void 0) {
                      estimate = 0;
                    }
                    if (weight === void 0) {
                      weight = 0;
                    }
                    this.halfLife = void 0;
                    this.alpha_ = void 0;
                    this.estimate_ = void 0;
                    this.totalWeight_ = void 0;
                    this.halfLife = halfLife;
                    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
                    this.estimate_ = estimate;
                    this.totalWeight_ = weight;
                  }
                  var _proto = EWMA2.prototype;
                  _proto.sample = function sample(weight, value) {
                    var adjAlpha = Math.pow(this.alpha_, weight);
                    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
                    this.totalWeight_ += weight;
                  };
                  _proto.getTotalWeight = function getTotalWeight() {
                    return this.totalWeight_;
                  };
                  _proto.getEstimate = function getEstimate() {
                    if (this.alpha_) {
                      var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
                      if (zeroFactor) {
                        return this.estimate_ / zeroFactor;
                      }
                    }
                    return this.estimate_;
                  };
                  return EWMA2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = EWMA;
              }
            ),
            /***/
            "./src/utils/fetch-loader.ts": (
              /*!***********************************!*\
                !*** ./src/utils/fetch-loader.ts ***!
                \***********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__,
                  /* harmony export */
                  "fetchSupported": () => (
                    /* binding */
                    fetchSupported
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../loader/load-stats */
                  "./src/loader/load-stats.ts"
                );
                var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../demux/chunk-cache */
                  "./src/demux/chunk-cache.ts"
                );
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
                  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                    if (Class2 === null || !_isNativeFunction(Class2))
                      return Class2;
                    if (typeof Class2 !== "function") {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    if (typeof _cache !== "undefined") {
                      if (_cache.has(Class2))
                        return _cache.get(Class2);
                      _cache.set(Class2, Wrapper);
                    }
                    function Wrapper() {
                      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                    return _setPrototypeOf(Wrapper, Class2);
                  };
                  return _wrapNativeSuper(Class);
                }
                function _construct(Parent, args, Class) {
                  if (_isNativeReflectConstruct()) {
                    _construct = Reflect.construct.bind();
                  } else {
                    _construct = function _construct2(Parent2, args2, Class2) {
                      var a = [null];
                      a.push.apply(a, args2);
                      var Constructor = Function.bind.apply(Parent2, a);
                      var instance = new Constructor();
                      if (Class2)
                        _setPrototypeOf(instance, Class2.prototype);
                      return instance;
                    };
                  }
                  return _construct.apply(null, arguments);
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                function _isNativeFunction(fn) {
                  return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                function fetchSupported() {
                  if (
                    // @ts-ignore
                    self.fetch && self.AbortController && self.ReadableStream && self.Request
                  ) {
                    try {
                      new self.ReadableStream({});
                      return true;
                    } catch (e) {
                    }
                  }
                  return false;
                }
                var FetchLoader = function() {
                  function FetchLoader2(config) {
                    this.fetchSetup = void 0;
                    this.requestTimeout = void 0;
                    this.request = void 0;
                    this.response = void 0;
                    this.controller = void 0;
                    this.context = void 0;
                    this.config = null;
                    this.callbacks = null;
                    this.stats = void 0;
                    this.loader = null;
                    this.fetchSetup = config.fetchSetup || getRequest;
                    this.controller = new self.AbortController();
                    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__.LoadStats();
                  }
                  var _proto = FetchLoader2.prototype;
                  _proto.destroy = function destroy() {
                    this.loader = this.callbacks = null;
                    this.abortInternal();
                  };
                  _proto.abortInternal = function abortInternal() {
                    var response = this.response;
                    if (!response || !response.ok) {
                      this.stats.aborted = true;
                      this.controller.abort();
                    }
                  };
                  _proto.abort = function abort() {
                    var _this$callbacks;
                    this.abortInternal();
                    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {
                      this.callbacks.onAbort(this.stats, this.context, this.response);
                    }
                  };
                  _proto.load = function load(context, config, callbacks) {
                    var _this = this;
                    var stats = this.stats;
                    if (stats.loading.start) {
                      throw new Error("Loader can only be used once.");
                    }
                    stats.loading.start = self.performance.now();
                    var initParams = getRequestParameters(context, this.controller.signal);
                    var onProgress = callbacks.onProgress;
                    var isArrayBuffer = context.responseType === "arraybuffer";
                    var LENGTH = isArrayBuffer ? "byteLength" : "length";
                    this.context = context;
                    this.config = config;
                    this.callbacks = callbacks;
                    this.request = this.fetchSetup(context, initParams);
                    self.clearTimeout(this.requestTimeout);
                    this.requestTimeout = self.setTimeout(function() {
                      _this.abortInternal();
                      callbacks.onTimeout(stats, context, _this.response);
                    }, config.timeout);
                    self.fetch(this.request).then(function(response) {
                      _this.response = _this.loader = response;
                      if (!response.ok) {
                        var status = response.status, statusText = response.statusText;
                        throw new FetchError(statusText || "fetch, bad network response", status, response);
                      }
                      stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
                      stats.total = parseInt(response.headers.get("Content-Length") || "0");
                      if (onProgress && (0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(config.highWaterMark)) {
                        return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
                      }
                      if (isArrayBuffer) {
                        return response.arrayBuffer();
                      }
                      return response.text();
                    }).then(function(responseData) {
                      var response = _this.response;
                      self.clearTimeout(_this.requestTimeout);
                      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
                      var total = responseData[LENGTH];
                      if (total) {
                        stats.loaded = stats.total = total;
                      }
                      var loaderResponse = {
                        url: response.url,
                        data: responseData
                      };
                      if (onProgress && !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(config.highWaterMark)) {
                        onProgress(stats, context, responseData, response);
                      }
                      callbacks.onSuccess(loaderResponse, stats, context, response);
                    }).catch(function(error) {
                      self.clearTimeout(_this.requestTimeout);
                      if (stats.aborted) {
                        return;
                      }
                      var code = !error ? 0 : error.code || 0;
                      var text = !error ? null : error.message;
                      callbacks.onError({
                        code,
                        text
                      }, context, error ? error.details : null);
                    });
                  };
                  _proto.getCacheAge = function getCacheAge() {
                    var result = null;
                    if (this.response) {
                      var ageHeader = this.response.headers.get("age");
                      result = ageHeader ? parseFloat(ageHeader) : null;
                    }
                    return result;
                  };
                  _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {
                    if (highWaterMark === void 0) {
                      highWaterMark = 0;
                    }
                    var chunkCache = new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__["default"]();
                    var reader = response.body.getReader();
                    var pump = function pump2() {
                      return reader.read().then(function(data) {
                        if (data.done) {
                          if (chunkCache.dataLength) {
                            onProgress(stats, context, chunkCache.flush(), response);
                          }
                          return Promise.resolve(new ArrayBuffer(0));
                        }
                        var chunk = data.value;
                        var len = chunk.length;
                        stats.loaded += len;
                        if (len < highWaterMark || chunkCache.dataLength) {
                          chunkCache.push(chunk);
                          if (chunkCache.dataLength >= highWaterMark) {
                            onProgress(stats, context, chunkCache.flush(), response);
                          }
                        } else {
                          onProgress(stats, context, chunk, response);
                        }
                        return pump2();
                      }).catch(function() {
                        return Promise.reject();
                      });
                    };
                    return pump();
                  };
                  return FetchLoader2;
                }();
                function getRequestParameters(context, signal) {
                  var initParams = {
                    method: "GET",
                    mode: "cors",
                    credentials: "same-origin",
                    signal,
                    headers: new self.Headers(_extends({}, context.headers))
                  };
                  if (context.rangeEnd) {
                    initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
                  }
                  return initParams;
                }
                function getRequest(context, initParams) {
                  return new self.Request(context.url, initParams);
                }
                var FetchError = function(_Error) {
                  _inheritsLoose(FetchError2, _Error);
                  function FetchError2(message, code, details) {
                    var _this2;
                    _this2 = _Error.call(this, message) || this;
                    _this2.code = void 0;
                    _this2.details = void 0;
                    _this2.code = code;
                    _this2.details = details;
                    return _this2;
                  }
                  return FetchError2;
                }(_wrapNativeSuper(Error));
                const __WEBPACK_DEFAULT_EXPORT__ = FetchLoader;
              }
            ),
            /***/
            "./src/utils/hex.ts": (
              /*!**************************!*\
                !*** ./src/utils/hex.ts ***!
                \**************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var Hex = {
                  hexDump: function hexDump(array) {
                    var str = "";
                    for (var i = 0; i < array.length; i++) {
                      var h = array[i].toString(16);
                      if (h.length < 2) {
                        h = "0" + h;
                      }
                      str += h;
                    }
                    return str;
                  }
                };
                const __WEBPACK_DEFAULT_EXPORT__ = Hex;
              }
            ),
            /***/
            "./src/utils/imsc1-ttml-parser.ts": (
              /*!****************************************!*\
                !*** ./src/utils/imsc1-ttml-parser.ts ***!
                \****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "IMSC1_CODEC": () => (
                    /* binding */
                    IMSC1_CODEC
                  ),
                  /* harmony export */
                  "parseIMSC1": () => (
                    /* binding */
                    parseIMSC1
                  )
                  /* harmony export */
                });
                var _mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./mp4-tools */
                  "./src/utils/mp4-tools.ts"
                );
                var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./vttparser */
                  "./src/utils/vttparser.ts"
                );
                var _vttcue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./vttcue */
                  "./src/utils/vttcue.ts"
                );
                var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../demux/id3 */
                  "./src/demux/id3.ts"
                );
                var _timescale_conversion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./timescale-conversion */
                  "./src/utils/timescale-conversion.ts"
                );
                var _webvtt_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./webvtt-parser */
                  "./src/utils/webvtt-parser.ts"
                );
                function _extends() {
                  _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  };
                  return _extends.apply(this, arguments);
                }
                var IMSC1_CODEC = "stpp.ttml.im1t";
                var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
                var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
                var textAlignToLineAlign = {
                  left: "start",
                  center: "center",
                  right: "end",
                  start: "start",
                  end: "end"
                };
                function parseIMSC1(payload, initPTS, timescale, callBack, errorCallBack) {
                  var results = (0, _mp4_tools__WEBPACK_IMPORTED_MODULE_0__.findBox)(new Uint8Array(payload), ["mdat"]);
                  if (results.length === 0) {
                    errorCallBack(new Error("Could not parse IMSC1 mdat"));
                    return;
                  }
                  var ttmlList = results.map(function(mdat) {
                    return (0, _demux_id3__WEBPACK_IMPORTED_MODULE_3__.utf8ArrayToStr)(mdat);
                  });
                  var syncTime = (0, _timescale_conversion__WEBPACK_IMPORTED_MODULE_4__.toTimescaleFromScale)(initPTS, 1, timescale);
                  try {
                    ttmlList.forEach(function(ttml) {
                      return callBack(parseTTML(ttml, syncTime));
                    });
                  } catch (error) {
                    errorCallBack(error);
                  }
                }
                function parseTTML(ttml, syncTime) {
                  var parser = new DOMParser();
                  var xmlDoc = parser.parseFromString(ttml, "text/xml");
                  var tt = xmlDoc.getElementsByTagName("tt")[0];
                  if (!tt) {
                    throw new Error("Invalid ttml");
                  }
                  var defaultRateInfo = {
                    frameRate: 30,
                    subFrameRate: 1,
                    frameRateMultiplier: 0,
                    tickRate: 0
                  };
                  var rateInfo = Object.keys(defaultRateInfo).reduce(function(result, key) {
                    result[key] = tt.getAttribute("ttp:" + key) || defaultRateInfo[key];
                    return result;
                  }, {});
                  var trim = tt.getAttribute("xml:space") !== "preserve";
                  var styleElements = collectionToDictionary(getElementCollection(tt, "styling", "style"));
                  var regionElements = collectionToDictionary(getElementCollection(tt, "layout", "region"));
                  var cueElements = getElementCollection(tt, "body", "[begin]");
                  return [].map.call(cueElements, function(cueElement) {
                    var cueText = getTextContent(cueElement, trim);
                    if (!cueText || !cueElement.hasAttribute("begin")) {
                      return null;
                    }
                    var startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
                    var duration = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
                    var endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
                    if (startTime === null) {
                      throw timestampParsingError(cueElement);
                    }
                    if (endTime === null) {
                      if (duration === null) {
                        throw timestampParsingError(cueElement);
                      }
                      endTime = startTime + duration;
                    }
                    var cue = new _vttcue__WEBPACK_IMPORTED_MODULE_2__["default"](startTime - syncTime, endTime - syncTime, cueText);
                    cue.id = (0, _webvtt_parser__WEBPACK_IMPORTED_MODULE_5__.generateCueId)(cue.startTime, cue.endTime, cue.text);
                    var region = regionElements[cueElement.getAttribute("region")];
                    var style = styleElements[cueElement.getAttribute("style")];
                    var styles = getTtmlStyles(region, style, styleElements);
                    var textAlign = styles.textAlign;
                    if (textAlign) {
                      var lineAlign = textAlignToLineAlign[textAlign];
                      if (lineAlign) {
                        cue.lineAlign = lineAlign;
                      }
                      cue.align = textAlign;
                    }
                    _extends(cue, styles);
                    return cue;
                  }).filter(function(cue) {
                    return cue !== null;
                  });
                }
                function getElementCollection(fromElement, parentName, childName) {
                  var parent = fromElement.getElementsByTagName(parentName)[0];
                  if (parent) {
                    return [].slice.call(parent.querySelectorAll(childName));
                  }
                  return [];
                }
                function collectionToDictionary(elementsWithId) {
                  return elementsWithId.reduce(function(dict, element) {
                    var id = element.getAttribute("xml:id");
                    if (id) {
                      dict[id] = element;
                    }
                    return dict;
                  }, {});
                }
                function getTextContent(element, trim) {
                  return [].slice.call(element.childNodes).reduce(function(str, node, i) {
                    var _node$childNodes;
                    if (node.nodeName === "br" && i) {
                      return str + "\n";
                    }
                    if ((_node$childNodes = node.childNodes) !== null && _node$childNodes !== void 0 && _node$childNodes.length) {
                      return getTextContent(node, trim);
                    } else if (trim) {
                      return str + node.textContent.trim().replace(/\s+/g, " ");
                    }
                    return str + node.textContent;
                  }, "");
                }
                function getTtmlStyles(region, style, styleElements) {
                  var ttsNs = "http://www.w3.org/ns/ttml#styling";
                  var regionStyle = null;
                  var styleAttributes = [
                    "displayAlign",
                    "textAlign",
                    "color",
                    "backgroundColor",
                    "fontSize",
                    "fontFamily"
                    // 'fontWeight',
                    // 'lineHeight',
                    // 'wrapOption',
                    // 'fontStyle',
                    // 'direction',
                    // 'writingMode'
                  ];
                  var regionStyleName = region !== null && region !== void 0 && region.hasAttribute("style") ? region.getAttribute("style") : null;
                  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
                    regionStyle = styleElements[regionStyleName];
                  }
                  return styleAttributes.reduce(function(styles, name) {
                    var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
                    if (value) {
                      styles[name] = value;
                    }
                    return styles;
                  }, {});
                }
                function getAttributeNS(element, ns, name) {
                  if (!element) {
                    return null;
                  }
                  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
                }
                function timestampParsingError(node) {
                  return new Error("Could not parse ttml timestamp " + node);
                }
                function parseTtmlTime(timeAttributeValue, rateInfo) {
                  if (!timeAttributeValue) {
                    return null;
                  }
                  var seconds = (0, _vttparser__WEBPACK_IMPORTED_MODULE_1__.parseTimeStamp)(timeAttributeValue);
                  if (seconds === null) {
                    if (HMSF_REGEX.test(timeAttributeValue)) {
                      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
                    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
                      seconds = parseTimeUnits(timeAttributeValue, rateInfo);
                    }
                  }
                  return seconds;
                }
                function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
                  var m = HMSF_REGEX.exec(timeAttributeValue);
                  var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
                  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
                }
                function parseTimeUnits(timeAttributeValue, rateInfo) {
                  var m = TIME_UNIT_REGEX.exec(timeAttributeValue);
                  var value = Number(m[1]);
                  var unit = m[2];
                  switch (unit) {
                    case "h":
                      return value * 3600;
                    case "m":
                      return value * 60;
                    case "ms":
                      return value * 1e3;
                    case "f":
                      return value / rateInfo.frameRate;
                    case "t":
                      return value / rateInfo.tickRate;
                  }
                  return value;
                }
              }
            ),
            /***/
            "./src/utils/keysystem-util.ts": (
              /*!*************************************!*\
                !*** ./src/utils/keysystem-util.ts ***!
                \*************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "changeEndianness": () => (
                    /* binding */
                    changeEndianness
                  ),
                  /* harmony export */
                  "convertDataUriToArrayBytes": () => (
                    /* binding */
                    convertDataUriToArrayBytes
                  ),
                  /* harmony export */
                  "strToUtf8array": () => (
                    /* binding */
                    strToUtf8array
                  )
                  /* harmony export */
                });
                var _numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./numeric-encoding-utils */
                  "./src/utils/numeric-encoding-utils.ts"
                );
                function getKeyIdBytes(str) {
                  var keyIdbytes = strToUtf8array(str).subarray(0, 16);
                  var paddedkeyIdbytes = new Uint8Array(16);
                  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
                  return paddedkeyIdbytes;
                }
                function changeEndianness(keyId) {
                  var swap = function swap2(array, from, to) {
                    var cur = array[from];
                    array[from] = array[to];
                    array[to] = cur;
                  };
                  swap(keyId, 0, 3);
                  swap(keyId, 1, 2);
                  swap(keyId, 4, 5);
                  swap(keyId, 6, 7);
                }
                function convertDataUriToArrayBytes(uri) {
                  var colonsplit = uri.split(":");
                  var keydata = null;
                  if (colonsplit[0] === "data" && colonsplit.length === 2) {
                    var semicolonsplit = colonsplit[1].split(";");
                    var commasplit = semicolonsplit[semicolonsplit.length - 1].split(",");
                    if (commasplit.length === 2) {
                      var isbase64 = commasplit[0] === "base64";
                      var data = commasplit[1];
                      if (isbase64) {
                        semicolonsplit.splice(-1, 1);
                        keydata = (0, _numeric_encoding_utils__WEBPACK_IMPORTED_MODULE_0__.base64Decode)(data);
                      } else {
                        keydata = getKeyIdBytes(data);
                      }
                    }
                  }
                  return keydata;
                }
                function strToUtf8array(str) {
                  return Uint8Array.from(unescape(encodeURIComponent(str)), function(c) {
                    return c.charCodeAt(0);
                  });
                }
              }
            ),
            /***/
            "./src/utils/logger.ts": (
              /*!*****************************!*\
                !*** ./src/utils/logger.ts ***!
                \*****************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "enableLogs": () => (
                    /* binding */
                    enableLogs
                  ),
                  /* harmony export */
                  "logger": () => (
                    /* binding */
                    logger
                  )
                  /* harmony export */
                });
                var noop = function noop2() {
                };
                var fakeLogger = {
                  trace: noop,
                  debug: noop,
                  log: noop,
                  warn: noop,
                  info: noop,
                  error: noop
                };
                var exportedLogger = fakeLogger;
                function consolePrintFn(type) {
                  var func = self.console[type];
                  if (func) {
                    return func.bind(self.console, "[" + type + "] >");
                  }
                  return noop;
                }
                function exportLoggerFunctions(debugConfig) {
                  for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    functions[_key - 1] = arguments[_key];
                  }
                  functions.forEach(function(type) {
                    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
                  });
                }
                function enableLogs(debugConfig, id) {
                  if (self.console && debugConfig === true || typeof debugConfig === "object") {
                    exportLoggerFunctions(
                      debugConfig,
                      // Remove out from list here to hard-disable a log-level
                      // 'trace',
                      "debug",
                      "log",
                      "info",
                      "warn",
                      "error"
                    );
                    try {
                      exportedLogger.log('Debug logs enabled for "' + id + '"');
                    } catch (e) {
                      exportedLogger = fakeLogger;
                    }
                  } else {
                    exportedLogger = fakeLogger;
                  }
                }
                var logger = exportedLogger;
              }
            ),
            /***/
            "./src/utils/mediakeys-helper.ts": (
              /*!***************************************!*\
                !*** ./src/utils/mediakeys-helper.ts ***!
                \***************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "KeySystemFormats": () => (
                    /* binding */
                    KeySystemFormats
                  ),
                  /* harmony export */
                  "KeySystemIds": () => (
                    /* binding */
                    KeySystemIds
                  ),
                  /* harmony export */
                  "KeySystems": () => (
                    /* binding */
                    KeySystems
                  ),
                  /* harmony export */
                  "getKeySystemsForConfig": () => (
                    /* binding */
                    getKeySystemsForConfig
                  ),
                  /* harmony export */
                  "getSupportedMediaKeySystemConfigurations": () => (
                    /* binding */
                    getSupportedMediaKeySystemConfigurations
                  ),
                  /* harmony export */
                  "keySystemDomainToKeySystemFormat": () => (
                    /* binding */
                    keySystemDomainToKeySystemFormat
                  ),
                  /* harmony export */
                  "keySystemFormatToKeySystemDomain": () => (
                    /* binding */
                    keySystemFormatToKeySystemDomain
                  ),
                  /* harmony export */
                  "keySystemIdToKeySystemDomain": () => (
                    /* binding */
                    keySystemIdToKeySystemDomain
                  ),
                  /* harmony export */
                  "requestMediaKeySystemAccess": () => (
                    /* binding */
                    requestMediaKeySystemAccess
                  )
                  /* harmony export */
                });
                var KeySystems;
                (function(KeySystems2) {
                  KeySystems2["CLEARKEY"] = "org.w3.clearkey";
                  KeySystems2["FAIRPLAY"] = "com.apple.fps";
                  KeySystems2["PLAYREADY"] = "com.microsoft.playready";
                  KeySystems2["WIDEVINE"] = "com.widevine.alpha";
                })(KeySystems || (KeySystems = {}));
                var KeySystemFormats;
                (function(KeySystemFormats2) {
                  KeySystemFormats2["CLEARKEY"] = "org.w3.clearkey";
                  KeySystemFormats2["FAIRPLAY"] = "com.apple.streamingkeydelivery";
                  KeySystemFormats2["PLAYREADY"] = "com.microsoft.playready";
                  KeySystemFormats2["WIDEVINE"] = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
                })(KeySystemFormats || (KeySystemFormats = {}));
                function keySystemFormatToKeySystemDomain(format) {
                  switch (format) {
                    case KeySystemFormats.FAIRPLAY:
                      return KeySystems.FAIRPLAY;
                    case KeySystemFormats.PLAYREADY:
                      return KeySystems.PLAYREADY;
                    case KeySystemFormats.WIDEVINE:
                      return KeySystems.WIDEVINE;
                    case KeySystemFormats.CLEARKEY:
                      return KeySystems.CLEARKEY;
                  }
                }
                var KeySystemIds;
                (function(KeySystemIds2) {
                  KeySystemIds2["WIDEVINE"] = "edef8ba979d64acea3c827dcd51d21ed";
                })(KeySystemIds || (KeySystemIds = {}));
                function keySystemIdToKeySystemDomain(systemId) {
                  if (systemId === KeySystemIds.WIDEVINE) {
                    return KeySystems.WIDEVINE;
                  }
                }
                function keySystemDomainToKeySystemFormat(keySystem) {
                  switch (keySystem) {
                    case KeySystems.FAIRPLAY:
                      return KeySystemFormats.FAIRPLAY;
                    case KeySystems.PLAYREADY:
                      return KeySystemFormats.PLAYREADY;
                    case KeySystems.WIDEVINE:
                      return KeySystemFormats.WIDEVINE;
                    case KeySystems.CLEARKEY:
                      return KeySystemFormats.CLEARKEY;
                  }
                }
                function getKeySystemsForConfig(config) {
                  var drmSystems = config.drmSystems, widevineLicenseUrl = config.widevineLicenseUrl;
                  var keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(function(keySystem) {
                    return !!drmSystems[keySystem];
                  }) : [];
                  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
                    keySystemsToAttempt.push(KeySystems.WIDEVINE);
                  }
                  return keySystemsToAttempt;
                }
                var requestMediaKeySystemAccess = function() {
                  if (typeof self !== "undefined" && self.navigator && self.navigator.requestMediaKeySystemAccess) {
                    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
                  } else {
                    return null;
                  }
                }();
                function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
                  var initDataTypes;
                  switch (keySystem) {
                    case KeySystems.FAIRPLAY:
                      initDataTypes = ["cenc", "sinf"];
                      break;
                    case KeySystems.WIDEVINE:
                    case KeySystems.PLAYREADY:
                      initDataTypes = ["cenc"];
                      break;
                    case KeySystems.CLEARKEY:
                      initDataTypes = ["cenc", "keyids"];
                      break;
                    default:
                      throw new Error("Unknown key-system: " + keySystem);
                  }
                  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
                }
                function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
                  var baseConfig = {
                    initDataTypes,
                    persistentState: drmSystemOptions.persistentState || "not-allowed",
                    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || "not-allowed",
                    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || "temporary"],
                    audioCapabilities: audioCodecs.map(function(codec) {
                      return {
                        contentType: 'audio/mp4; codecs="' + codec + '"',
                        robustness: drmSystemOptions.audioRobustness || "",
                        encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
                      };
                    }),
                    videoCapabilities: videoCodecs.map(function(codec) {
                      return {
                        contentType: 'video/mp4; codecs="' + codec + '"',
                        robustness: drmSystemOptions.videoRobustness || "",
                        encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
                      };
                    })
                  };
                  return [baseConfig];
                }
              }
            ),
            /***/
            "./src/utils/mediasource-helper.ts": (
              /*!*****************************************!*\
                !*** ./src/utils/mediasource-helper.ts ***!
                \*****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "getMediaSource": () => (
                    /* binding */
                    getMediaSource
                  )
                  /* harmony export */
                });
                function getMediaSource() {
                  return self.MediaSource || self.WebKitMediaSource;
                }
              }
            ),
            /***/
            "./src/utils/mp4-tools.ts": (
              /*!********************************!*\
                !*** ./src/utils/mp4-tools.ts ***!
                \********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "RemuxerTrackIdConfig": () => (
                    /* binding */
                    RemuxerTrackIdConfig
                  ),
                  /* harmony export */
                  "appendUint8Array": () => (
                    /* binding */
                    appendUint8Array
                  ),
                  /* harmony export */
                  "bin2str": () => (
                    /* binding */
                    bin2str
                  ),
                  /* harmony export */
                  "computeRawDurationFromSamples": () => (
                    /* binding */
                    computeRawDurationFromSamples
                  ),
                  /* harmony export */
                  "discardEPB": () => (
                    /* binding */
                    discardEPB
                  ),
                  /* harmony export */
                  "findBox": () => (
                    /* binding */
                    findBox
                  ),
                  /* harmony export */
                  "getDuration": () => (
                    /* binding */
                    getDuration
                  ),
                  /* harmony export */
                  "getStartDTS": () => (
                    /* binding */
                    getStartDTS
                  ),
                  /* harmony export */
                  "mp4Box": () => (
                    /* binding */
                    mp4Box
                  ),
                  /* harmony export */
                  "mp4pssh": () => (
                    /* binding */
                    mp4pssh
                  ),
                  /* harmony export */
                  "offsetStartDTS": () => (
                    /* binding */
                    offsetStartDTS
                  ),
                  /* harmony export */
                  "parseEmsg": () => (
                    /* binding */
                    parseEmsg
                  ),
                  /* harmony export */
                  "parseInitSegment": () => (
                    /* binding */
                    parseInitSegment
                  ),
                  /* harmony export */
                  "parsePssh": () => (
                    /* binding */
                    parsePssh
                  ),
                  /* harmony export */
                  "parseSEIMessageFromNALu": () => (
                    /* binding */
                    parseSEIMessageFromNALu
                  ),
                  /* harmony export */
                  "parseSamples": () => (
                    /* binding */
                    parseSamples
                  ),
                  /* harmony export */
                  "parseSegmentIndex": () => (
                    /* binding */
                    parseSegmentIndex
                  ),
                  /* harmony export */
                  "parseSinf": () => (
                    /* binding */
                    parseSinf
                  ),
                  /* harmony export */
                  "patchEncyptionData": () => (
                    /* binding */
                    patchEncyptionData
                  ),
                  /* harmony export */
                  "readSint32": () => (
                    /* binding */
                    readSint32
                  ),
                  /* harmony export */
                  "readUint16": () => (
                    /* binding */
                    readUint16
                  ),
                  /* harmony export */
                  "readUint32": () => (
                    /* binding */
                    readUint32
                  ),
                  /* harmony export */
                  "segmentValidRange": () => (
                    /* binding */
                    segmentValidRange
                  ),
                  /* harmony export */
                  "writeUint32": () => (
                    /* binding */
                    writeUint32
                  )
                  /* harmony export */
                });
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../loader/fragment */
                  "./src/loader/fragment.ts"
                );
                var _typed_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./typed-array */
                  "./src/utils/typed-array.ts"
                );
                var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../demux/id3 */
                  "./src/demux/id3.ts"
                );
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _hex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./hex */
                  "./src/utils/hex.ts"
                );
                var UINT32_MAX = Math.pow(2, 32) - 1;
                var push = [].push;
                var RemuxerTrackIdConfig = {
                  video: 1,
                  audio: 2,
                  id3: 3,
                  text: 4
                };
                function bin2str(data) {
                  return String.fromCharCode.apply(null, data);
                }
                function readUint16(buffer, offset) {
                  var val = buffer[offset] << 8 | buffer[offset + 1];
                  return val < 0 ? 65536 + val : val;
                }
                function readUint32(buffer, offset) {
                  var val = readSint32(buffer, offset);
                  return val < 0 ? 4294967296 + val : val;
                }
                function readSint32(buffer, offset) {
                  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
                }
                function writeUint32(buffer, offset, value) {
                  buffer[offset] = value >> 24;
                  buffer[offset + 1] = value >> 16 & 255;
                  buffer[offset + 2] = value >> 8 & 255;
                  buffer[offset + 3] = value & 255;
                }
                function findBox(data, path) {
                  var results = [];
                  if (!path.length) {
                    return results;
                  }
                  var end = data.byteLength;
                  for (var i = 0; i < end; ) {
                    var size = readUint32(data, i);
                    var type = bin2str(data.subarray(i + 4, i + 8));
                    var endbox = size > 1 ? i + size : end;
                    if (type === path[0]) {
                      if (path.length === 1) {
                        results.push(data.subarray(i + 8, endbox));
                      } else {
                        var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
                        if (subresults.length) {
                          push.apply(results, subresults);
                        }
                      }
                    }
                    i = endbox;
                  }
                  return results;
                }
                function parseSegmentIndex(sidx) {
                  var references = [];
                  var version = sidx[0];
                  var index = 8;
                  var timescale = readUint32(sidx, index);
                  index += 4;
                  var earliestPresentationTime = 0;
                  var firstOffset = 0;
                  if (version === 0) {
                    index += 8;
                  } else {
                    index += 16;
                  }
                  index += 2;
                  var startByte = sidx.length + firstOffset;
                  var referencesCount = readUint16(sidx, index);
                  index += 2;
                  for (var i = 0; i < referencesCount; i++) {
                    var referenceIndex = index;
                    var referenceInfo = readUint32(sidx, referenceIndex);
                    referenceIndex += 4;
                    var referenceSize = referenceInfo & 2147483647;
                    var referenceType = (referenceInfo & 2147483648) >>> 31;
                    if (referenceType === 1) {
                      console.warn("SIDX has hierarchical references (not supported)");
                      return null;
                    }
                    var subsegmentDuration = readUint32(sidx, referenceIndex);
                    referenceIndex += 4;
                    references.push({
                      referenceSize,
                      subsegmentDuration,
                      // unscaled
                      info: {
                        duration: subsegmentDuration / timescale,
                        start: startByte,
                        end: startByte + referenceSize - 1
                      }
                    });
                    startByte += referenceSize;
                    referenceIndex += 4;
                    index = referenceIndex;
                  }
                  return {
                    earliestPresentationTime,
                    timescale,
                    version,
                    referencesCount,
                    references
                  };
                }
                function parseInitSegment(initSegment) {
                  var result = [];
                  var traks = findBox(initSegment, ["moov", "trak"]);
                  for (var i = 0; i < traks.length; i++) {
                    var trak = traks[i];
                    var tkhd = findBox(trak, ["tkhd"])[0];
                    if (tkhd) {
                      var version = tkhd[0];
                      var _index = version === 0 ? 12 : 20;
                      var trackId = readUint32(tkhd, _index);
                      var mdhd = findBox(trak, ["mdia", "mdhd"])[0];
                      if (mdhd) {
                        version = mdhd[0];
                        _index = version === 0 ? 12 : 20;
                        var timescale = readUint32(mdhd, _index);
                        var hdlr = findBox(trak, ["mdia", "hdlr"])[0];
                        if (hdlr) {
                          var hdlrType = bin2str(hdlr.subarray(8, 12));
                          var type = {
                            soun: _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.AUDIO,
                            vide: _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.VIDEO
                          }[hdlrType];
                          if (type) {
                            var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
                            var codec = void 0;
                            if (stsd) {
                              codec = bin2str(stsd.subarray(12, 16));
                            }
                            result[trackId] = {
                              timescale,
                              type
                            };
                            result[type] = {
                              timescale,
                              id: trackId,
                              codec
                            };
                          }
                        }
                      }
                    }
                  }
                  var trex = findBox(initSegment, ["moov", "mvex", "trex"]);
                  trex.forEach(function(trex2) {
                    var trackId2 = readUint32(trex2, 4);
                    var track = result[trackId2];
                    if (track) {
                      track.default = {
                        duration: readUint32(trex2, 12),
                        flags: readUint32(trex2, 20)
                      };
                    }
                  });
                  return result;
                }
                function patchEncyptionData(initSegment, decryptdata) {
                  if (!initSegment || !decryptdata) {
                    return initSegment;
                  }
                  var keyId = decryptdata.keyId;
                  if (keyId && decryptdata.isCommonEncryption) {
                    var traks = findBox(initSegment, ["moov", "trak"]);
                    traks.forEach(function(trak) {
                      var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
                      var sampleEntries = stsd.subarray(8);
                      var encBoxes = findBox(sampleEntries, ["enca"]);
                      var isAudio = encBoxes.length > 0;
                      if (!isAudio) {
                        encBoxes = findBox(sampleEntries, ["encv"]);
                      }
                      encBoxes.forEach(function(enc) {
                        var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
                        var sinfBoxes = findBox(encBoxChildren, ["sinf"]);
                        sinfBoxes.forEach(function(sinf) {
                          var tenc = parseSinf(sinf);
                          if (tenc) {
                            var tencKeyId = tenc.subarray(8, 24);
                            if (!tencKeyId.some(function(b) {
                              return b !== 0;
                            })) {
                              _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.log("[eme] Patching keyId in 'enc" + (isAudio ? "a" : "v") + ">sinf>>tenc' box: " + _hex__WEBPACK_IMPORTED_MODULE_4__["default"].hexDump(tencKeyId) + " -> " + _hex__WEBPACK_IMPORTED_MODULE_4__["default"].hexDump(keyId));
                              tenc.set(keyId, 8);
                            }
                          }
                        });
                      });
                    });
                  }
                  return initSegment;
                }
                function parseSinf(sinf) {
                  var schm = findBox(sinf, ["schm"])[0];
                  if (schm) {
                    var scheme = bin2str(schm.subarray(4, 8));
                    if (scheme === "cbcs" || scheme === "cenc") {
                      return findBox(sinf, ["schi", "tenc"])[0];
                    }
                  }
                  _utils_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error("[eme] missing 'schm' box");
                  return null;
                }
                function getStartDTS(initData, fmp4) {
                  return findBox(fmp4, ["moof", "traf"]).reduce(function(result, traf) {
                    var tfdt = findBox(traf, ["tfdt"])[0];
                    var version = tfdt[0];
                    var start = findBox(traf, ["tfhd"]).reduce(function(result2, tfhd) {
                      var id = readUint32(tfhd, 4);
                      var track = initData[id];
                      if (track) {
                        var baseTime = readUint32(tfdt, 4);
                        if (version === 1) {
                          baseTime *= Math.pow(2, 32);
                          baseTime += readUint32(tfdt, 8);
                        }
                        var scale = track.timescale || 9e4;
                        var startTime = baseTime / scale;
                        if (isFinite(startTime) && (result2 === null || startTime < result2)) {
                          return startTime;
                        }
                      }
                      return result2;
                    }, null);
                    if (start !== null && isFinite(start) && (result === null || start < result)) {
                      return start;
                    }
                    return result;
                  }, null) || 0;
                }
                function getDuration(data, initData) {
                  var rawDuration = 0;
                  var videoDuration = 0;
                  var audioDuration = 0;
                  var trafs = findBox(data, ["moof", "traf"]);
                  for (var i = 0; i < trafs.length; i++) {
                    var traf = trafs[i];
                    var tfhd = findBox(traf, ["tfhd"])[0];
                    var id = readUint32(tfhd, 4);
                    var track = initData[id];
                    if (!track) {
                      continue;
                    }
                    var trackDefault = track.default;
                    var tfhdFlags = readUint32(tfhd, 0) | (trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.flags);
                    var sampleDuration = trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.duration;
                    if (tfhdFlags & 8) {
                      if (tfhdFlags & 2) {
                        sampleDuration = readUint32(tfhd, 12);
                      } else {
                        sampleDuration = readUint32(tfhd, 8);
                      }
                    }
                    var timescale = track.timescale || 9e4;
                    var truns = findBox(traf, ["trun"]);
                    for (var j = 0; j < truns.length; j++) {
                      rawDuration = computeRawDurationFromSamples(truns[j]);
                      if (!rawDuration && sampleDuration) {
                        var sampleCount = readUint32(truns[j], 4);
                        rawDuration = sampleDuration * sampleCount;
                      }
                      if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.VIDEO) {
                        videoDuration += rawDuration / timescale;
                      } else if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.AUDIO) {
                        audioDuration += rawDuration / timescale;
                      }
                    }
                  }
                  if (videoDuration === 0 && audioDuration === 0) {
                    var sidxDuration = 0;
                    var sidxs = findBox(data, ["sidx"]);
                    for (var _i = 0; _i < sidxs.length; _i++) {
                      var sidx = parseSegmentIndex(sidxs[_i]);
                      if (sidx !== null && sidx !== void 0 && sidx.references) {
                        sidxDuration += sidx.references.reduce(function(dur, ref) {
                          return dur + ref.info.duration || 0;
                        }, 0);
                      }
                    }
                    return sidxDuration;
                  }
                  if (videoDuration) {
                    return videoDuration;
                  }
                  return audioDuration;
                }
                function computeRawDurationFromSamples(trun) {
                  var flags = readUint32(trun, 0);
                  var offset = 8;
                  if (flags & 1) {
                    offset += 4;
                  }
                  if (flags & 4) {
                    offset += 4;
                  }
                  var duration = 0;
                  var sampleCount = readUint32(trun, 4);
                  for (var i = 0; i < sampleCount; i++) {
                    if (flags & 256) {
                      var sampleDuration = readUint32(trun, offset);
                      duration += sampleDuration;
                      offset += 4;
                    }
                    if (flags & 512) {
                      offset += 4;
                    }
                    if (flags & 1024) {
                      offset += 4;
                    }
                    if (flags & 2048) {
                      offset += 4;
                    }
                  }
                  return duration;
                }
                function offsetStartDTS(initData, fmp4, timeOffset) {
                  findBox(fmp4, ["moof", "traf"]).forEach(function(traf) {
                    findBox(traf, ["tfhd"]).forEach(function(tfhd) {
                      var id = readUint32(tfhd, 4);
                      var track = initData[id];
                      if (!track) {
                        return;
                      }
                      var timescale = track.timescale || 9e4;
                      findBox(traf, ["tfdt"]).forEach(function(tfdt) {
                        var version = tfdt[0];
                        var baseMediaDecodeTime = readUint32(tfdt, 4);
                        if (version === 0) {
                          baseMediaDecodeTime -= timeOffset * timescale;
                          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                          writeUint32(tfdt, 4, baseMediaDecodeTime);
                        } else {
                          baseMediaDecodeTime *= Math.pow(2, 32);
                          baseMediaDecodeTime += readUint32(tfdt, 8);
                          baseMediaDecodeTime -= timeOffset * timescale;
                          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                          var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
                          var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                          writeUint32(tfdt, 4, upper);
                          writeUint32(tfdt, 8, lower);
                        }
                      });
                    });
                  });
                }
                function segmentValidRange(data) {
                  var segmentedRange = {
                    valid: null,
                    remainder: null
                  };
                  var moofs = findBox(data, ["moof"]);
                  if (!moofs) {
                    return segmentedRange;
                  } else if (moofs.length < 2) {
                    segmentedRange.remainder = data;
                    return segmentedRange;
                  }
                  var last = moofs[moofs.length - 1];
                  segmentedRange.valid = (0, _typed_array__WEBPACK_IMPORTED_MODULE_1__.sliceUint8)(data, 0, last.byteOffset - 8);
                  segmentedRange.remainder = (0, _typed_array__WEBPACK_IMPORTED_MODULE_1__.sliceUint8)(data, last.byteOffset - 8);
                  return segmentedRange;
                }
                function appendUint8Array(data1, data2) {
                  var temp = new Uint8Array(data1.length + data2.length);
                  temp.set(data1);
                  temp.set(data2, data1.length);
                  return temp;
                }
                function parseSamples(timeOffset, track) {
                  var seiSamples = [];
                  var videoData = track.samples;
                  var timescale = track.timescale;
                  var trackId = track.id;
                  var isHEVCFlavor = false;
                  var moofs = findBox(videoData, ["moof"]);
                  moofs.map(function(moof) {
                    var moofOffset = moof.byteOffset - 8;
                    var trafs = findBox(moof, ["traf"]);
                    trafs.map(function(traf) {
                      var baseTime = findBox(traf, ["tfdt"]).map(function(tfdt) {
                        var version = tfdt[0];
                        var result = readUint32(tfdt, 4);
                        if (version === 1) {
                          result *= Math.pow(2, 32);
                          result += readUint32(tfdt, 8);
                        }
                        return result / timescale;
                      })[0];
                      if (baseTime !== void 0) {
                        timeOffset = baseTime;
                      }
                      return findBox(traf, ["tfhd"]).map(function(tfhd) {
                        var id = readUint32(tfhd, 4);
                        var tfhdFlags = readUint32(tfhd, 0) & 16777215;
                        var baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
                        var sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
                        var defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
                        var defaultSampleDuration = 0;
                        var defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
                        var defaultSampleSize = 0;
                        var defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
                        var tfhdOffset = 8;
                        if (id === trackId) {
                          if (baseDataOffsetPresent) {
                            tfhdOffset += 8;
                          }
                          if (sampleDescriptionIndexPresent) {
                            tfhdOffset += 4;
                          }
                          if (defaultSampleDurationPresent) {
                            defaultSampleDuration = readUint32(tfhd, tfhdOffset);
                            tfhdOffset += 4;
                          }
                          if (defaultSampleSizePresent) {
                            defaultSampleSize = readUint32(tfhd, tfhdOffset);
                            tfhdOffset += 4;
                          }
                          if (defaultSampleFlagsPresent) {
                            tfhdOffset += 4;
                          }
                          if (track.type === "video") {
                            isHEVCFlavor = isHEVC(track.codec);
                          }
                          findBox(traf, ["trun"]).map(function(trun) {
                            var version = trun[0];
                            var flags = readUint32(trun, 0) & 16777215;
                            var dataOffsetPresent = (flags & 1) !== 0;
                            var dataOffset = 0;
                            var firstSampleFlagsPresent = (flags & 4) !== 0;
                            var sampleDurationPresent = (flags & 256) !== 0;
                            var sampleDuration = 0;
                            var sampleSizePresent = (flags & 512) !== 0;
                            var sampleSize = 0;
                            var sampleFlagsPresent = (flags & 1024) !== 0;
                            var sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
                            var compositionOffset = 0;
                            var sampleCount = readUint32(trun, 4);
                            var trunOffset = 8;
                            if (dataOffsetPresent) {
                              dataOffset = readUint32(trun, trunOffset);
                              trunOffset += 4;
                            }
                            if (firstSampleFlagsPresent) {
                              trunOffset += 4;
                            }
                            var sampleOffset = dataOffset + moofOffset;
                            for (var ix = 0; ix < sampleCount; ix++) {
                              if (sampleDurationPresent) {
                                sampleDuration = readUint32(trun, trunOffset);
                                trunOffset += 4;
                              } else {
                                sampleDuration = defaultSampleDuration;
                              }
                              if (sampleSizePresent) {
                                sampleSize = readUint32(trun, trunOffset);
                                trunOffset += 4;
                              } else {
                                sampleSize = defaultSampleSize;
                              }
                              if (sampleFlagsPresent) {
                                trunOffset += 4;
                              }
                              if (sampleCompositionOffsetsPresent) {
                                if (version === 0) {
                                  compositionOffset = readUint32(trun, trunOffset);
                                } else {
                                  compositionOffset = readSint32(trun, trunOffset);
                                }
                                trunOffset += 4;
                              }
                              if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_0__.ElementaryStreamTypes.VIDEO) {
                                var naluTotalSize = 0;
                                while (naluTotalSize < sampleSize) {
                                  var naluSize = readUint32(videoData, sampleOffset);
                                  sampleOffset += 4;
                                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                                    var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                                  }
                                  sampleOffset += naluSize;
                                  naluTotalSize += naluSize + 4;
                                }
                              }
                              timeOffset += sampleDuration / timescale;
                            }
                          });
                        }
                      });
                    });
                  });
                  return seiSamples;
                }
                function isHEVC(codec) {
                  if (!codec) {
                    return false;
                  }
                  var delimit = codec.indexOf(".");
                  var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
                  return baseCodec === "hvc1" || baseCodec === "hev1" || // Dolby Vision
                  baseCodec === "dvh1" || baseCodec === "dvhe";
                }
                function isSEIMessage(isHEVCFlavor, naluHeader) {
                  if (isHEVCFlavor) {
                    var naluType = naluHeader >> 1 & 63;
                    return naluType === 39 || naluType === 40;
                  } else {
                    var _naluType = naluHeader & 31;
                    return _naluType === 6;
                  }
                }
                function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
                  var data = discardEPB(unescapedData);
                  var seiPtr = 0;
                  seiPtr += headerSize;
                  var payloadType = 0;
                  var payloadSize = 0;
                  var endOfCaptions = false;
                  var b = 0;
                  while (seiPtr < data.length) {
                    payloadType = 0;
                    do {
                      if (seiPtr >= data.length) {
                        break;
                      }
                      b = data[seiPtr++];
                      payloadType += b;
                    } while (b === 255);
                    payloadSize = 0;
                    do {
                      if (seiPtr >= data.length) {
                        break;
                      }
                      b = data[seiPtr++];
                      payloadSize += b;
                    } while (b === 255);
                    var leftOver = data.length - seiPtr;
                    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {
                      endOfCaptions = true;
                      var countryCode = data[seiPtr++];
                      if (countryCode === 181) {
                        var providerCode = readUint16(data, seiPtr);
                        seiPtr += 2;
                        if (providerCode === 49) {
                          var userStructure = readUint32(data, seiPtr);
                          seiPtr += 4;
                          if (userStructure === 1195456820) {
                            var userDataType = data[seiPtr++];
                            if (userDataType === 3) {
                              var firstByte = data[seiPtr++];
                              var totalCCs = 31 & firstByte;
                              var enabled = 64 & firstByte;
                              var totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                              var byteArray = new Uint8Array(totalBytes);
                              if (enabled) {
                                byteArray[0] = firstByte;
                                for (var i = 1; i < totalBytes; i++) {
                                  byteArray[i] = data[seiPtr++];
                                }
                              }
                              samples.push({
                                type: userDataType,
                                payloadType,
                                pts,
                                bytes: byteArray
                              });
                            }
                          }
                        }
                      }
                    } else if (payloadType === 5 && payloadSize < leftOver) {
                      endOfCaptions = true;
                      if (payloadSize > 16) {
                        var uuidStrArray = [];
                        for (var _i2 = 0; _i2 < 16; _i2++) {
                          var _b = data[seiPtr++].toString(16);
                          uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
                          if (_i2 === 3 || _i2 === 5 || _i2 === 7 || _i2 === 9) {
                            uuidStrArray.push("-");
                          }
                        }
                        var length = payloadSize - 16;
                        var userDataBytes = new Uint8Array(length);
                        for (var _i3 = 0; _i3 < length; _i3++) {
                          userDataBytes[_i3] = data[seiPtr++];
                        }
                        samples.push({
                          payloadType,
                          pts,
                          uuid: uuidStrArray.join(""),
                          userData: (0, _demux_id3__WEBPACK_IMPORTED_MODULE_2__.utf8ArrayToStr)(userDataBytes),
                          userDataBytes
                        });
                      }
                    } else if (payloadSize < leftOver) {
                      seiPtr += payloadSize;
                    } else if (payloadSize > leftOver) {
                      break;
                    }
                  }
                }
                function discardEPB(data) {
                  var length = data.byteLength;
                  var EPBPositions = [];
                  var i = 1;
                  while (i < length - 2) {
                    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                      EPBPositions.push(i + 2);
                      i += 2;
                    } else {
                      i++;
                    }
                  }
                  if (EPBPositions.length === 0) {
                    return data;
                  }
                  var newLength = length - EPBPositions.length;
                  var newData = new Uint8Array(newLength);
                  var sourceIndex = 0;
                  for (i = 0; i < newLength; sourceIndex++, i++) {
                    if (sourceIndex === EPBPositions[0]) {
                      sourceIndex++;
                      EPBPositions.shift();
                    }
                    newData[i] = data[sourceIndex];
                  }
                  return newData;
                }
                function parseEmsg(data) {
                  var version = data[0];
                  var schemeIdUri = "";
                  var value = "";
                  var timeScale = 0;
                  var presentationTimeDelta = 0;
                  var presentationTime = 0;
                  var eventDuration = 0;
                  var id = 0;
                  var offset = 0;
                  if (version === 0) {
                    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                      offset += 1;
                    }
                    schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                    offset += 1;
                    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                      value += bin2str(data.subarray(offset, offset + 1));
                      offset += 1;
                    }
                    value += bin2str(data.subarray(offset, offset + 1));
                    offset += 1;
                    timeScale = readUint32(data, 12);
                    presentationTimeDelta = readUint32(data, 16);
                    eventDuration = readUint32(data, 20);
                    id = readUint32(data, 24);
                    offset = 28;
                  } else if (version === 1) {
                    offset += 4;
                    timeScale = readUint32(data, offset);
                    offset += 4;
                    var leftPresentationTime = readUint32(data, offset);
                    offset += 4;
                    var rightPresentationTime = readUint32(data, offset);
                    offset += 4;
                    presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;
                    if (!Number.isSafeInteger(presentationTime)) {
                      presentationTime = Number.MAX_SAFE_INTEGER;
                      console.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
                    }
                    eventDuration = readUint32(data, offset);
                    offset += 4;
                    id = readUint32(data, offset);
                    offset += 4;
                    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                      offset += 1;
                    }
                    schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                    offset += 1;
                    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                      value += bin2str(data.subarray(offset, offset + 1));
                      offset += 1;
                    }
                    value += bin2str(data.subarray(offset, offset + 1));
                    offset += 1;
                  }
                  var payload = data.subarray(offset, data.byteLength);
                  return {
                    schemeIdUri,
                    value,
                    timeScale,
                    presentationTime,
                    presentationTimeDelta,
                    eventDuration,
                    id,
                    payload
                  };
                }
                function mp4Box(type) {
                  for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    payload[_key - 1] = arguments[_key];
                  }
                  var len = payload.length;
                  var size = 8;
                  var i = len;
                  while (i--) {
                    size += payload[i].byteLength;
                  }
                  var result = new Uint8Array(size);
                  result[0] = size >> 24 & 255;
                  result[1] = size >> 16 & 255;
                  result[2] = size >> 8 & 255;
                  result[3] = size & 255;
                  result.set(type, 4);
                  for (i = 0, size = 8; i < len; i++) {
                    result.set(payload[i], size);
                    size += payload[i].byteLength;
                  }
                  return result;
                }
                function mp4pssh(systemId, keyids, data) {
                  if (systemId.byteLength !== 16) {
                    throw new RangeError("Invalid system id");
                  }
                  var version;
                  var kids;
                  if (keyids) {
                    version = 1;
                    kids = new Uint8Array(keyids.length * 16);
                    for (var ix = 0; ix < keyids.length; ix++) {
                      var k = keyids[ix];
                      if (k.byteLength !== 16) {
                        throw new RangeError("Invalid key");
                      }
                      kids.set(k, ix * 16);
                    }
                  } else {
                    version = 0;
                    kids = new Uint8Array();
                  }
                  var kidCount;
                  if (version > 0) {
                    kidCount = new Uint8Array(4);
                    if (keyids.length > 0) {
                      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
                    }
                  } else {
                    kidCount = new Uint8Array();
                  }
                  var dataSize = new Uint8Array(4);
                  if (data && data.byteLength > 0) {
                    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
                  }
                  return mp4Box(
                    [112, 115, 115, 104],
                    new Uint8Array([
                      version,
                      0,
                      0,
                      0
                      // Flags
                    ]),
                    systemId,
                    // 16 bytes
                    kidCount,
                    kids,
                    dataSize,
                    data || new Uint8Array()
                  );
                }
                function parsePssh(initData) {
                  if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {
                    return null;
                  }
                  var result = {
                    version: 0,
                    systemId: "",
                    kids: null,
                    data: null
                  };
                  var view = new DataView(initData);
                  var boxSize = view.getUint32(0);
                  if (initData.byteLength !== boxSize && boxSize > 44) {
                    return null;
                  }
                  var type = view.getUint32(4);
                  if (type !== 1886614376) {
                    return null;
                  }
                  result.version = view.getUint32(8) >>> 24;
                  if (result.version > 1) {
                    return null;
                  }
                  result.systemId = _hex__WEBPACK_IMPORTED_MODULE_4__["default"].hexDump(new Uint8Array(initData, 12, 16));
                  var dataSizeOrKidCount = view.getUint32(28);
                  if (result.version === 0) {
                    if (boxSize - 32 < dataSizeOrKidCount) {
                      return null;
                    }
                    result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);
                  } else if (result.version === 1) {
                    result.kids = [];
                    for (var i = 0; i < dataSizeOrKidCount; i++) {
                      result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));
                    }
                  }
                  return result;
                }
              }
            ),
            /***/
            "./src/utils/numeric-encoding-utils.ts": (
              /*!*********************************************!*\
                !*** ./src/utils/numeric-encoding-utils.ts ***!
                \*********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "base64Decode": () => (
                    /* binding */
                    base64Decode
                  ),
                  /* harmony export */
                  "base64DecodeToStr": () => (
                    /* binding */
                    base64DecodeToStr
                  ),
                  /* harmony export */
                  "base64Encode": () => (
                    /* binding */
                    base64Encode
                  ),
                  /* harmony export */
                  "base64ToBase64Url": () => (
                    /* binding */
                    base64ToBase64Url
                  ),
                  /* harmony export */
                  "base64UrlEncode": () => (
                    /* binding */
                    base64UrlEncode
                  ),
                  /* harmony export */
                  "strToBase64Encode": () => (
                    /* binding */
                    strToBase64Encode
                  )
                  /* harmony export */
                });
                function base64ToBase64Url(base64encodedStr) {
                  return base64encodedStr.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
                }
                function strToBase64Encode(str) {
                  return btoa(str);
                }
                function base64DecodeToStr(str) {
                  return atob(str);
                }
                function base64Encode(input) {
                  return btoa(String.fromCharCode.apply(String, input));
                }
                function base64UrlEncode(input) {
                  return base64ToBase64Url(base64Encode(input));
                }
                function base64Decode(base64encodedStr) {
                  return Uint8Array.from(atob(base64encodedStr), function(c) {
                    return c.charCodeAt(0);
                  });
                }
              }
            ),
            /***/
            "./src/utils/output-filter.ts": (
              /*!************************************!*\
                !*** ./src/utils/output-filter.ts ***!
                \************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => (
                    /* binding */
                    OutputFilter
                  )
                  /* harmony export */
                });
                var OutputFilter = function() {
                  function OutputFilter2(timelineController, trackName) {
                    this.timelineController = void 0;
                    this.cueRanges = [];
                    this.trackName = void 0;
                    this.startTime = null;
                    this.endTime = null;
                    this.screen = null;
                    this.timelineController = timelineController;
                    this.trackName = trackName;
                  }
                  var _proto = OutputFilter2.prototype;
                  _proto.dispatchCue = function dispatchCue() {
                    if (this.startTime === null) {
                      return;
                    }
                    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
                    this.startTime = null;
                  };
                  _proto.newCue = function newCue(startTime, endTime, screen) {
                    if (this.startTime === null || this.startTime > startTime) {
                      this.startTime = startTime;
                    }
                    this.endTime = endTime;
                    this.screen = screen;
                    this.timelineController.createCaptionsTrack(this.trackName);
                  };
                  _proto.reset = function reset() {
                    this.cueRanges = [];
                    this.startTime = null;
                  };
                  return OutputFilter2;
                }();
              }
            ),
            /***/
            "./src/utils/texttrack-utils.ts": (
              /*!**************************************!*\
                !*** ./src/utils/texttrack-utils.ts ***!
                \**************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "addCueToTrack": () => (
                    /* binding */
                    addCueToTrack
                  ),
                  /* harmony export */
                  "clearCurrentCues": () => (
                    /* binding */
                    clearCurrentCues
                  ),
                  /* harmony export */
                  "getCuesInRange": () => (
                    /* binding */
                    getCuesInRange
                  ),
                  /* harmony export */
                  "removeCuesInRange": () => (
                    /* binding */
                    removeCuesInRange
                  ),
                  /* harmony export */
                  "sendAddTrackEvent": () => (
                    /* binding */
                    sendAddTrackEvent
                  )
                  /* harmony export */
                });
                var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./logger */
                  "./src/utils/logger.ts"
                );
                function sendAddTrackEvent(track, videoEl) {
                  var event;
                  try {
                    event = new Event("addtrack");
                  } catch (err) {
                    event = document.createEvent("Event");
                    event.initEvent("addtrack", false, false);
                  }
                  event.track = track;
                  videoEl.dispatchEvent(event);
                }
                function addCueToTrack(track, cue) {
                  var mode = track.mode;
                  if (mode === "disabled") {
                    track.mode = "hidden";
                  }
                  if (track.cues && !track.cues.getCueById(cue.id)) {
                    try {
                      track.addCue(cue);
                      if (!track.cues.getCueById(cue.id)) {
                        throw new Error("addCue is failed for: " + cue);
                      }
                    } catch (err) {
                      _logger__WEBPACK_IMPORTED_MODULE_0__.logger.debug("[texttrack-utils]: " + err);
                      var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
                      textTrackCue.id = cue.id;
                      track.addCue(textTrackCue);
                    }
                  }
                  if (mode === "disabled") {
                    track.mode = mode;
                  }
                }
                function clearCurrentCues(track) {
                  var mode = track.mode;
                  if (mode === "disabled") {
                    track.mode = "hidden";
                  }
                  if (track.cues) {
                    for (var i = track.cues.length; i--; ) {
                      track.removeCue(track.cues[i]);
                    }
                  }
                  if (mode === "disabled") {
                    track.mode = mode;
                  }
                }
                function removeCuesInRange(track, start, end, predicate) {
                  var mode = track.mode;
                  if (mode === "disabled") {
                    track.mode = "hidden";
                  }
                  if (track.cues && track.cues.length > 0) {
                    var cues = getCuesInRange(track.cues, start, end);
                    for (var i = 0; i < cues.length; i++) {
                      if (!predicate || predicate(cues[i])) {
                        track.removeCue(cues[i]);
                      }
                    }
                  }
                  if (mode === "disabled") {
                    track.mode = mode;
                  }
                }
                function getFirstCueIndexAfterTime(cues, time) {
                  if (time < cues[0].startTime) {
                    return 0;
                  }
                  var len = cues.length - 1;
                  if (time > cues[len].endTime) {
                    return -1;
                  }
                  var left = 0;
                  var right = len;
                  while (left <= right) {
                    var mid = Math.floor((right + left) / 2);
                    if (time < cues[mid].startTime) {
                      right = mid - 1;
                    } else if (time > cues[mid].startTime && left < len) {
                      left = mid + 1;
                    } else {
                      return mid;
                    }
                  }
                  return cues[left].startTime - time < time - cues[right].startTime ? left : right;
                }
                function getCuesInRange(cues, start, end) {
                  var cuesFound = [];
                  var firstCueInRange = getFirstCueIndexAfterTime(cues, start);
                  if (firstCueInRange > -1) {
                    for (var i = firstCueInRange, len = cues.length; i < len; i++) {
                      var _cue = cues[i];
                      if (_cue.startTime >= start && _cue.endTime <= end) {
                        cuesFound.push(_cue);
                      } else if (_cue.startTime > end) {
                        return cuesFound;
                      }
                    }
                  }
                  return cuesFound;
                }
              }
            ),
            /***/
            "./src/utils/time-ranges.ts": (
              /*!**********************************!*\
                !*** ./src/utils/time-ranges.ts ***!
                \**********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var TimeRanges = {
                  toString: function toString(r) {
                    var log = "";
                    var len = r.length;
                    for (var i = 0; i < len; i++) {
                      log += "[" + r.start(i).toFixed(3) + "-" + r.end(i).toFixed(3) + "]";
                    }
                    return log;
                  }
                };
                const __WEBPACK_DEFAULT_EXPORT__ = TimeRanges;
              }
            ),
            /***/
            "./src/utils/timescale-conversion.ts": (
              /*!*******************************************!*\
                !*** ./src/utils/timescale-conversion.ts ***!
                \*******************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "toMpegTsClockFromTimescale": () => (
                    /* binding */
                    toMpegTsClockFromTimescale
                  ),
                  /* harmony export */
                  "toMsFromMpegTsClock": () => (
                    /* binding */
                    toMsFromMpegTsClock
                  ),
                  /* harmony export */
                  "toTimescaleFromBase": () => (
                    /* binding */
                    toTimescaleFromBase
                  ),
                  /* harmony export */
                  "toTimescaleFromScale": () => (
                    /* binding */
                    toTimescaleFromScale
                  )
                  /* harmony export */
                });
                var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
                function toTimescaleFromBase(value, destScale, srcBase, round) {
                  if (srcBase === void 0) {
                    srcBase = 1;
                  }
                  if (round === void 0) {
                    round = false;
                  }
                  var result = value * destScale * srcBase;
                  return round ? Math.round(result) : result;
                }
                function toTimescaleFromScale(value, destScale, srcScale, round) {
                  if (srcScale === void 0) {
                    srcScale = 1;
                  }
                  if (round === void 0) {
                    round = false;
                  }
                  return toTimescaleFromBase(value, destScale, 1 / srcScale, round);
                }
                function toMsFromMpegTsClock(value, round) {
                  if (round === void 0) {
                    round = false;
                  }
                  return toTimescaleFromBase(value, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
                }
                function toMpegTsClockFromTimescale(value, srcScale) {
                  if (srcScale === void 0) {
                    srcScale = 1;
                  }
                  return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
                }
              }
            ),
            /***/
            "./src/utils/typed-array.ts": (
              /*!**********************************!*\
                !*** ./src/utils/typed-array.ts ***!
                \**********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "sliceUint8": () => (
                    /* binding */
                    sliceUint8
                  )
                  /* harmony export */
                });
                function sliceUint8(array, start, end) {
                  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
                }
              }
            ),
            /***/
            "./src/utils/vttcue.ts": (
              /*!*****************************!*\
                !*** ./src/utils/vttcue.ts ***!
                \*****************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                const __WEBPACK_DEFAULT_EXPORT__ = function() {
                  if (typeof self !== "undefined" && self.VTTCue) {
                    return self.VTTCue;
                  }
                  var AllowedDirections = ["", "lr", "rl"];
                  var AllowedAlignments = ["start", "middle", "end", "left", "right"];
                  function isAllowedValue(allowed, value) {
                    if (typeof value !== "string") {
                      return false;
                    }
                    if (!Array.isArray(allowed)) {
                      return false;
                    }
                    var lcValue = value.toLowerCase();
                    if (~allowed.indexOf(lcValue)) {
                      return lcValue;
                    }
                    return false;
                  }
                  function findDirectionSetting(value) {
                    return isAllowedValue(AllowedDirections, value);
                  }
                  function findAlignSetting(value) {
                    return isAllowedValue(AllowedAlignments, value);
                  }
                  function extend(obj) {
                    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      rest[_key - 1] = arguments[_key];
                    }
                    var i = 1;
                    for (; i < arguments.length; i++) {
                      var cobj = arguments[i];
                      for (var p in cobj) {
                        obj[p] = cobj[p];
                      }
                    }
                    return obj;
                  }
                  function VTTCue(startTime, endTime, text) {
                    var cue = this;
                    var baseObj = {
                      enumerable: true
                    };
                    cue.hasBeenReset = false;
                    var _id = "";
                    var _pauseOnExit = false;
                    var _startTime = startTime;
                    var _endTime = endTime;
                    var _text = text;
                    var _region = null;
                    var _vertical = "";
                    var _snapToLines = true;
                    var _line = "auto";
                    var _lineAlign = "start";
                    var _position = 50;
                    var _positionAlign = "middle";
                    var _size = 50;
                    var _align = "middle";
                    Object.defineProperty(cue, "id", extend({}, baseObj, {
                      get: function get() {
                        return _id;
                      },
                      set: function set(value) {
                        _id = "" + value;
                      }
                    }));
                    Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
                      get: function get() {
                        return _pauseOnExit;
                      },
                      set: function set(value) {
                        _pauseOnExit = !!value;
                      }
                    }));
                    Object.defineProperty(cue, "startTime", extend({}, baseObj, {
                      get: function get() {
                        return _startTime;
                      },
                      set: function set(value) {
                        if (typeof value !== "number") {
                          throw new TypeError("Start time must be set to a number.");
                        }
                        _startTime = value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "endTime", extend({}, baseObj, {
                      get: function get() {
                        return _endTime;
                      },
                      set: function set(value) {
                        if (typeof value !== "number") {
                          throw new TypeError("End time must be set to a number.");
                        }
                        _endTime = value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "text", extend({}, baseObj, {
                      get: function get() {
                        return _text;
                      },
                      set: function set(value) {
                        _text = "" + value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "region", extend({}, baseObj, {
                      get: function get() {
                        return _region;
                      },
                      set: function set(value) {
                        _region = value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "vertical", extend({}, baseObj, {
                      get: function get() {
                        return _vertical;
                      },
                      set: function set(value) {
                        var setting = findDirectionSetting(value);
                        if (setting === false) {
                          throw new SyntaxError("An invalid or illegal string was specified.");
                        }
                        _vertical = setting;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
                      get: function get() {
                        return _snapToLines;
                      },
                      set: function set(value) {
                        _snapToLines = !!value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "line", extend({}, baseObj, {
                      get: function get() {
                        return _line;
                      },
                      set: function set(value) {
                        if (typeof value !== "number" && value !== "auto") {
                          throw new SyntaxError("An invalid number or illegal string was specified.");
                        }
                        _line = value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
                      get: function get() {
                        return _lineAlign;
                      },
                      set: function set(value) {
                        var setting = findAlignSetting(value);
                        if (!setting) {
                          throw new SyntaxError("An invalid or illegal string was specified.");
                        }
                        _lineAlign = setting;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "position", extend({}, baseObj, {
                      get: function get() {
                        return _position;
                      },
                      set: function set(value) {
                        if (value < 0 || value > 100) {
                          throw new Error("Position must be between 0 and 100.");
                        }
                        _position = value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
                      get: function get() {
                        return _positionAlign;
                      },
                      set: function set(value) {
                        var setting = findAlignSetting(value);
                        if (!setting) {
                          throw new SyntaxError("An invalid or illegal string was specified.");
                        }
                        _positionAlign = setting;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "size", extend({}, baseObj, {
                      get: function get() {
                        return _size;
                      },
                      set: function set(value) {
                        if (value < 0 || value > 100) {
                          throw new Error("Size must be between 0 and 100.");
                        }
                        _size = value;
                        this.hasBeenReset = true;
                      }
                    }));
                    Object.defineProperty(cue, "align", extend({}, baseObj, {
                      get: function get() {
                        return _align;
                      },
                      set: function set(value) {
                        var setting = findAlignSetting(value);
                        if (!setting) {
                          throw new SyntaxError("An invalid or illegal string was specified.");
                        }
                        _align = setting;
                        this.hasBeenReset = true;
                      }
                    }));
                    cue.displayState = void 0;
                  }
                  VTTCue.prototype.getCueAsHTML = function() {
                    var WebVTT = self.WebVTT;
                    return WebVTT.convertCueToDOMTree(self, this.text);
                  };
                  return VTTCue;
                }();
              }
            ),
            /***/
            "./src/utils/vttparser.ts": (
              /*!********************************!*\
                !*** ./src/utils/vttparser.ts ***!
                \********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "VTTParser": () => (
                    /* binding */
                    VTTParser
                  ),
                  /* harmony export */
                  "fixLineBreaks": () => (
                    /* binding */
                    fixLineBreaks
                  ),
                  /* harmony export */
                  "parseTimeStamp": () => (
                    /* binding */
                    parseTimeStamp
                  )
                  /* harmony export */
                });
                var _vttcue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./vttcue */
                  "./src/utils/vttcue.ts"
                );
                var StringDecoder = function() {
                  function StringDecoder2() {
                  }
                  var _proto = StringDecoder2.prototype;
                  _proto.decode = function decode(data, options) {
                    if (!data) {
                      return "";
                    }
                    if (typeof data !== "string") {
                      throw new Error("Error - expected string data.");
                    }
                    return decodeURIComponent(encodeURIComponent(data));
                  };
                  return StringDecoder2;
                }();
                function parseTimeStamp(input) {
                  function computeSeconds(h, m2, s, f) {
                    return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + parseFloat(f || 0);
                  }
                  var m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
                  if (!m) {
                    return null;
                  }
                  if (parseFloat(m[2]) > 59) {
                    return computeSeconds(m[2], m[3], 0, m[4]);
                  }
                  return computeSeconds(m[1], m[2], m[3], m[4]);
                }
                var Settings = function() {
                  function Settings2() {
                    this.values = /* @__PURE__ */ Object.create(null);
                  }
                  var _proto2 = Settings2.prototype;
                  _proto2.set = function set(k, v) {
                    if (!this.get(k) && v !== "") {
                      this.values[k] = v;
                    }
                  };
                  _proto2.get = function get(k, dflt, defaultKey) {
                    if (defaultKey) {
                      return this.has(k) ? this.values[k] : dflt[defaultKey];
                    }
                    return this.has(k) ? this.values[k] : dflt;
                  };
                  _proto2.has = function has(k) {
                    return k in this.values;
                  };
                  _proto2.alt = function alt(k, v, a) {
                    for (var n = 0; n < a.length; ++n) {
                      if (v === a[n]) {
                        this.set(k, v);
                        break;
                      }
                    }
                  };
                  _proto2.integer = function integer(k, v) {
                    if (/^-?\d+$/.test(v)) {
                      this.set(k, parseInt(v, 10));
                    }
                  };
                  _proto2.percent = function percent(k, v) {
                    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
                      var percent2 = parseFloat(v);
                      if (percent2 >= 0 && percent2 <= 100) {
                        this.set(k, percent2);
                        return true;
                      }
                    }
                    return false;
                  };
                  return Settings2;
                }();
                function parseOptions(input, callback, keyValueDelim, groupDelim) {
                  var groups = groupDelim ? input.split(groupDelim) : [input];
                  for (var i in groups) {
                    if (typeof groups[i] !== "string") {
                      continue;
                    }
                    var kv = groups[i].split(keyValueDelim);
                    if (kv.length !== 2) {
                      continue;
                    }
                    var _k = kv[0];
                    var _v = kv[1];
                    callback(_k, _v);
                  }
                }
                var defaults = new _vttcue__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, "");
                var center = defaults.align === "middle" ? "middle" : "center";
                function parseCue(input, cue, regionList) {
                  var oInput = input;
                  function consumeTimeStamp() {
                    var ts = parseTimeStamp(input);
                    if (ts === null) {
                      throw new Error("Malformed timestamp: " + oInput);
                    }
                    input = input.replace(/^[^\sa-zA-Z-]+/, "");
                    return ts;
                  }
                  function consumeCueSettings(input2, cue2) {
                    var settings = new Settings();
                    parseOptions(input2, function(k, v) {
                      var vals;
                      switch (k) {
                        case "region":
                          for (var i = regionList.length - 1; i >= 0; i--) {
                            if (regionList[i].id === v) {
                              settings.set(k, regionList[i].region);
                              break;
                            }
                          }
                          break;
                        case "vertical":
                          settings.alt(k, v, ["rl", "lr"]);
                          break;
                        case "line":
                          vals = v.split(",");
                          settings.integer(k, vals[0]);
                          if (settings.percent(k, vals[0])) {
                            settings.set("snapToLines", false);
                          }
                          settings.alt(k, vals[0], ["auto"]);
                          if (vals.length === 2) {
                            settings.alt("lineAlign", vals[1], ["start", center, "end"]);
                          }
                          break;
                        case "position":
                          vals = v.split(",");
                          settings.percent(k, vals[0]);
                          if (vals.length === 2) {
                            settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
                          }
                          break;
                        case "size":
                          settings.percent(k, v);
                          break;
                        case "align":
                          settings.alt(k, v, ["start", center, "end", "left", "right"]);
                          break;
                      }
                    }, /:/, /\s/);
                    cue2.region = settings.get("region", null);
                    cue2.vertical = settings.get("vertical", "");
                    var line = settings.get("line", "auto");
                    if (line === "auto" && defaults.line === -1) {
                      line = -1;
                    }
                    cue2.line = line;
                    cue2.lineAlign = settings.get("lineAlign", "start");
                    cue2.snapToLines = settings.get("snapToLines", true);
                    cue2.size = settings.get("size", 100);
                    cue2.align = settings.get("align", center);
                    var position = settings.get("position", "auto");
                    if (position === "auto" && defaults.position === 50) {
                      position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
                    }
                    cue2.position = position;
                  }
                  function skipWhitespace() {
                    input = input.replace(/^\s+/, "");
                  }
                  skipWhitespace();
                  cue.startTime = consumeTimeStamp();
                  skipWhitespace();
                  if (input.slice(0, 3) !== "-->") {
                    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
                  }
                  input = input.slice(3);
                  skipWhitespace();
                  cue.endTime = consumeTimeStamp();
                  skipWhitespace();
                  consumeCueSettings(input, cue);
                }
                function fixLineBreaks(input) {
                  return input.replace(/<br(?: \/)?>/gi, "\n");
                }
                var VTTParser = function() {
                  function VTTParser2() {
                    this.state = "INITIAL";
                    this.buffer = "";
                    this.decoder = new StringDecoder();
                    this.regionList = [];
                    this.cue = null;
                    this.oncue = void 0;
                    this.onparsingerror = void 0;
                    this.onflush = void 0;
                  }
                  var _proto3 = VTTParser2.prototype;
                  _proto3.parse = function parse(data) {
                    var _this = this;
                    if (data) {
                      _this.buffer += _this.decoder.decode(data, {
                        stream: true
                      });
                    }
                    function collectNextLine() {
                      var buffer = _this.buffer;
                      var pos = 0;
                      buffer = fixLineBreaks(buffer);
                      while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
                        ++pos;
                      }
                      var line2 = buffer.slice(0, pos);
                      if (buffer[pos] === "\r") {
                        ++pos;
                      }
                      if (buffer[pos] === "\n") {
                        ++pos;
                      }
                      _this.buffer = buffer.slice(pos);
                      return line2;
                    }
                    function parseHeader(input) {
                      parseOptions(input, function(k, v) {
                      }, /:/);
                    }
                    try {
                      var line = "";
                      if (_this.state === "INITIAL") {
                        if (!/\r\n|\n/.test(_this.buffer)) {
                          return this;
                        }
                        line = collectNextLine();
                        var m = line.match(/^()?WEBVTT([ \t].*)?$/);
                        if (!m || !m[0]) {
                          throw new Error("Malformed WebVTT signature.");
                        }
                        _this.state = "HEADER";
                      }
                      var alreadyCollectedLine = false;
                      while (_this.buffer) {
                        if (!/\r\n|\n/.test(_this.buffer)) {
                          return this;
                        }
                        if (!alreadyCollectedLine) {
                          line = collectNextLine();
                        } else {
                          alreadyCollectedLine = false;
                        }
                        switch (_this.state) {
                          case "HEADER":
                            if (/:/.test(line)) {
                              parseHeader(line);
                            } else if (!line) {
                              _this.state = "ID";
                            }
                            continue;
                          case "NOTE":
                            if (!line) {
                              _this.state = "ID";
                            }
                            continue;
                          case "ID":
                            if (/^NOTE($|[ \t])/.test(line)) {
                              _this.state = "NOTE";
                              break;
                            }
                            if (!line) {
                              continue;
                            }
                            _this.cue = new _vttcue__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, "");
                            _this.state = "CUE";
                            if (line.indexOf("-->") === -1) {
                              _this.cue.id = line;
                              continue;
                            }
                          case "CUE":
                            if (!_this.cue) {
                              _this.state = "BADCUE";
                              continue;
                            }
                            try {
                              parseCue(line, _this.cue, _this.regionList);
                            } catch (e) {
                              _this.cue = null;
                              _this.state = "BADCUE";
                              continue;
                            }
                            _this.state = "CUETEXT";
                            continue;
                          case "CUETEXT":
                            {
                              var hasSubstring = line.indexOf("-->") !== -1;
                              if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                                if (_this.oncue && _this.cue) {
                                  _this.oncue(_this.cue);
                                }
                                _this.cue = null;
                                _this.state = "ID";
                                continue;
                              }
                              if (_this.cue === null) {
                                continue;
                              }
                              if (_this.cue.text) {
                                _this.cue.text += "\n";
                              }
                              _this.cue.text += line;
                            }
                            continue;
                          case "BADCUE":
                            if (!line) {
                              _this.state = "ID";
                            }
                        }
                      }
                    } catch (e) {
                      if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
                        _this.oncue(_this.cue);
                      }
                      _this.cue = null;
                      _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
                    }
                    return this;
                  };
                  _proto3.flush = function flush() {
                    var _this = this;
                    try {
                      if (_this.cue || _this.state === "HEADER") {
                        _this.buffer += "\n\n";
                        _this.parse();
                      }
                      if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
                        throw new Error("Malformed WebVTT signature.");
                      }
                    } catch (e) {
                      if (_this.onparsingerror) {
                        _this.onparsingerror(e);
                      }
                    }
                    if (_this.onflush) {
                      _this.onflush();
                    }
                    return this;
                  };
                  return VTTParser2;
                }();
              }
            ),
            /***/
            "./src/utils/webvtt-parser.ts": (
              /*!************************************!*\
                !*** ./src/utils/webvtt-parser.ts ***!
                \************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "generateCueId": () => (
                    /* binding */
                    generateCueId
                  ),
                  /* harmony export */
                  "parseWebVTT": () => (
                    /* binding */
                    parseWebVTT
                  )
                  /* harmony export */
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./src/polyfills/number */
                  "./src/polyfills/number.ts"
                );
                var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./vttparser */
                  "./src/utils/vttparser.ts"
                );
                var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ../demux/id3 */
                  "./src/demux/id3.ts"
                );
                var _timescale_conversion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./timescale-conversion */
                  "./src/utils/timescale-conversion.ts"
                );
                var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ../remux/mp4-remuxer */
                  "./src/remux/mp4-remuxer.ts"
                );
                var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
                var startsWith = function startsWith2(inputString, searchString, position) {
                  if (position === void 0) {
                    position = 0;
                  }
                  return inputString.slice(position, position + searchString.length) === searchString;
                };
                var cueString2millis = function cueString2millis2(timeString) {
                  var ts = parseInt(timeString.slice(-3));
                  var secs = parseInt(timeString.slice(-6, -4));
                  var mins = parseInt(timeString.slice(-9, -7));
                  var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
                  if (!(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(ts) || !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(secs) || !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(mins) || !(0, _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__.isFiniteNumber)(hours)) {
                    throw Error("Malformed X-TIMESTAMP-MAP: Local:" + timeString);
                  }
                  ts += 1e3 * secs;
                  ts += 60 * 1e3 * mins;
                  ts += 60 * 60 * 1e3 * hours;
                  return ts;
                };
                var hash = function hash2(text) {
                  var hash3 = 5381;
                  var i = text.length;
                  while (i) {
                    hash3 = hash3 * 33 ^ text.charCodeAt(--i);
                  }
                  return (hash3 >>> 0).toString();
                };
                function generateCueId(startTime, endTime, text) {
                  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
                }
                var calculateOffset = function calculateOffset2(vttCCs, cc, presentationTime) {
                  var currCC = vttCCs[cc];
                  var prevCC = vttCCs[currCC.prevCC];
                  if (!prevCC || !prevCC.new && currCC.new) {
                    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
                    currCC.new = false;
                    return;
                  }
                  while ((_prevCC = prevCC) !== null && _prevCC !== void 0 && _prevCC.new) {
                    var _prevCC;
                    vttCCs.ccOffset += currCC.start - prevCC.start;
                    currCC.new = false;
                    currCC = prevCC;
                    prevCC = vttCCs[currCC.prevCC];
                  }
                  vttCCs.presentationOffset = presentationTime;
                };
                function parseWebVTT(vttByteArray, initPTS, timescale, vttCCs, cc, timeOffset, callBack, errorCallBack) {
                  var parser = new _vttparser__WEBPACK_IMPORTED_MODULE_1__.VTTParser();
                  var vttLines = (0, _demux_id3__WEBPACK_IMPORTED_MODULE_2__.utf8ArrayToStr)(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, "\n").split("\n");
                  var cues = [];
                  var initPTS90Hz = (0, _timescale_conversion__WEBPACK_IMPORTED_MODULE_3__.toMpegTsClockFromTimescale)(initPTS, timescale);
                  var cueTime = "00:00.000";
                  var timestampMapMPEGTS = 0;
                  var timestampMapLOCAL = 0;
                  var parsingError;
                  var inHeader = true;
                  parser.oncue = function(cue) {
                    var currCC = vttCCs[cc];
                    var cueOffset = vttCCs.ccOffset;
                    var webVttMpegTsMapOffset = (timestampMapMPEGTS - initPTS90Hz) / 9e4;
                    if (currCC !== null && currCC !== void 0 && currCC.new) {
                      if (timestampMapLOCAL !== void 0) {
                        cueOffset = vttCCs.ccOffset = currCC.start;
                      } else {
                        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
                      }
                    }
                    if (webVttMpegTsMapOffset) {
                      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
                    }
                    var duration = cue.endTime - cue.startTime;
                    var startTime = (0, _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__.normalizePts)((cue.startTime + cueOffset - timestampMapLOCAL) * 9e4, timeOffset * 9e4) / 9e4;
                    cue.startTime = Math.max(startTime, 0);
                    cue.endTime = Math.max(startTime + duration, 0);
                    var text = cue.text.trim();
                    cue.text = decodeURIComponent(encodeURIComponent(text));
                    if (!cue.id) {
                      cue.id = generateCueId(cue.startTime, cue.endTime, text);
                    }
                    if (cue.endTime > 0) {
                      cues.push(cue);
                    }
                  };
                  parser.onparsingerror = function(error) {
                    parsingError = error;
                  };
                  parser.onflush = function() {
                    if (parsingError) {
                      errorCallBack(parsingError);
                      return;
                    }
                    callBack(cues);
                  };
                  vttLines.forEach(function(line) {
                    if (inHeader) {
                      if (startsWith(line, "X-TIMESTAMP-MAP=")) {
                        inHeader = false;
                        line.slice(16).split(",").forEach(function(timestamp) {
                          if (startsWith(timestamp, "LOCAL:")) {
                            cueTime = timestamp.slice(6);
                          } else if (startsWith(timestamp, "MPEGTS:")) {
                            timestampMapMPEGTS = parseInt(timestamp.slice(7));
                          }
                        });
                        try {
                          timestampMapLOCAL = cueString2millis(cueTime) / 1e3;
                        } catch (error) {
                          parsingError = error;
                        }
                        return;
                      } else if (line === "") {
                        inHeader = false;
                      }
                    }
                    parser.parse(line + "\n");
                  });
                  parser.flush();
                }
              }
            ),
            /***/
            "./src/utils/xhr-loader.ts": (
              /*!*********************************!*\
                !*** ./src/utils/xhr-loader.ts ***!
                \*********************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../utils/logger */
                  "./src/utils/logger.ts"
                );
                var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../loader/load-stats */
                  "./src/loader/load-stats.ts"
                );
                var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/m;
                var XhrLoader = function() {
                  function XhrLoader2(config) {
                    this.xhrSetup = void 0;
                    this.requestTimeout = void 0;
                    this.retryTimeout = void 0;
                    this.retryDelay = void 0;
                    this.config = null;
                    this.callbacks = null;
                    this.context = void 0;
                    this.loader = null;
                    this.stats = void 0;
                    this.xhrSetup = config ? config.xhrSetup : null;
                    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__.LoadStats();
                    this.retryDelay = 0;
                  }
                  var _proto = XhrLoader2.prototype;
                  _proto.destroy = function destroy() {
                    this.callbacks = null;
                    this.abortInternal();
                    this.loader = null;
                    this.config = null;
                  };
                  _proto.abortInternal = function abortInternal() {
                    var loader = this.loader;
                    self.clearTimeout(this.requestTimeout);
                    self.clearTimeout(this.retryTimeout);
                    if (loader) {
                      loader.onreadystatechange = null;
                      loader.onprogress = null;
                      if (loader.readyState !== 4) {
                        this.stats.aborted = true;
                        loader.abort();
                      }
                    }
                  };
                  _proto.abort = function abort() {
                    var _this$callbacks;
                    this.abortInternal();
                    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {
                      this.callbacks.onAbort(this.stats, this.context, this.loader);
                    }
                  };
                  _proto.load = function load(context, config, callbacks) {
                    if (this.stats.loading.start) {
                      throw new Error("Loader can only be used once.");
                    }
                    this.stats.loading.start = self.performance.now();
                    this.context = context;
                    this.config = config;
                    this.callbacks = callbacks;
                    this.retryDelay = config.retryDelay;
                    this.loadInternal();
                  };
                  _proto.loadInternal = function loadInternal() {
                    var config = this.config, context = this.context;
                    if (!config) {
                      return;
                    }
                    var xhr = this.loader = new self.XMLHttpRequest();
                    var stats = this.stats;
                    stats.loading.first = 0;
                    stats.loaded = 0;
                    var xhrSetup = this.xhrSetup;
                    try {
                      if (xhrSetup) {
                        try {
                          xhrSetup(xhr, context.url);
                        } catch (e) {
                          xhr.open("GET", context.url, true);
                          xhrSetup(xhr, context.url);
                        }
                      }
                      if (!xhr.readyState) {
                        xhr.open("GET", context.url, true);
                      }
                      var headers = this.context.headers;
                      if (headers) {
                        for (var header in headers) {
                          xhr.setRequestHeader(header, headers[header]);
                        }
                      }
                    } catch (e) {
                      this.callbacks.onError({
                        code: xhr.status,
                        text: e.message
                      }, context, xhr);
                      return;
                    }
                    if (context.rangeEnd) {
                      xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
                    }
                    xhr.onreadystatechange = this.readystatechange.bind(this);
                    xhr.onprogress = this.loadprogress.bind(this);
                    xhr.responseType = context.responseType;
                    self.clearTimeout(this.requestTimeout);
                    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
                    xhr.send();
                  };
                  _proto.readystatechange = function readystatechange() {
                    var context = this.context, xhr = this.loader, stats = this.stats;
                    if (!context || !xhr) {
                      return;
                    }
                    var readyState = xhr.readyState;
                    var config = this.config;
                    if (stats.aborted) {
                      return;
                    }
                    if (readyState >= 2) {
                      self.clearTimeout(this.requestTimeout);
                      if (stats.loading.first === 0) {
                        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
                      }
                      if (readyState === 4) {
                        xhr.onreadystatechange = null;
                        xhr.onprogress = null;
                        var status = xhr.status;
                        var isArrayBuffer = xhr.responseType === "arraybuffer";
                        if (status >= 200 && status < 300 && (isArrayBuffer && xhr.response || xhr.responseText !== null)) {
                          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
                          var data;
                          var len;
                          if (isArrayBuffer) {
                            data = xhr.response;
                            len = data.byteLength;
                          } else {
                            data = xhr.responseText;
                            len = data.length;
                          }
                          stats.loaded = stats.total = len;
                          if (!this.callbacks) {
                            return;
                          }
                          var onProgress = this.callbacks.onProgress;
                          if (onProgress) {
                            onProgress(stats, context, data, xhr);
                          }
                          if (!this.callbacks) {
                            return;
                          }
                          var response = {
                            url: xhr.responseURL,
                            data
                          };
                          this.callbacks.onSuccess(response, stats, context, xhr);
                        } else {
                          if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.error(status + " while loading " + context.url);
                            this.callbacks.onError({
                              code: status,
                              text: xhr.statusText
                            }, context, xhr);
                          } else {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.warn(status + " while loading " + context.url + ", retrying in " + this.retryDelay + "...");
                            this.abortInternal();
                            this.loader = null;
                            self.clearTimeout(this.retryTimeout);
                            this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                            this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                            stats.retry++;
                          }
                        }
                      } else {
                        self.clearTimeout(this.requestTimeout);
                        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
                      }
                    }
                  };
                  _proto.loadtimeout = function loadtimeout() {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_0__.logger.warn("timeout while loading " + this.context.url);
                    var callbacks = this.callbacks;
                    if (callbacks) {
                      this.abortInternal();
                      callbacks.onTimeout(this.stats, this.context, this.loader);
                    }
                  };
                  _proto.loadprogress = function loadprogress(event) {
                    var stats = this.stats;
                    stats.loaded = event.loaded;
                    if (event.lengthComputable) {
                      stats.total = event.total;
                    }
                  };
                  _proto.getCacheAge = function getCacheAge() {
                    var result = null;
                    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
                      var ageHeader = this.loader.getResponseHeader("age");
                      result = ageHeader ? parseFloat(ageHeader) : null;
                    }
                    return result;
                  };
                  return XhrLoader2;
                }();
                const __WEBPACK_DEFAULT_EXPORT__ = XhrLoader;
              }
            ),
            /***/
            "./node_modules/eventemitter3/index.js": (
              /*!*********************************************!*\
                !*** ./node_modules/eventemitter3/index.js ***!
                \*********************************************/
              /***/
              (module2) => {
                "use strict";
                var has = Object.prototype.hasOwnProperty, prefix = "~";
                function Events() {
                }
                if (Object.create) {
                  Events.prototype = /* @__PURE__ */ Object.create(null);
                  if (!new Events().__proto__)
                    prefix = false;
                }
                function EE(fn, context, once) {
                  this.fn = fn;
                  this.context = context;
                  this.once = once || false;
                }
                function addListener(emitter, event, fn, context, once) {
                  if (typeof fn !== "function") {
                    throw new TypeError("The listener must be a function");
                  }
                  var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
                  if (!emitter._events[evt])
                    emitter._events[evt] = listener, emitter._eventsCount++;
                  else if (!emitter._events[evt].fn)
                    emitter._events[evt].push(listener);
                  else
                    emitter._events[evt] = [emitter._events[evt], listener];
                  return emitter;
                }
                function clearEvent(emitter, evt) {
                  if (--emitter._eventsCount === 0)
                    emitter._events = new Events();
                  else
                    delete emitter._events[evt];
                }
                function EventEmitter() {
                  this._events = new Events();
                  this._eventsCount = 0;
                }
                EventEmitter.prototype.eventNames = function eventNames() {
                  var names = [], events, name;
                  if (this._eventsCount === 0)
                    return names;
                  for (name in events = this._events) {
                    if (has.call(events, name))
                      names.push(prefix ? name.slice(1) : name);
                  }
                  if (Object.getOwnPropertySymbols) {
                    return names.concat(Object.getOwnPropertySymbols(events));
                  }
                  return names;
                };
                EventEmitter.prototype.listeners = function listeners(event) {
                  var evt = prefix ? prefix + event : event, handlers = this._events[evt];
                  if (!handlers)
                    return [];
                  if (handlers.fn)
                    return [handlers.fn];
                  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
                    ee[i] = handlers[i].fn;
                  }
                  return ee;
                };
                EventEmitter.prototype.listenerCount = function listenerCount(event) {
                  var evt = prefix ? prefix + event : event, listeners = this._events[evt];
                  if (!listeners)
                    return 0;
                  if (listeners.fn)
                    return 1;
                  return listeners.length;
                };
                EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                  var evt = prefix ? prefix + event : event;
                  if (!this._events[evt])
                    return false;
                  var listeners = this._events[evt], len = arguments.length, args, i;
                  if (listeners.fn) {
                    if (listeners.once)
                      this.removeListener(event, listeners.fn, void 0, true);
                    switch (len) {
                      case 1:
                        return listeners.fn.call(listeners.context), true;
                      case 2:
                        return listeners.fn.call(listeners.context, a1), true;
                      case 3:
                        return listeners.fn.call(listeners.context, a1, a2), true;
                      case 4:
                        return listeners.fn.call(listeners.context, a1, a2, a3), true;
                      case 5:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                      case 6:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                    }
                    for (i = 1, args = new Array(len - 1); i < len; i++) {
                      args[i - 1] = arguments[i];
                    }
                    listeners.fn.apply(listeners.context, args);
                  } else {
                    var length = listeners.length, j;
                    for (i = 0; i < length; i++) {
                      if (listeners[i].once)
                        this.removeListener(event, listeners[i].fn, void 0, true);
                      switch (len) {
                        case 1:
                          listeners[i].fn.call(listeners[i].context);
                          break;
                        case 2:
                          listeners[i].fn.call(listeners[i].context, a1);
                          break;
                        case 3:
                          listeners[i].fn.call(listeners[i].context, a1, a2);
                          break;
                        case 4:
                          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                          break;
                        default:
                          if (!args)
                            for (j = 1, args = new Array(len - 1); j < len; j++) {
                              args[j - 1] = arguments[j];
                            }
                          listeners[i].fn.apply(listeners[i].context, args);
                      }
                    }
                  }
                  return true;
                };
                EventEmitter.prototype.on = function on(event, fn, context) {
                  return addListener(this, event, fn, context, false);
                };
                EventEmitter.prototype.once = function once(event, fn, context) {
                  return addListener(this, event, fn, context, true);
                };
                EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                  var evt = prefix ? prefix + event : event;
                  if (!this._events[evt])
                    return this;
                  if (!fn) {
                    clearEvent(this, evt);
                    return this;
                  }
                  var listeners = this._events[evt];
                  if (listeners.fn) {
                    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                      clearEvent(this, evt);
                    }
                  } else {
                    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                        events.push(listeners[i]);
                      }
                    }
                    if (events.length)
                      this._events[evt] = events.length === 1 ? events[0] : events;
                    else
                      clearEvent(this, evt);
                  }
                  return this;
                };
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                  var evt;
                  if (event) {
                    evt = prefix ? prefix + event : event;
                    if (this._events[evt])
                      clearEvent(this, evt);
                  } else {
                    this._events = new Events();
                    this._eventsCount = 0;
                  }
                  return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.addListener = EventEmitter.prototype.on;
                EventEmitter.prefixed = prefix;
                EventEmitter.EventEmitter = EventEmitter;
                if (true) {
                  module2.exports = EventEmitter;
                }
              }
            ),
            /***/
            "./node_modules/url-toolkit/src/url-toolkit.js": (
              /*!*****************************************************!*\
                !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
                \*****************************************************/
              /***/
              function(module2) {
                (function(root) {
                  var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
                  var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
                  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
                  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
                  var URLToolkit = {
                    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
                    // E.g
                    // With opts.alwaysNormalize = false (default, spec compliant)
                    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
                    // With opts.alwaysNormalize = true (not spec compliant)
                    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
                    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
                      opts = opts || {};
                      baseURL = baseURL.trim();
                      relativeURL = relativeURL.trim();
                      if (!relativeURL) {
                        if (!opts.alwaysNormalize) {
                          return baseURL;
                        }
                        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
                        if (!basePartsForNormalise) {
                          throw new Error("Error trying to parse base URL.");
                        }
                        basePartsForNormalise.path = URLToolkit.normalizePath(
                          basePartsForNormalise.path
                        );
                        return URLToolkit.buildURLFromParts(basePartsForNormalise);
                      }
                      var relativeParts = URLToolkit.parseURL(relativeURL);
                      if (!relativeParts) {
                        throw new Error("Error trying to parse relative URL.");
                      }
                      if (relativeParts.scheme) {
                        if (!opts.alwaysNormalize) {
                          return relativeURL;
                        }
                        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
                        return URLToolkit.buildURLFromParts(relativeParts);
                      }
                      var baseParts = URLToolkit.parseURL(baseURL);
                      if (!baseParts) {
                        throw new Error("Error trying to parse base URL.");
                      }
                      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
                        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
                        baseParts.netLoc = pathParts[1];
                        baseParts.path = pathParts[2];
                      }
                      if (baseParts.netLoc && !baseParts.path) {
                        baseParts.path = "/";
                      }
                      var builtParts = {
                        // 2c) Otherwise, the embedded URL inherits the scheme of
                        // the base URL.
                        scheme: baseParts.scheme,
                        netLoc: relativeParts.netLoc,
                        path: null,
                        params: relativeParts.params,
                        query: relativeParts.query,
                        fragment: relativeParts.fragment
                      };
                      if (!relativeParts.netLoc) {
                        builtParts.netLoc = baseParts.netLoc;
                        if (relativeParts.path[0] !== "/") {
                          if (!relativeParts.path) {
                            builtParts.path = baseParts.path;
                            if (!relativeParts.params) {
                              builtParts.params = baseParts.params;
                              if (!relativeParts.query) {
                                builtParts.query = baseParts.query;
                              }
                            }
                          } else {
                            var baseURLPath = baseParts.path;
                            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                            builtParts.path = URLToolkit.normalizePath(newPath);
                          }
                        }
                      }
                      if (builtParts.path === null) {
                        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
                      }
                      return URLToolkit.buildURLFromParts(builtParts);
                    },
                    parseURL: function(url) {
                      var parts = URL_REGEX.exec(url);
                      if (!parts) {
                        return null;
                      }
                      return {
                        scheme: parts[1] || "",
                        netLoc: parts[2] || "",
                        path: parts[3] || "",
                        params: parts[4] || "",
                        query: parts[5] || "",
                        fragment: parts[6] || ""
                      };
                    },
                    normalizePath: function(path) {
                      path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
                      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
                      }
                      return path.split("").reverse().join("");
                    },
                    buildURLFromParts: function(parts) {
                      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
                    }
                  };
                  if (true)
                    module2.exports = URLToolkit;
                  else {
                  }
                })(this);
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          __webpack_require__.m = __webpack_modules__;
          (() => {
            __webpack_require__.n = (module2) => {
              var getter = module2 && module2.__esModule ? (
                /******/
                () => module2["default"]
              ) : (
                /******/
                () => module2
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          var __webpack_exports__ = __webpack_require__("./src/hls.ts");
          __webpack_exports__ = __webpack_exports__["default"];
          return __webpack_exports__;
        })()
      );
    });
  }
});
export default require_hls();
//# sourceMappingURL=hls-IDM4AB4P.js.map
